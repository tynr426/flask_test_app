1
00:00:05,250 --> 00:00:07,430
斯坦福大学

2
00:00:08,810 --> 00:00:14,910
欢迎来到2013/14学年秋季CS193P课程第三讲

3
00:00:14,910 --> 00:00:18,670
今天我将直接跳到一个demo

4
00:00:18,670 --> 00:00:20,920
然后我有一些幻灯片

5
00:00:20,920 --> 00:00:25,890
假设demo不需要整堂课时间

6
00:00:25,890 --> 00:00:28,190
demo要做的是

7
00:00:28,190 --> 00:00:33,990
将上周我们做的纸牌工作用到真正的纸牌匹配游戏

8
00:00:33,990 --> 00:00:37,710
我们将真正开始匹配 而不只是翻来翻去

9
00:00:37,710 --> 00:00:39,640
如果时间允许

10
00:00:39,640 --> 00:00:42,640
我还会进一步讲Objective-C

11
00:00:42,640 --> 00:00:46,050
周三我将非常详细地讲到Objective-C

12
00:00:46,050 --> 00:00:50,830
我还附上了一些复习幻灯片在最后

13
00:00:50,830 --> 00:00:54,180
复习前三讲我们所学的内容

14
00:00:54,180 --> 00:00:56,740
让你们能够快速回顾 并问自己是否理解

15
00:00:56,740 --> 00:00:57,860
让你们能够快速回顾 并问自己是否理解

16
00:00:57,860 --> 00:01:02,640
如果不记得 你显然需要发帖向我们提问

17
00:01:02,640 --> 00:01:07,330
好 我们来做这个demo

18
00:01:07,330 --> 00:01:08,950
demo是这样的

19
00:01:08,950 --> 00:01:12,820
实际上 在demo最开始

20
00:01:12,820 --> 00:01:17,160
我将公布作业的答案

21
00:01:17,160 --> 00:01:20,540
我讲过我要做这个的 本学期只有一次我会这样做

22
00:01:20,540 --> 00:01:23,350
我讲过我要做这个的 本学期只有一次我会这样做

23
00:01:23,350 --> 00:01:25,600
一般我不会讲答案

24
00:01:25,600 --> 00:01:29,500
但这里答案很简单 而且需要知道这些答案

25
00:01:29,500 --> 00:01:32,920
我们才能继续今天后面的内容

26
00:01:32,920 --> 00:01:34,700
所以先看答案

27
00:01:34,700 --> 00:01:36,710
这里我启动了XCode

28
00:01:36,710 --> 00:01:40,630
最近文件中有上次编辑的Machismo

29
00:01:40,630 --> 00:01:43,540
打开这个

30
00:01:43,540 --> 00:01:45,920
好了 确保我们使用了

31
00:01:45,920 --> 00:01:49,130
尽量多的屏幕空间

32
00:01:49,130 --> 00:01:52,930
把这些线挪开

33
00:01:52,930 --> 00:01:59,700
好 从上次结束的地方开始 你们做过作业 应该记得

34
00:01:59,700 --> 00:02:02,070
我们有这一张牌

35
00:02:02,070 --> 00:02:04,640
它在梅花A和反面间来回翻动

36
00:02:04,640 --> 00:02:08,700
你们的作业是在课上模型的基础上

37
00:02:08,700 --> 00:02:11,810
让它从整个牌堆中抽牌翻转

38
00:02:11,810 --> 00:02:15,200
这个答案非常简单

39
00:02:15,200 --> 00:02:18,340
我们显然需要牌堆

40
00:02:18,340 --> 00:02:22,510
我将添加一个属性 强属性 必须是强的

41
00:02:22,510 --> 00:02:25,390
因为我们需要牌堆一直存在

42
00:02:25,390 --> 00:02:27,840
它是牌堆 取名deck

43
00:02:27,840 --> 00:02:31,280
因为deck 这里有个错误

44
00:02:31,280 --> 00:02:34,680
所以我们需要到上面这里 导入Deck

45
00:02:34,680 --> 00:02:36,510
这样错误就没有了

46
00:02:36,510 --> 00:02:39,440
现在我们有了这个属性 这很酷

47
00:02:39,440 --> 00:02:43,820
显然 我们希望使用惰性实例化来实例化这一属性

48
00:02:43,820 --> 00:02:46,700
所以我在这里输入 (Deck *)deck

49
00:02:46,710 --> 00:02:51,180
我要看我的实例变量是否为nil

50
00:02:51,180 --> 00:02:54,140
基本上也就是 是否为0

51
00:02:54,140 --> 00:02:59,810
然后是_deck =

52
00:02:59,810 --> 00:03:03,150
我将使用另一个方法来创建deck

53
00:03:03,150 --> 00:03:07,620
等下你们就知道为什么了 然后返回_deck

54
00:03:07,620 --> 00:03:12,920
createDeck将会创建一个牌堆

55
00:03:12,920 --> 00:03:16,680
createDeck 我将创建一个扑克牌堆

56
00:03:16,680 --> 00:03:19,450
因为这就是我要求你们做的

57
00:03:19,450 --> 00:03:22,300
这里用alloc init来做这个

58
00:03:22,300 --> 00:03:26,280
这里有个错误 因为只导入Deck是不行的

59
00:03:26,280 --> 00:03:28,410
我们需要导入PlayingCardDeck

60
00:03:28,410 --> 00:03:33,420
很不幸的是 这里我要创建一个通用的纸牌游戏

61
00:03:33,420 --> 00:03:36,310
结果却要导入扑克牌堆

62
00:03:36,310 --> 00:03:38,060
为什么说这很不幸呢

63
00:03:38,060 --> 00:03:40,850
这里我要尝试创建一个纸牌游戏

64
00:03:40,850 --> 00:03:43,380
它同扑克牌没有任何关系

65
00:03:43,380 --> 00:03:44,860
它是通用的

66
00:03:44,860 --> 00:03:48,010
应该对任何牌堆都适用

67
00:03:48,010 --> 00:03:50,760
实际上 在你们的作业中

68
00:03:50,760 --> 00:03:55,980
你们下周会被要求考虑不同牌堆 来增强游戏

69
00:03:55,980 --> 00:03:59,660
所以说 这里需要这样做是很不幸的

70
00:03:59,660 --> 00:04:05,020
在周三或周一 我将讨论如何把这个除掉

71
00:04:05,020 --> 00:04:07,340
不再导入PlayingCardDeck

72
00:04:07,340 --> 00:04:11,990
让这个createDeck方法更具通用性

73
00:04:11,990 --> 00:04:15,670
而不仅仅适用于扑克牌

74
00:04:15,670 --> 00:04:18,660
无论如何 这里我有了这个deck

75
00:04:18,660 --> 00:04:21,560
它是惰性实例化的 有了deck后

76
00:04:21,560 --> 00:04:27,620
我就可以用它来替换这个梅花A了

77
00:04:27,620 --> 00:04:34,160
我可以这样做 这里加入Card *card

78
00:04:34,160 --> 00:04:37,740
= [self.deck drawRandomCard]

79
00:04:37,740 --> 00:04:40,340
我将从牌堆中随机抽取一张牌

80
00:04:40,340 --> 00:04:42,320
然后这里不再是梅花A

81
00:04:42,320 --> 00:04:45,200
将它改为纸牌内容

82
00:04:45,200 --> 00:04:49,440
这就是你们所有的作业内容

83
00:04:49,440 --> 00:04:54,580
这里我还要做两个小的改动

84
00:04:54,580 --> 00:04:57,470
因为我们的答案不是能够工作就行

85
00:04:57,470 --> 00:05:00,400
运行这个确实能够工作

86
00:05:00,420 --> 00:05:03,780
能够工作 但并不优雅

87
00:05:03,780 --> 00:05:07,170
这不能算一个很好的答案

88
00:05:07,170 --> 00:05:09,990
虽然它能够达到目的

89
00:05:09,990 --> 00:05:12,610
可以看到 它会随机出牌

90
00:05:12,610 --> 00:05:15,270
但有几点比较让人不爽

91
00:05:15,270 --> 00:05:18,820
一是它会从梅花A开始 这很毛糙

92
00:05:18,820 --> 00:05:20,640
因为一直点击这里

93
00:05:20,640 --> 00:05:24,360
最终我会重新得到梅花A 这就是了

94
00:05:24,360 --> 00:05:26,290
这很糟糕

95
00:05:26,290 --> 00:05:28,860
另一点是 当牌堆为空时

96
00:05:28,860 --> 00:05:34,240
这个将没法善终

97
00:05:34,240 --> 00:05:36,490
我们需要优雅的答案

98
00:05:36,490 --> 00:05:38,870
提示中就涉及到过

99
00:05:38,870 --> 00:05:43,170
然后是翻转计数 纸牌用完后 它还会持续计数

100
00:05:43,170 --> 00:05:47,820
它会增加到102 103 104 105 这不很优雅

101
00:05:47,820 --> 00:05:52,480
让我们来修正上述三点 得到简单优雅的答案

102
00:05:52,480 --> 00:05:55,400
对于梅花A 我的简单优雅答案

103
00:05:55,400 --> 00:06:00,340
是从反面开始 这个我其实提示过

104
00:06:00,340 --> 00:06:03,730
我将用到cardback 除掉梅花A

105
00:06:03,730 --> 00:06:05,720
这时就是从反面开始了

106
00:06:05,720 --> 00:06:08,810
我根本都不需要写任何代码

107
00:06:08,810 --> 00:06:13,450
直接在这里点几下就行了

108
00:06:13,450 --> 00:06:17,000
这是解决那一问题的优雅方式

109
00:06:17,000 --> 00:06:18,690
我们将从正面朝下开始

110
00:06:18,690 --> 00:06:21,990
没有人要求一定要梅花A正面朝上

111
00:06:21,990 --> 00:06:24,310
这是很好的解决办法

112
00:06:24,310 --> 00:06:26,810
而对于纸牌用完的情况

113
00:06:26,810 --> 00:06:31,160
我认为最优雅的解决办法是 这时就停止翻动

114
00:06:31,160 --> 00:06:34,300
你当然也可以再加载一副牌

115
00:06:34,300 --> 00:06:37,590
不过我认为最简单的解决办法是

116
00:06:37,590 --> 00:06:40,270
牌用完时 再点就不翻了

117
00:06:40,270 --> 00:06:42,330
这怎么做到呢

118
00:06:42,330 --> 00:06:44,870
我知道你们有些人会说

119
00:06:44,870 --> 00:06:48,540
如果翻转次数为102 那么停止翻动

120
00:06:48,540 --> 00:06:50,210
这非常糟糕

121
00:06:50,210 --> 00:06:52,060
这是非常糟糕的设计

122
00:06:52,060 --> 00:06:56,010
因为102就像一个你加入到程序中的神奇数字

123
00:06:56,010 --> 00:06:59,150
而且这种糟糕设计完全没有理由

124
00:06:59,150 --> 00:07:02,750
你只需要说 if (card)

125
00:07:02,750 --> 00:07:05,640
那么翻转

126
00:07:05,640 --> 00:07:08,470
这些表示翻转

127
00:07:08,470 --> 00:07:11,650
空出一点空间 这样更清楚一些

128
00:07:11,650 --> 00:07:14,750
否则 牌就不会翻动

129
00:07:14,750 --> 00:07:19,220
这是超级优雅的解决办法

130
00:07:19,220 --> 00:07:23,540
牌堆中牌用完时 这里就将不再翻动

131
00:07:23,540 --> 00:07:26,870
我们知道 drawRandomCard会返回nil

132
00:07:26,870 --> 00:07:30,360
根据实现 它在deck为空时会返回nil

133
00:07:30,360 --> 00:07:31,440
很完美

134
00:07:31,440 --> 00:07:35,180
为nil时 牌就不会翻到有内容的那一面了

135
00:07:35,180 --> 00:07:36,770
它会维持在反面

136
00:07:36,770 --> 00:07:37,580
有问题吗

137
00:07:39,270 --> 00:07:43,100
翻牌计数是不大优雅的第三个内容 如何修正呢

138
00:07:43,100 --> 00:07:45,600
这方面可以有多种解决办法

139
00:07:45,600 --> 00:07:48,360
不过我认为最简单的是

140
00:07:48,360 --> 00:07:55,580
仅在真正翻动时才计数

141
00:07:55,580 --> 00:07:58,240
这其实并不是很棒的解决办法

142
00:07:58,240 --> 00:08:01,870
因为这里 我们并没有实际翻牌

143
00:08:01,870 --> 00:08:06,020
如果我们在反面 那么这里我们要翻牌

144
00:08:06,020 --> 00:08:10,840
这个不算很好 因为我们是在…

145
00:08:10,840 --> 00:08:17,460
一旦翻到反面 我们没有问题 因为我们开始…

146
00:08:17,460 --> 00:08:19,720
我们将反复执行这段代码

147
00:08:19,720 --> 00:08:21,600
因为我们总在背面

148
00:08:21,600 --> 00:08:24,920
我认为这样能行 这是好的解决办法吗

149
00:08:24,920 --> 00:08:27,400
我不喜欢它的原因在于

150
00:08:27,400 --> 00:08:29,740
一段代码同时出现在两处

151
00:08:29,740 --> 00:08:32,570
我们还可以做很多别的事

152
00:08:32,570 --> 00:08:37,860
我们可以将图像和字符串提出到单独局部变量

153
00:08:37,860 --> 00:08:40,600
用if 应用这些 等等

154
00:08:40,600 --> 00:08:44,810
不过这些就有点过头了

155
00:08:44,810 --> 00:08:47,440
我们来看看这能否奏效

156
00:08:47,440 --> 00:08:50,370
程序开始时 牌是朝下的

157
00:08:50,370 --> 00:08:52,370
点完整副牌

158
00:08:52,370 --> 00:08:54,050
快速点它

159
00:08:54,050 --> 00:08:56,600
可以看到 我点得很快

160
00:08:56,600 --> 00:09:01,240
以致于动画都不能完全展示出来

161
00:09:01,240 --> 00:09:04,590
下下周我们会开始讨论动画

162
00:09:04,590 --> 00:09:08,650
动画中可能发生的一个情况就是

163
00:09:08,650 --> 00:09:13,370
它会同实际发生的情况有些不同步

164
00:09:13,370 --> 00:09:16,580
这里我在快速翻牌

165
00:09:16,580 --> 00:09:19,890
但动画却慢半拍 动画有些滞后

166
00:09:19,890 --> 00:09:21,740
很不幸 它就是这样

167
00:09:21,740 --> 00:09:23,780
动画最终会赶上

168
00:09:23,780 --> 00:09:25,930
这里我们到了最后一张牌

169
00:09:25,930 --> 00:09:29,710
然后正面朝下 再点就没反应了

170
00:09:29,710 --> 00:09:32,340
停在104

171
00:09:32,340 --> 00:09:35,750
关于这个解决方案有任何问题吗

172
00:09:37,450 --> 00:09:38,700
很简单

173
00:09:38,700 --> 00:09:42,640
优雅性 简洁性 这是你们在作业中要追求的

174
00:09:42,640 --> 00:09:46,560
加入很多API的复杂解决方案我们不推崇

175
00:09:46,560 --> 00:09:50,430
我们推崇更简介优雅的解决方案

176
00:09:50,430 --> 00:09:53,170
就算像这样有两行做相同事情的代码

177
00:09:53,170 --> 00:09:55,380
都显得有些不够优雅

178
00:09:55,380 --> 00:09:58,520
也许你不应该像这样复制

179
00:09:58,520 --> 00:10:01,350
这只能勉强算优雅

180
00:10:01,360 --> 00:10:03,260
不过这里还要考虑简单

181
00:10:03,260 --> 00:10:06,740
因为我只有这么多时间

182
00:10:06,740 --> 00:10:07,610
好

183
00:10:07,610 --> 00:10:13,990
下面 我们将要进入纸牌匹配游戏的下一阶段

184
00:10:13,990 --> 00:10:16,790
也就是实际进行游戏

185
00:10:16,790 --> 00:10:19,980
游戏的进行是我们模型的一部分

186
00:10:19,990 --> 00:10:21,630
理解这个很重要

187
00:10:21,630 --> 00:10:25,130
它不是控制器的一部分 而是模型的一部分

188
00:10:25,130 --> 00:10:28,660
因为我讲过 模型是关于游戏是什么

189
00:10:28,660 --> 00:10:30,080
这是什么

190
00:10:30,080 --> 00:10:33,170
这是一个纸牌匹配游戏 "什么"需要放在模型中

191
00:10:33,170 --> 00:10:36,540
所以 我们将在模型中创建一个类

192
00:10:36,540 --> 00:10:39,690
封装游戏进行的逻辑

193
00:10:39,690 --> 00:10:42,700
它将对用户界面一无所知

194
00:10:42,700 --> 00:10:46,280
它其中没有任何同用户界面相关的事物

195
00:10:46,280 --> 00:10:48,550
这是一个非常重要的区分

196
00:10:48,550 --> 00:10:50,920
我们来创建这个新类

197
00:10:50,920 --> 00:10:55,500
创建新类的方式同今天作业中一样

198
00:10:55,500 --> 00:10:57,200
点击新文件

199
00:10:57,200 --> 00:11:00,240
我们想要一个Objective-C类

200
00:11:00,240 --> 00:11:04,500
命名为CardMatchingGame

201
00:11:04,500 --> 00:11:11,300
它将继承自NSObject 和所有基本类一样

202
00:11:11,300 --> 00:11:16,130
我将把这个类同模型中其它类放到相同目录下

203
00:11:16,130 --> 00:11:20,820
我还将用导航栏将它放到模型的同一个组中

204
00:11:20,820 --> 00:11:24,520
它和所有这些一起在这个组中

205
00:11:24,520 --> 00:11:27,840
记得这样做是很好的

206
00:11:27,840 --> 00:11:29,420
好 我们创建了它

207
00:11:29,420 --> 00:11:30,840
这就是了

208
00:11:30,840 --> 00:11:34,610
这是它的头文件

209
00:11:34,610 --> 00:11:39,970
我将使用这个自动对照 来显示实现

210
00:11:39,970 --> 00:11:43,450
这是头文件及实现

211
00:11:43,450 --> 00:11:47,490
我在设计新类时 我总喜欢

212
00:11:47,490 --> 00:11:51,210
首先处理公共API

213
00:11:51,210 --> 00:11:53,750
稍后再考虑它的实现

214
00:11:53,750 --> 00:11:57,920
我会先思考 人们会怎样使用我的类

215
00:11:57,920 --> 00:12:00,870
以此驱动我的总体设计

216
00:12:00,870 --> 00:12:02,420
这里类很简单

217
00:12:02,420 --> 00:12:04,180
如果类更复杂一些

218
00:12:04,180 --> 00:12:07,210
你可能需要同团队开意义重大的设计会议

219
00:12:07,210 --> 00:12:10,000
来理解这是什么对象 它如何融入到世界中

220
00:12:10,000 --> 00:12:12,620
但如果只是一个简单直接的类

221
00:12:12,620 --> 00:12:14,700
特别是在初次编写时

222
00:12:14,700 --> 00:12:18,420
有时 想想其API是什么就足够了

223
00:12:18,420 --> 00:12:24,160
API在这里也就是类的公共应用程序接口

224
00:12:24,160 --> 00:12:28,000
我需要思考这个纸牌匹配游戏需要做什么

225
00:12:28,000 --> 00:12:31,110
首先 我知道它需要一个初始化器

226
00:12:31,110 --> 00:12:32,810
一个init

227
00:12:32,810 --> 00:12:34,870
当我考虑我的纸牌匹配游戏时

228
00:12:34,870 --> 00:12:38,120
它有一些东西需要知道去初始化

229
00:12:38,120 --> 00:12:41,570
它不能只像PlayingCardDeck那样初始化自身

230
00:12:41,570 --> 00:12:43,830
PlayingCardDeck在开始时知道

231
00:12:43,830 --> 00:12:45,980
关于扑克牌堆它需要知道的一切

232
00:12:45,980 --> 00:12:47,660
但这个不知道这些

233
00:12:47,660 --> 00:12:50,170
我需要一些东西 其中一个是

234
00:12:50,170 --> 00:12:53,290
玩家玩的有多少张牌

235
00:12:53,290 --> 00:12:57,010
玩家被允许总共匹配多少张纸牌

236
00:12:57,010 --> 00:12:58,230
总共多少张

237
00:12:58,230 --> 00:12:59,180
我们需要这个

238
00:12:59,180 --> 00:13:03,610
所以这里我说 initWithCardCount(初始化 带纸牌计数)

239
00:13:03,610 --> 00:13:06,680
这里使用NSUInteger

240
00:13:06,680 --> 00:13:11,490
实际上 计数至少需要是2 你们应该能想到

241
00:13:11,490 --> 00:13:16,280
所以我在初始化器中 也许应该验证 确保它大于1

242
00:13:16,280 --> 00:13:18,500
如若不然 我将从self返回nil

243
00:13:18,500 --> 00:13:21,890
换言之 我将不初始化 我的alloc init会返回nil

244
00:13:21,890 --> 00:13:25,500
确实 我们会选一种返回nil的方式

245
00:13:25,500 --> 00:13:27,630
但我们也应该验证这个

246
00:13:27,630 --> 00:13:31,320
我需要的第二个东西是一个牌堆

247
00:13:31,320 --> 00:13:33,450
因为我要发这些牌

248
00:13:33,450 --> 00:13:38,480
我发牌后 你要选择一些来匹配

249
00:13:38,480 --> 00:13:42,970
所以这里我说 usingDeck(使用牌堆)

250
00:13:42,970 --> 00:13:45,410
(Deck *)deck

251
00:13:45,410 --> 00:13:48,240
这里是初始化器

252
00:13:48,240 --> 00:13:52,240
为了这个 我需要导入Deck

253
00:13:52,240 --> 00:13:54,250
这很好

254
00:13:54,250 --> 00:13:55,420
从这里开始

255
00:13:55,420 --> 00:13:57,580
我的游戏还需要什么

256
00:13:57,580 --> 00:14:02,460
这是一个游戏 它当然应该有分数

257
00:14:03,390 --> 00:14:06,680
这里用NSInteger来表示分数

258
00:14:06,690 --> 00:14:08,680
重申一次 使用NSInteger NSUInteger

259
00:14:08,690 --> 00:14:10,960
而不用unsigned int 只是风格问题

260
00:14:10,960 --> 00:14:12,850
上面用了NSUInteger

261
00:14:12,850 --> 00:14:16,390
这里我用NSInteger保持一致

262
00:14:16,390 --> 00:14:18,570
分数其实也可能为负

263
00:14:18,570 --> 00:14:21,280
所以不是NSUInteger 它可以为负

264
00:14:21,280 --> 00:14:23,500
注意 这里我让该属性为只读

265
00:14:23,500 --> 00:14:25,170
我们第一次看到这个

266
00:14:25,170 --> 00:14:26,240
为什么呢

267
00:14:26,240 --> 00:14:28,380
这是因为 我是游戏逻辑

268
00:14:28,380 --> 00:14:30,130
我需要决定分数是多少

269
00:14:30,130 --> 00:14:33,530
没人能够设置分数 我会告诉你分数是什么

270
00:14:33,530 --> 00:14:36,560
因此 任何人都不能够设置该属性

271
00:14:36,560 --> 00:14:38,190
至少公共上

272
00:14:38,190 --> 00:14:41,880
等下你们会看到 私有上 我们可以改写它

273
00:14:41,880 --> 00:14:43,670
从而进行私有设置

274
00:14:43,670 --> 00:14:45,860
因为我们需要一直更新分数

275
00:14:45,860 --> 00:14:50,480
用户翻牌并匹配正确后会得分 我们需要更新

276
00:14:50,480 --> 00:14:53,740
但公共上 我们希望它是只读的

277
00:14:55,720 --> 00:14:58,110
剩下我还需要解决一件事

278
00:14:58,110 --> 00:15:01,610
玩家需要点击这些牌 牌会翻面

279
00:15:01,610 --> 00:15:04,140
它们被选择 可能会匹配

280
00:15:04,140 --> 00:15:07,800
所以我需要有某种方法 让玩家选择一张牌

281
00:15:07,800 --> 00:15:15,990
这里我将其称作chooseCardAtIndex(在某下标处选牌)

282
00:15:15,990 --> 00:15:19,200
还是NSUInteger类型 index

283
00:15:19,200 --> 00:15:24,200
API中有很多方式能让玩家选牌

284
00:15:24,200 --> 00:15:27,700
创建这一纸牌匹配游戏的对象 例如控制器

285
00:15:27,700 --> 00:15:29,530
创建这一纸牌匹配游戏的对象 例如控制器

286
00:15:29,530 --> 00:15:32,850
创建这一模型类的对象 知道计数

287
00:15:32,850 --> 00:15:35,420
因为它指定了牌的计数

288
00:15:35,420 --> 00:15:39,420
所以 这样指定一个下标很合理

289
00:15:39,420 --> 00:15:42,110
在0和这个count-1之间

290
00:15:42,110 --> 00:15:44,170
只要玩家选择了一张牌

291
00:15:44,170 --> 00:15:49,360
这就是明确玩家选择哪张牌的一种简单方式

292
00:15:49,360 --> 00:15:56,310
类似地 我需要能够返回一张给定下标处的牌

293
00:15:56,310 --> 00:15:58,360
为什么需要这样呢

294
00:15:58,360 --> 00:16:01,780
因为我需要弄清游戏状态

295
00:16:01,780 --> 00:16:04,600
在任何时候 我需要知道

296
00:16:04,600 --> 00:16:08,480
我的控制器如何为该游戏显示一个UI

297
00:16:08,480 --> 00:16:12,000
如果它无法弄清纸牌状态是怎样的 那就麻烦了

298
00:16:12,000 --> 00:16:14,270
这里只是为了让它得到纸牌

299
00:16:14,280 --> 00:16:17,520
它可以遍历所有这些纸牌 获得全部 全部更新

300
00:16:17,520 --> 00:16:19,720
它也可以得到特定下标处的牌

301
00:16:19,720 --> 00:16:24,950
做它所需要做的最合适的事情

302
00:16:24,950 --> 00:16:27,190
好 这是我的公共API

303
00:16:27,190 --> 00:16:30,490
我在这里编写实现之前

304
00:16:30,490 --> 00:16:33,350
你们可以看到这里有一条警告 它怎么说

305
00:16:33,350 --> 00:16:36,910
它说有三条 你可以点击这个3来展开

306
00:16:36,910 --> 00:16:40,180
它说 你没有实现这些

307
00:16:40,180 --> 00:16:43,910
你使之成为公共的三个方法 这个警告很好

308
00:16:43,910 --> 00:16:45,340
我需要这样做

309
00:16:45,340 --> 00:16:49,590
但在这样做之前 我要先回到我的控制器

310
00:16:49,590 --> 00:16:52,090
我要展示给你们

311
00:16:52,090 --> 00:16:55,460
这里我们需要有怎样的UI

312
00:16:55,460 --> 00:16:57,640
使得我们进行实现时

313
00:16:57,640 --> 00:16:59,610
你能想象它们如何一同工作

314
00:16:59,610 --> 00:17:01,400
但我不一定需要

315
00:17:01,400 --> 00:17:04,010
在CardMatchingGame之前做这个UI

316
00:17:04,010 --> 00:17:06,650
有人甚至认为 我应该先做CardMatchingGame

317
00:17:06,650 --> 00:17:11,070
设计模型时不要受UI太大影响

318
00:17:11,070 --> 00:17:15,520
但是 要知道 这个模型将会同UI一同工作

319
00:17:15,520 --> 00:17:19,700
所以我们将一同做 让你们能够更好地想象

320
00:17:19,700 --> 00:17:22,660
这个UI需要什么呢

321
00:17:22,660 --> 00:17:25,110
一点就是 我们需要很多牌

322
00:17:25,110 --> 00:17:27,550
这张牌无法和任何东西进行匹配

323
00:17:27,550 --> 00:17:30,780
让我们弄更多牌 这很简单

324
00:17:30,780 --> 00:17:33,910
我只需要把这张牌移到角落里

325
00:17:33,910 --> 00:17:38,410
然后复制粘贴 选择它 复制粘贴

326
00:17:38,410 --> 00:17:40,870
使用蓝色参考线来放置

327
00:17:40,870 --> 00:17:43,890
我还可以复制两张并粘贴

328
00:17:43,890 --> 00:17:48,280
然后复制四张并粘贴

329
00:17:48,280 --> 00:17:52,580
我将有12张牌 这是很好的纸牌数量

330
00:17:52,580 --> 00:17:55,420
实际上 我不再需要翻牌计数

331
00:17:55,420 --> 00:17:57,300
这里不再是翻牌 而是要匹配

332
00:17:57,300 --> 00:18:00,630
也许我需要展示分数 但这是之后的事情

333
00:18:00,630 --> 00:18:03,270
不过这就基本上是我的整个UI了

334
00:18:03,270 --> 00:18:06,450
我有这些牌 我将点击它们

335
00:18:06,450 --> 00:18:08,690
它会显示出一张牌

336
00:18:08,690 --> 00:18:12,740
然后我可以再点一下 让它正面朝下 取消选择

337
00:18:12,740 --> 00:18:14,460
我也可以点另外一张牌

338
00:18:14,460 --> 00:18:16,370
如果匹配成功 我将得到一些分数

339
00:18:16,370 --> 00:18:21,070
否则的话 我之前选的那张将会翻回去 正面朝下

340
00:18:21,070 --> 00:18:25,830
这同你们所熟悉的Concentration游戏不同

341
00:18:25,830 --> 00:18:28,440
通常你选一张牌 然后再选另一张

342
00:18:28,440 --> 00:18:29,970
相匹配你会得分

343
00:18:29,970 --> 00:18:33,730
否则两者都会翻回去

344
00:18:33,730 --> 00:18:36,920
这是很酷的UI 但我还没教你们怎么做动画

345
00:18:36,920 --> 00:18:38,050
这是这里所必须的

346
00:18:38,050 --> 00:18:41,250
因为第二张牌需要正面朝上 在屏幕上显示一段时间

347
00:18:41,250 --> 00:18:42,570
然后两者才会同时翻回正面朝下

348
00:18:42,570 --> 00:18:44,380
因为这个你需要看一段时间

349
00:18:44,380 --> 00:18:47,420
因为你们没学过动画 所以点击第二张牌时

350
00:18:47,420 --> 00:18:50,430
如果不匹配 我们将让之前那张正面朝下

351
00:18:50,430 --> 00:18:52,610
然后你不断点击

352
00:18:52,610 --> 00:18:56,330
找到相匹配的牌就能得分 我来展示下

353
00:18:56,330 --> 00:18:58,650
我要使用的分数系统

354
00:18:58,650 --> 00:19:00,680
这就是我的整个UI

355
00:19:00,680 --> 00:19:03,430
这是一个非常以内容为中心的UI

356
00:19:03,430 --> 00:19:06,890
UI集中在这些纸牌上

357
00:19:06,890 --> 00:19:09,240
周围没有很多装饰

358
00:19:09,240 --> 00:19:11,670
实际上 也几乎没有别的东西了

359
00:19:11,670 --> 00:19:14,770
除了分数 你们还需要加一个重新发牌的按钮

360
00:19:14,770 --> 00:19:20,280
也许还有一些关于状态的内容 这些是作业

361
00:19:20,280 --> 00:19:23,810
不过UI的基础就是这些了

362
00:19:23,810 --> 00:19:27,600
下面回到我们的CardMatchingGame

363
00:19:27,600 --> 00:19:32,620
我们来讲讲如何实现这个

364
00:19:32,620 --> 00:19:35,410
这里选择自动

365
00:19:35,410 --> 00:19:36,840
把这个弄回来

366
00:19:36,840 --> 00:19:39,630
为了让这更漂亮一些 我要这样

367
00:19:39,630 --> 00:19:43,970
我将把这个头文件留在这里

368
00:19:43,970 --> 00:19:46,430
同时来编写实现

369
00:19:46,430 --> 00:19:50,600
这样你们就能对照着看 我们要做什么

370
00:19:50,600 --> 00:19:57,740
首先我要让这个只在实现中为读写

371
00:19:57,740 --> 00:20:01,190
做法是通过这个私有接口

372
00:20:01,190 --> 00:20:04,050
记得吧 这个我讲过 你可以使用

373
00:20:04,050 --> 00:20:06,340
这种开闭括号表示

374
00:20:06,340 --> 00:20:09,570
像这样 现在你可以声明你自己的东西

375
00:20:09,570 --> 00:20:11,930
我将重新声明这个

376
00:20:11,930 --> 00:20:17,380
为非原子 读写 NSInteger score

377
00:20:18,060 --> 00:20:23,200
这个读写 我们不怎么使用 因为它是默认

378
00:20:23,200 --> 00:20:27,970
isChosen 记得Card中的chosen和matched属性吗

379
00:20:27,970 --> 00:20:30,910
它们没说是读写 但它们有setter和getter

380
00:20:30,910 --> 00:20:32,670
它们是读写的

381
00:20:32,670 --> 00:20:34,550
这个只使用在

382
00:20:34,550 --> 00:20:38,310
重新声明公共中的只读为私有中的读写时

383
00:20:38,310 --> 00:20:41,110
这是我们使用这个的唯一情况

384
00:20:41,110 --> 00:20:42,880
也有一些编程风格

385
00:20:42,880 --> 00:20:45,080
有人喜欢一直加上读写

386
00:20:45,080 --> 00:20:48,100
虽然这是默认 有些人对强是这样做的

387
00:20:48,100 --> 00:20:49,830
强也是默认

388
00:20:49,830 --> 00:20:52,230
我就喜欢在任何地方都指明强

389
00:20:52,230 --> 00:20:56,020
这样我脑袋里能更清楚知道发生了什么

390
00:20:56,020 --> 00:21:00,360
但读写一般都没必要特别指出 除了这里需要重新定义

391
00:21:00,360 --> 00:21:02,270
大家都理解这里我做了什么吗

392
00:21:02,270 --> 00:21:04,890
这是score 和前面完全一样的分数

393
00:21:04,890 --> 00:21:08,110
也就是说 这里将会有setter

394
00:21:08,110 --> 00:21:10,650
但我只能在私有条件下调用setter

395
00:21:10,650 --> 00:21:13,780
至少在实现中编译器不会提出警告

396
00:21:13,780 --> 00:21:16,500
因为我这里声明了读写

397
00:21:16,500 --> 00:21:20,190
没有公共理由能够设置这一分数

398
00:21:20,190 --> 00:21:23,800
调用setScore 而不让编译器提出警告

399
00:21:25,310 --> 00:21:26,880
下一步 我想考虑这个纸牌游戏的内部数据结构

400
00:21:26,880 --> 00:21:29,790
下一步 我想考虑这个纸牌游戏的内部数据结构

401
00:21:29,790 --> 00:21:30,660
非常简单

402
00:21:30,660 --> 00:21:32,610
不过是一个纸牌的数组

403
00:21:32,610 --> 00:21:34,410
我将有一个纸牌的数组

404
00:21:34,410 --> 00:21:37,710
它将有这么多张牌 我将从牌堆中抽出它们

405
00:21:37,710 --> 00:21:44,280
玩家将能选择这些牌 可以看这些牌

406
00:21:44,280 --> 00:21:47,880
我们会在玩家选择对牌时进行加分

407
00:21:47,880 --> 00:21:50,500
我需要这种内部数据结构 这是内部的

408
00:21:50,500 --> 00:21:53,640
所以这里我需要说 非原子 强

409
00:21:53,640 --> 00:21:57,550
它将是一个可变的NSMutableArray

410
00:21:57,550 --> 00:22:01,420
这同我们在Deck中看到的情况类似

411
00:22:01,420 --> 00:22:06,520
这里我总喜欢注释一下 说是Card的

412
00:22:06,520 --> 00:22:07,880
因为 我说过

413
00:22:07,880 --> 00:22:13,170
Objective-C没有办法让编译器强制说这里是什么

414
00:22:13,170 --> 00:22:16,220
位于这个可变数组中的不过是对象

415
00:22:16,220 --> 00:22:19,450
编译器不知道它们是什么类

416
00:22:19,450 --> 00:22:22,260
所以你需要确保没有将消息

417
00:22:22,260 --> 00:22:24,420
发送给错误的事物

418
00:22:24,420 --> 00:22:29,860
这里我们至少要让读代码的人知道我们的意图

419
00:22:29,860 --> 00:22:32,430
我们希望这里是纸牌的数组

420
00:22:32,430 --> 00:22:38,510
当然 我们希望进行惰性实例化

421
00:22:45,580 --> 00:22:47,010
这很好

422
00:22:47,010 --> 00:22:52,090
现在我们有了这个纸牌的数组 我们可以随时使用它

423
00:22:52,090 --> 00:22:56,010
还是那句话 我们可以在初始化器中进行这个初始化

424
00:22:56,010 --> 00:22:58,340
我们可以在这里做这个alloc init

425
00:22:58,340 --> 00:23:01,340
不过我更喜欢惰性实例化

426
00:23:01,340 --> 00:23:06,210
我认为它让初始化器的代码看起来更简洁

427
00:23:06,210 --> 00:23:08,310
下面让我们来写初始化器

428
00:23:08,310 --> 00:23:12,010
我将要复制粘贴

429
00:23:12,010 --> 00:23:14,890
也许没必要复制粘贴

430
00:23:14,890 --> 00:23:17,960
因为键入时 它会自动补全

431
00:23:17,960 --> 00:23:20,720
其它方法中 我会展示这个的

432
00:23:20,720 --> 00:23:24,120
然后 我们都知道我们做了这个奇怪的事

433
00:23:24,120 --> 00:23:25,940
self = [super init]

434
00:23:25,940 --> 00:23:29,260
这是我们类的指定初始化器

435
00:23:29,260 --> 00:23:31,880
换句话说 你需要调用这个初始化器

436
00:23:31,880 --> 00:23:34,600
否则我们的类将无法正常初始化

437
00:23:34,600 --> 00:23:37,860
我们可以有其它能调用这个的初始化器

438
00:23:37,860 --> 00:23:40,180
如果有方法能够默认设置这些

439
00:23:40,180 --> 00:23:41,900
这里没有办法默认设置

440
00:23:41,900 --> 00:23:44,520
所以这个必须是我们的指定初始化器

441
00:23:44,520 --> 00:23:47,930
我将在公共头文件中加一段注释

442
00:23:47,940 --> 00:23:50,970
注明这是我的指定初始化器

443
00:23:50,970 --> 00:23:53,900
这样任何为CardMatchingGame编写子类的人

444
00:23:53,900 --> 00:23:56,530
就知道在他们的指定初始化器中

445
00:23:56,530 --> 00:24:00,000
他们需要调用super 我们的指定初始化器

446
00:24:00,000 --> 00:24:02,060
这就是指定初始化器的工作方式

447
00:24:02,060 --> 00:24:04,430
你需要从你的指定初始化器

448
00:24:04,430 --> 00:24:06,430
调用你的super指定初始化器

449
00:24:07,040 --> 00:24:07,750
有问题

450
00:24:11,340 --> 00:24:14,020
指定初始化器吗 不 编译器不知道

451
00:24:14,020 --> 00:24:17,690
这纯粹是注释 它类似于这类注释

452
00:24:17,690 --> 00:24:21,060
很不幸 编译器不知道 没有关键字说

453
00:24:21,060 --> 00:24:23,440
这是我的指定初始化器

454
00:24:23,440 --> 00:24:25,680
你的问题提得早些

455
00:24:25,680 --> 00:24:27,510
好 你讲

456
00:24:40,290 --> 00:24:43,240
你可以跟进我讲的 我不大理解你的问题

457
00:24:43,240 --> 00:24:45,770
如果有其它初始化器 我猜

458
00:24:45,770 --> 00:24:50,510
你的问题是我怎样禁用另一个初始化器吗

459
00:24:57,300 --> 00:24:59,720
对 哦 我知道你是什么意思了

460
00:24:59,720 --> 00:25:03,120
问题是 我能否有另一个初始化器

461
00:25:03,120 --> 00:25:05,240
指定初始化器 不是公共的

462
00:25:05,240 --> 00:25:07,620
而是私有的 再让事物调用它

463
00:25:07,620 --> 00:25:09,310
当然 你可以那样做

464
00:25:09,310 --> 00:25:12,270
只是 如果你让指定初始化器不是公共的

465
00:25:12,270 --> 00:25:13,890
那么子类就不知道它

466
00:25:13,890 --> 00:25:16,210
因为Objective-C中没有protected

467
00:25:16,210 --> 00:25:18,690
所以任何子类需要的东西都要设为公共的

468
00:25:18,690 --> 00:25:19,820
来让它们看到它

469
00:25:19,820 --> 00:25:22,150
它仍在那里 仍然能够创建它的子类

470
00:25:22,160 --> 00:25:23,880
但要子类知道它

471
00:25:23,880 --> 00:25:26,190
你需要把它放到公共API中

472
00:25:26,190 --> 00:25:29,130
对 整个初始化器问题在Objective-C中

473
00:25:29,130 --> 00:25:32,090
并没有很好地得到语言的支持

474
00:25:32,090 --> 00:25:33,510
请讲

475
00:25:39,360 --> 00:25:42,650
问题是 这里是否可以

476
00:25:42,650 --> 00:25:47,110
实现init在这里

477
00:25:47,110 --> 00:25:48,490
来做点什么

478
00:25:48,490 --> 00:25:52,100
也许重写init也是可以的

479
00:25:52,100 --> 00:25:53,510
你知道怎么做吗

480
00:25:53,510 --> 00:25:55,160
返回nil

481
00:25:55,170 --> 00:25:58,460
因为如果你使用[CardMatchingGame alloc] init

482
00:25:58,460 --> 00:26:00,150
它没有适当初始化

483
00:26:00,150 --> 00:26:04,690
而且纸牌数或牌堆没有默认值 所以返回nil

484
00:26:04,690 --> 00:26:07,070
对 答案是肯定的 你可以

485
00:26:07,070 --> 00:26:09,430
好 回到我们的指定初始化器

486
00:26:09,430 --> 00:26:12,300
我们需要调用super的指定初始化器

487
00:26:12,300 --> 00:26:14,710
对于NSObject 这是init

488
00:26:14,710 --> 00:26:15,670
没有参数

489
00:26:15,670 --> 00:26:18,890
然后我们可以说 if (self)

490
00:26:18,900 --> 00:26:21,720
这时我们可以初始化我们自己

491
00:26:21,720 --> 00:26:23,360
然后返回self

492
00:26:23,360 --> 00:26:28,260
如果这里任何情况出现错误 我们将把self设为nil

493
00:26:28,260 --> 00:26:30,220
从这里跳出来

494
00:26:30,220 --> 00:26:33,230
实际上 你们会看到 这里确实会出错

495
00:26:33,230 --> 00:26:37,760
我们需要做什么来初始化这里的东西呢

496
00:26:37,760 --> 00:26:42,980
我们需要从牌堆中抽出这么多张牌

497
00:26:42,980 --> 00:26:45,970
将它放入我们的内部数据结构中

498
00:26:45,970 --> 00:26:48,050
怎么做到呢

499
00:26:48,050 --> 00:26:56,210
这样做 for (int i = 0; i < count; i++)

500
00:26:56,210 --> 00:26:59,180
这能让我遍历这么多个事物

501
00:26:59,180 --> 00:27:02,510
下面是Card *card =

502
00:27:02,510 --> 00:27:05,570
[deck drawRandomCard]

503
00:27:05,570 --> 00:27:07,390
这是从牌堆随机抽一张牌

504
00:27:07,410 --> 00:27:15,140
然后我要说 self.cards[i] = card

505
00:27:15,140 --> 00:27:19,490
我有这个可变数组 它将总是非nil

506
00:27:19,490 --> 00:27:21,730
这完全没问题

507
00:27:21,730 --> 00:27:23,800
不过这里有一个问题

508
00:27:23,800 --> 00:27:26,440
如果牌用完了会怎样

509
00:27:26,440 --> 00:27:29,200
如果传递一副扑克牌到这里

510
00:27:29,200 --> 00:27:32,690
然后你说要100张牌用于游戏

511
00:27:32,690 --> 00:27:35,520
这最终会返回nil

512
00:27:35,520 --> 00:27:36,830
牌不够

513
00:27:36,830 --> 00:27:40,580
所以这里我们要检验说 if (card)

514
00:27:40,580 --> 00:27:43,600
然后再做我们一般要做的事

515
00:27:43,600 --> 00:27:46,300
否则 self = nil

516
00:27:46,300 --> 00:27:50,100
并从for循环中跳出

517
00:27:51,170 --> 00:27:52,510
有问题

518
00:28:00,440 --> 00:28:05,620
问题是 cards中还没有任何东西时 我在这一行代码中

519
00:28:05,620 --> 00:28:07,990
是怎样访问cards来设置它的

520
00:28:07,990 --> 00:28:12,800
cards最开始时是nil 然后当我调用getter时

521
00:28:12,800 --> 00:28:16,220
这里self.cards是getter 这会初始化它

522
00:28:16,220 --> 00:28:19,080
得到空数组 但数组可变

523
00:28:19,080 --> 00:28:23,900
所以我可以在这里添加对象 哦 抱歉

524
00:28:23,900 --> 00:28:26,390
这里你是对的 不过这也没问题

525
00:28:26,390 --> 00:28:29,910
也许更好的做法是 self.cards

526
00:28:29,910 --> 00:28:33,170
addObject:card 这样更清楚一些

527
00:28:33,170 --> 00:28:35,920
也许你是对的 我的做法可能无法工作

528
00:28:35,920 --> 00:28:40,470
这是更好的做法 将纸牌加到牌堆中

529
00:28:40,470 --> 00:28:41,790
好了吗

530
00:28:41,790 --> 00:28:44,580
抱歉 之前我的那个不怎么好

531
00:28:44,580 --> 00:28:47,260
实际上 我不知道之前那个能否工作

532
00:28:47,260 --> 00:28:49,800
我来想想 你说的是插入对象

533
00:28:49,800 --> 00:28:51,440
这可能也能工作

534
00:28:51,440 --> 00:28:54,240
因为你做的是在某下标处插入对象

535
00:28:54,240 --> 00:28:56,920
这会是在数组最后 这也许也能行

536
00:28:56,920 --> 00:28:58,220
两种方式都行

537
00:28:58,220 --> 00:29:01,620
因为self.cards[i] 这里的下标i

538
00:29:01,620 --> 00:29:03,960
调用的是一个方法 insertObject

539
00:29:03,960 --> 00:29:06,300
atIndex 在特定下标处插入

540
00:29:06,300 --> 00:29:09,300
你可以参考说明文档 看这里调用的方法名称

541
00:29:09,300 --> 00:29:13,270
如果是在数组最后的下标处插入对象 我想这能行

542
00:29:13,270 --> 00:29:16,640
但如果是在下标500处 这也许就行不通了

543
00:29:16,640 --> 00:29:19,580
因为数组只能逐渐增长 我这么认为

544
00:29:19,580 --> 00:29:20,700
请讲

545
00:29:23,170 --> 00:29:25,250
问题是 能否将不同类型的对象

546
00:29:25,250 --> 00:29:27,530
加到相同数组中 答案是当然可以

547
00:29:27,530 --> 00:29:30,380
我们有时确实也会这样做

548
00:29:30,380 --> 00:29:32,490
周三我会讲到如何处理这个

549
00:29:32,490 --> 00:29:34,410
考虑该如何处理

550
00:29:34,410 --> 00:29:35,980
不同类型的对象在这里

551
00:29:35,980 --> 00:29:38,390
你讲得没错 这完全合法

552
00:29:39,730 --> 00:29:41,160
好 这是这个

553
00:29:41,160 --> 00:29:45,850
我说过 我们还可以在最开始这里说

554
00:29:45,860 --> 00:29:47,450
if (self)

555
00:29:47,450 --> 00:29:51,670
我们还可以有 if count < 2

556
00:29:51,670 --> 00:29:55,510
这时返回nil 我们也可以检验这个

557
00:29:56,970 --> 00:29:59,200
好 我们再来看一些别的方法

558
00:29:59,200 --> 00:30:01,050
来看chooseCardAtIndex

559
00:30:01,050 --> 00:30:03,410
我们先来看cardAtIndex吧

560
00:30:03,410 --> 00:30:05,230
因为cardAtIndex超级简单

561
00:30:05,230 --> 00:30:08,810
这里是Card * 注意当我键入时

562
00:30:08,810 --> 00:30:10,960
它知道这是cardAtIndex

563
00:30:10,970 --> 00:30:14,260
它会自动补全 点Tab键就行了

564
00:30:14,260 --> 00:30:18,100
这个只是返回self.cards[index]

565
00:30:18,100 --> 00:30:21,090
但是 你知道 这是一个公共方法

566
00:30:21,090 --> 00:30:24,190
如果有人传递了糟糕的index怎么办

567
00:30:24,190 --> 00:30:26,710
例如大于count的index

568
00:30:26,710 --> 00:30:29,150
我们这里会崩溃掉吗

569
00:30:29,150 --> 00:30:33,560
有些人认为这很好 因为能够帮我们找bug

570
00:30:33,560 --> 00:30:36,150
显然 这里有某种assertion会更好

571
00:30:36,150 --> 00:30:37,650
我以后会讲到这个

572
00:30:37,650 --> 00:30:43,140
不过这里我将加一些保护 也就是

573
00:30:43,140 --> 00:30:48,190
如果这个index小于self.cards count

574
00:30:48,190 --> 00:30:50,040
我就返回

575
00:30:50,040 --> 00:30:53,020
否则… 噢

576
00:30:53,040 --> 00:30:57,720
if… 我还是用传统的?方式吧

577
00:30:57,720 --> 00:31:00,780
有些人曾问过这个

578
00:31:00,780 --> 00:31:02,930
返回 问号 nil

579
00:31:02,930 --> 00:31:06,120
大家都知道这种问号冒号C语言做法吗

580
00:31:06,120 --> 00:31:10,330
这完全是非对象的C语言做法 对吧

581
00:31:10,330 --> 00:31:11,950
就像if then一样

582
00:31:11,950 --> 00:31:12,940
有问题

583
00:31:12,940 --> 00:31:17,510
学生：[声音不清]带有这些方法的数组访问

584
00:31:17,510 --> 00:31:21,300
如何让可变数组在没有保护下工作

585
00:31:21,300 --> 00:31:24,010
要是传递一个大的下标 它不会崩溃吗

586
00:31:24,010 --> 00:31:25,750
老师：好 问题是

587
00:31:25,750 --> 00:31:29,370
如果这里传递太大的下标 是否会崩溃

588
00:31:29,370 --> 00:31:31,890
它会 而且异常将是数组下标越界

589
00:31:31,890 --> 00:31:34,370
它会 而且异常将是数组下标越界

590
00:31:35,960 --> 00:31:37,480
不 不 它会崩溃

591
00:31:37,480 --> 00:31:39,720
它会引发数组下标越界异常

592
00:31:39,720 --> 00:31:41,910
NSArray类会引发这一异常

593
00:31:41,910 --> 00:31:44,530
我们会谈到异常引发机制的

594
00:31:44,530 --> 00:31:47,850
现在 直到周五考虑调试之前

595
00:31:47,870 --> 00:31:51,980
你将只会看到异常出现在控制台中

596
00:31:51,980 --> 00:31:55,290
它甚至不会停在异常发生的地方 这很不幸

597
00:31:55,290 --> 00:31:58,390
不过讲调试时 我会讲到如何让它停止

598
00:31:58,390 --> 00:32:01,180
不过这就是会发生的情况 会引发异常

599
00:32:01,180 --> 00:32:04,230
这是cardAtIndex 非常非常简单

600
00:32:04,230 --> 00:32:07,820
下面再看另一个 即chooseCardAtIndex

601
00:32:07,820 --> 00:32:10,190
这是我们逻辑的核心

602
00:32:10,190 --> 00:32:11,870
因为这里是选牌的地方

603
00:32:11,870 --> 00:32:15,140
这是匹配和得分实际发生的地方

604
00:32:15,140 --> 00:32:19,020
所以我们的整个逻辑都将发生在这个方法中

605
00:32:19,020 --> 00:32:20,670
这里需要什么呢

606
00:32:20,670 --> 00:32:22,360
玩家会选一张牌

607
00:32:22,360 --> 00:32:24,620
让我们获得玩家所选的牌

608
00:32:24,620 --> 00:32:30,700
我将调用self cardAtIndex来获得这张牌

609
00:32:30,700 --> 00:32:36,080
这样我就有了玩家所选的这张牌

610
00:32:36,080 --> 00:32:40,500
如果玩家所选的牌已经同另一张牌相匹配

611
00:32:40,500 --> 00:32:41,910
这里就什么都不用做

612
00:32:41,910 --> 00:32:45,450
当玩家去选已经匹配过的牌时 我将忽略玩家的行为

613
00:32:45,450 --> 00:32:47,220
当玩家去选已经匹配过的牌时 我将忽略玩家的行为

614
00:32:47,220 --> 00:32:49,810
这里我要的是

615
00:32:49,820 --> 00:32:55,740
if (card.isMatched)

616
00:32:55,740 --> 00:32:59,850
我要说的应该是 if (!card.isMatched)

617
00:32:59,850 --> 00:33:02,530
我们会做点什么 否则我们什么都不做

618
00:33:02,530 --> 00:33:07,620
只在你选的牌没有已经匹配过时

619
00:33:07,620 --> 00:33:12,880
我们才会尝试去匹配两张你选的牌

620
00:33:12,880 --> 00:33:15,310
大家都明白了为什么要这样做吗

621
00:33:15,310 --> 00:33:18,130
已经匹配过的 就不能再同别的牌匹配了

622
00:33:18,130 --> 00:33:22,630
然后的问题是 如果纸牌已经被选

623
00:33:22,630 --> 00:33:24,640
那我将怎么做呢

624
00:33:24,640 --> 00:33:27,760
这时我将把纸牌翻回去 取消选择

625
00:33:27,760 --> 00:33:33,510
所以这里我说 card.chosen = NO

626
00:33:33,510 --> 00:33:35,950
如果选择了已经选过的牌

627
00:33:35,950 --> 00:33:38,870
两次选择 等于取消选择

628
00:33:38,870 --> 00:33:40,160
这是一种开关

629
00:33:40,160 --> 00:33:42,670
选牌是在选择和未选择之间来回切换

630
00:33:42,670 --> 00:33:44,950
注意我们有getter isChosen

631
00:33:44,950 --> 00:33:46,720
记得吧 我们在头文件中改名过

632
00:33:46,720 --> 00:33:48,460
通过getter = isChosen

633
00:33:48,460 --> 00:33:52,130
但setter不用isChosen

634
00:33:52,130 --> 00:33:56,000
setter仍然是chosen chosen是属性名

635
00:33:56,000 --> 00:33:57,780
大家都记得吗

636
00:33:57,780 --> 00:34:00,590
来自Card 你们需要键入这个 所以请记住

637
00:34:00,590 --> 00:34:03,020
否则 我们到这里

638
00:34:03,020 --> 00:34:05,600
这种情况下 我们选择了一张新纸牌

639
00:34:05,600 --> 00:34:09,430
我们需要将它同其它纸牌进行匹配

640
00:34:09,430 --> 00:34:12,670
这里写 另一张牌

641
00:34:12,670 --> 00:34:15,850
我们的匹配游戏只匹配两张牌

642
00:34:15,850 --> 00:34:19,460
你们的作业中 需要扩展到匹配三张牌

643
00:34:19,460 --> 00:34:21,310
这是你们作业的一部分

644
00:34:21,310 --> 00:34:23,470
但这里 我们只匹配另一张牌

645
00:34:23,470 --> 00:34:28,780
所以 这里我只需要检查纸牌数组中的所有其它牌

646
00:34:28,780 --> 00:34:30,480
在这个内部数据结构中

647
00:34:30,480 --> 00:34:34,140
我只需要检查所有这些 看看

648
00:34:34,140 --> 00:34:38,740
有没有另一张牌被选了 但没有匹配的

649
00:34:38,740 --> 00:34:42,380
如果有 我将把它同刚选择的这张匹配起来

650
00:34:42,380 --> 00:34:44,690
我将搜索所有的牌

651
00:34:44,690 --> 00:34:48,840
for (Card *otherCard in self.cards)

652
00:34:48,840 --> 00:34:50,360
遍历所有其它牌

653
00:34:50,360 --> 00:34:59,010
如果能找到另一张牌 已经被选 而且没被匹配

654
00:34:59,010 --> 00:35:00,780
那就中了

655
00:35:00,780 --> 00:35:02,450
我找到了另一张牌匹配上

656
00:35:02,450 --> 00:35:04,620
这里只能有另外一张

657
00:35:04,620 --> 00:35:06,780
因为我总是只考虑两张牌的匹配

658
00:35:06,780 --> 00:35:09,050
我只检查第二张牌 如果不匹配

659
00:35:09,050 --> 00:35:11,180
我将把它翻回去 取消选择它

660
00:35:11,180 --> 00:35:12,920
这里我准备好了

661
00:35:12,920 --> 00:35:16,050
这里只用找到另外一张能进行匹配的牌

662
00:35:16,050 --> 00:35:19,210
这里如果你要做三张或n张牌的匹配

663
00:35:19,210 --> 00:35:22,830
作业中考虑n张牌可能会是一个好主意

664
00:35:22,830 --> 00:35:24,540
你会找到多张牌

665
00:35:24,540 --> 00:35:26,920
你可能需要用数组这些来收集

666
00:35:26,920 --> 00:35:29,570
这样你就能将它们进行匹配 但这里

667
00:35:29,570 --> 00:35:31,620
我不需要担心这些

668
00:35:31,620 --> 00:35:34,710
找到了另外这张已经选择的牌 我们来进行匹配

669
00:35:34,710 --> 00:35:37,750
通过代码 matchScore =

670
00:35:37,750 --> 00:35:43,530
上面这里玩家所选的牌card

671
00:35:43,530 --> 00:35:48,010
match: 记得吧 这是Card中匹配两张牌的方法

672
00:35:48,010 --> 00:35:51,310
它的参数是一个数组

673
00:35:51,310 --> 00:35:56,410
我将现场创建一个数组 将另一张牌放入其中

674
00:35:56,410 --> 00:35:59,430
大家都明白这行代码吗

675
00:35:59,430 --> 00:36:05,760
我在用Card中match方法将这张牌同这张牌进行匹配

676
00:36:05,760 --> 00:36:08,760
但我需要现场创建这样一个数组

677
00:36:08,760 --> 00:36:12,410
因为match实际能够匹配多张牌 这很好

678
00:36:12,410 --> 00:36:14,320
因为你们的作业中需要这个

679
00:36:14,320 --> 00:36:17,120
但这里我只用考虑一个 所以这里

680
00:36:17,120 --> 00:36:21,050
只需要一个蓝色@[]来创建数组

681
00:36:21,050 --> 00:36:22,760
这里有了这个match

682
00:36:22,760 --> 00:36:26,580
我们定义过match的语义

683
00:36:26,580 --> 00:36:30,710
如果返回的是非0 那就有了某种匹配

684
00:36:30,710 --> 00:36:33,220
如果返回0 就没有匹配上

685
00:36:33,220 --> 00:36:35,780
这就是match:的意义

686
00:36:35,780 --> 00:36:40,200
这就是我们对模型语义的定义

687
00:36:40,200 --> 00:36:42,880
也许在Card.h中应该加一小段注释

688
00:36:42,880 --> 00:36:45,590
说match:如果没有匹配返回0

689
00:36:45,590 --> 00:36:48,080
否则考虑匹配有多好

690
00:36:48,080 --> 00:36:52,160
如果匹配得很好 match会返回高分

691
00:36:52,160 --> 00:36:54,620
如果匹配不好 则会返回低分

692
00:36:54,620 --> 00:36:57,500
这就是它的语义

693
00:36:57,500 --> 00:37:03,180
匹配上或没匹配上应该怎样呢

694
00:37:03,180 --> 00:37:06,100
这两种情况我们都需要处理

695
00:37:06,100 --> 00:37:11,570
在匹配上的情况下 我们将给自己分数

696
00:37:14,150 --> 00:37:18,140
而且两张牌都匹配上了 我们将它们标记为已匹配

697
00:37:18,140 --> 00:37:21,500
所以这里说 card.matched = YES

698
00:37:21,500 --> 00:37:25,680
而且另一张牌otherCard.matched = YES

699
00:37:25,680 --> 00:37:28,130
它们匹配上了

700
00:37:28,130 --> 00:37:30,100
它们使命完成 我们得到一些分

701
00:37:30,100 --> 00:37:31,750
如果没匹配上呢

702
00:37:31,750 --> 00:37:36,420
我说过 这时我会将选择的另一张牌取消选择

703
00:37:36,420 --> 00:37:41,380
所以这里有 otherCard.chosen = NO

704
00:37:41,380 --> 00:37:47,610
而且 我还想因此罚一些分

705
00:37:47,610 --> 00:37:52,250
我将从score中减一些分 这叫作错匹配罚分

706
00:37:52,250 --> 00:37:54,570
我将它设置为一个常量

707
00:37:54,570 --> 00:37:57,180
我来简单讲一下常量

708
00:37:57,180 --> 00:37:58,480
要知道 这是C

709
00:37:58,480 --> 00:38:00,750
你可以按照C的方法来处理常量

710
00:38:00,750 --> 00:38:03,720
一种做法是用#define

711
00:38:03,720 --> 00:38:07,950
我可以说 #define MISMATCH_PENALTY

712
00:38:09,310 --> 00:38:12,380
我们可以将MISMATCH_PENALTY设为2

713
00:38:12,380 --> 00:38:16,250
我们可以将MISMATCH_PENALTY设为2

714
00:38:16,250 --> 00:38:19,020
如果错匹配 我将罚掉2分

715
00:38:19,020 --> 00:38:21,480
这是一种做法

716
00:38:21,480 --> 00:38:24,810
另一种处理常量的方式是用const

717
00:38:24,810 --> 00:38:26,450
这里可以是static const

718
00:38:26,450 --> 00:38:33,290
static const int MISMATCH_PENALTY = 2

719
00:38:34,370 --> 00:38:36,610
这是另一种方式

720
00:38:36,610 --> 00:38:38,480
你可以随喜好选择

721
00:38:38,480 --> 00:38:41,710
static const的好处在于它们具有类型

722
00:38:41,710 --> 00:38:45,650
#define没有类型 只是替换

723
00:38:45,650 --> 00:38:49,390
而这里有类型 这在调试器中更好

724
00:38:49,390 --> 00:38:51,100
因为它有类型

725
00:38:51,100 --> 00:38:52,840
不过你们可以根据喜好来

726
00:38:52,840 --> 00:38:55,230
我只想说 不管你选择用哪种

727
00:38:55,230 --> 00:39:00,230
#define也好 static const也好 请保持一致

728
00:39:00,230 --> 00:39:02,510
用哪种取决于你

729
00:39:03,620 --> 00:39:07,650
另外我还要做一件事 如果你匹配上

730
00:39:07,650 --> 00:39:10,920
毕竟这里错匹配会罚2分

731
00:39:10,920 --> 00:39:14,270
如果你匹配上 我会给你很多分

732
00:39:14,270 --> 00:39:18,220
所以我要给你一个匹配红利

733
00:39:18,220 --> 00:39:20,590
MATCH_BONUS

734
00:39:20,610 --> 00:39:23,920
这将是另外一个常量

735
00:39:23,920 --> 00:39:27,970
放在这里 复制粘贴这个

736
00:39:27,980 --> 00:39:29,470
把这个贴过来

737
00:39:29,480 --> 00:39:32,270
我将给你匹配分数的四倍

738
00:39:32,270 --> 00:39:33,840
因为这里有罚分

739
00:39:33,840 --> 00:39:36,040
所以匹配上了我要多给点分你

740
00:39:36,040 --> 00:39:38,320
不管匹配得分是多少 不管匹配有多少

741
00:39:38,320 --> 00:39:41,980
这里得到的分数都会乘以4

742
00:39:41,980 --> 00:39:45,460
这些东西你们可以自己去倒腾

743
00:39:45,460 --> 00:39:49,220
也许在你们的作业中 你们想要

744
00:39:49,220 --> 00:39:52,960
把这些红利和罚分设置为公共API

745
00:39:52,960 --> 00:39:54,880
让它们可以被设置

746
00:39:54,880 --> 00:39:59,140
为了简便起见 这里我们把它们设为常量

747
00:39:59,140 --> 00:40:03,000
另外一点是 如果我们找到了这个匹配

748
00:40:03,000 --> 00:40:07,390
我们就可以从这个for循环中跳出来

749
00:40:07,390 --> 00:40:10,350
这是因为这里只需要匹配两张牌

750
00:40:10,350 --> 00:40:13,580
一旦找到匹配的 这就搞定了

751
00:40:13,580 --> 00:40:16,810
我们找到另一张已选牌 处理掉它

752
00:40:16,810 --> 00:40:19,400
我们不需要再找更多匹配的牌

753
00:40:19,400 --> 00:40:21,620
作业中 当要匹配的数量多于2时

754
00:40:21,620 --> 00:40:25,960
你要将这些牌收集起来 这里就不能跳出

755
00:40:25,960 --> 00:40:30,700
这里我还想做一件事 也就是

756
00:40:30,700 --> 00:40:35,900
如果你选择了一张牌 并让它正面朝上

757
00:40:35,900 --> 00:40:39,270
我要让它消耗一些东西

758
00:40:39,270 --> 00:40:44,120
这里我要设置一些选择成本

759
00:40:44,120 --> 00:40:46,490
这里设为1分

760
00:40:46,490 --> 00:40:50,700
这是因为我不想让你

761
00:40:50,700 --> 00:40:53,730
没有成本地来回来回翻牌

762
00:40:53,730 --> 00:40:57,020
最终记住所有牌 再翻过来让它们都匹配上

763
00:40:57,020 --> 00:40:58,660
这会有一些花销

764
00:40:58,660 --> 00:41:02,680
忘记牌的话 你需要重新翻开 这会花掉一些分

765
00:41:02,680 --> 00:41:05,360
没有错误匹配扣分多 但还是会扣一些分

766
00:41:05,360 --> 00:41:06,140
有问题

767
00:41:10,490 --> 00:41:12,090
对 你是对的

768
00:41:12,090 --> 00:41:15,270
很好 我还得依赖你们提醒我哪里有错

769
00:41:15,270 --> 00:41:16,240
没错

770
00:41:16,240 --> 00:41:17,920
这个break需要在这个if内

771
00:41:17,920 --> 00:41:22,370
因为当我们找到另一张牌时 我们会跳出这个for

772
00:41:22,370 --> 00:41:23,960
提得很好

773
00:41:24,720 --> 00:41:29,780
最后当然是 我想要把这张牌标记为已选

774
00:41:29,780 --> 00:41:33,200
抱歉这里用的是大写

775
00:41:33,200 --> 00:41:37,410
这张牌 噢 不是isChosen 而是chosen

776
00:41:37,410 --> 00:41:40,680
在做了所有这些之后 这张牌是已选的

777
00:41:40,680 --> 00:41:44,710
无论如何它都被选了 它是新的已选牌

778
00:41:44,710 --> 00:41:49,510
它也可能已经被匹配 但它至少是已选的

779
00:41:49,510 --> 00:41:51,790
这就完了

780
00:41:51,790 --> 00:41:54,890
这就是纸牌匹配游戏的整个逻辑

781
00:41:54,890 --> 00:41:58,140
很简单 有点过度简化了

782
00:41:58,140 --> 00:42:01,300
你们可以想象复杂很多的情况

783
00:42:01,300 --> 00:42:04,220
不过这里我是现场编程

784
00:42:04,220 --> 00:42:07,400
要知道 一堂课只有1小时15分钟左右

785
00:42:07,400 --> 00:42:09,360
我故意弄得简单一些

786
00:42:09,360 --> 00:42:13,700
不过我主要想让你们理解的是 这里没有UI

787
00:42:13,700 --> 00:42:16,870
这里只是处理纸牌 设置它们

788
00:42:16,870 --> 00:42:19,000
是否被匹配 是否被选

789
00:42:19,000 --> 00:42:22,550
取决于match:方法的使用 它也是我们模型的一部分

790
00:42:22,550 --> 00:42:24,300
这里没有UI

791
00:42:24,300 --> 00:42:29,250
将这些逻辑传达给UI的是控制器

792
00:42:29,900 --> 00:42:32,730
我们再来看看这个

793
00:42:32,730 --> 00:42:38,350
回到我们的串连图板 腾出一些空间

794
00:42:38,350 --> 00:42:40,680
把这个移过来点

795
00:42:40,680 --> 00:42:42,590
留出更多空间

796
00:42:42,590 --> 00:42:45,060
这是我们的控制器

797
00:42:45,060 --> 00:42:47,640
之前我们写出了这个简单控制器

798
00:42:47,640 --> 00:42:51,630
我要把逻辑用到这个之中

799
00:42:51,630 --> 00:42:53,670
首先我要做的是

800
00:42:53,680 --> 00:42:57,880
创建一个属性来容纳我的CardMatchingGame

801
00:42:59,760 --> 00:43:03,650
有些人可能会把这叫作model

802
00:43:03,650 --> 00:43:05,640
我不大喜欢这样

803
00:43:05,640 --> 00:43:08,740
因为model有时会扩展到多个属性

804
00:43:08,740 --> 00:43:11,710
也有人会叫它gameModel

805
00:43:11,710 --> 00:43:13,820
这不算太糟 我不反对这样

806
00:43:13,820 --> 00:43:17,080
我喜欢game 我认为这样在代码中读起来更好

807
00:43:17,080 --> 00:43:19,880
不过这是一种个人偏好问题

808
00:43:19,880 --> 00:43:24,880
无论如何 我需要导入我的CardMatchingGame头文件

809
00:43:24,880 --> 00:43:27,640
来让这个正常运行

810
00:43:27,640 --> 00:43:30,930
我将惰性实例化它

811
00:43:33,250 --> 00:43:35,660
如果game为nil

812
00:43:35,660 --> 00:43:39,230
也就是说 我们的对象新初始化

813
00:43:39,230 --> 00:43:41,840
那么我会让_game =

814
00:43:41,840 --> 00:43:47,640
[[CardMatchingGame alloc] init…

815
00:43:47,640 --> 00:43:50,670
这里有两个init 一个继承自NSObject

816
00:43:50,670 --> 00:43:53,140
我们知道它会返回nil 所以我不想要这个

817
00:43:53,140 --> 00:43:54,920
另一个是initWithCardCount

818
00:43:54,920 --> 00:43:59,240
我将使用这个 按下Tab 这个游戏中有多少牌

819
00:43:59,240 --> 00:44:00,230
有12张

820
00:44:00,230 --> 00:44:02,120
所以这里应该键入12吗

821
00:44:03,030 --> 00:44:03,940
不对

822
00:44:03,940 --> 00:44:07,490
这就像在作业中使用102一样

823
00:44:07,490 --> 00:44:09,500
以后我们可能增加牌数

824
00:44:09,500 --> 00:44:12,930
这里绝对不要写12 这里我暂时写0

825
00:44:12,930 --> 00:44:16,170
我到时会给你们展示 如何弄清这个值是什么

826
00:44:16,170 --> 00:44:17,880
usingDeck

827
00:44:17,880 --> 00:44:20,400
幸运的是 这里我有self createDeck

828
00:44:20,400 --> 00:44:22,010
所以我这样做

829
00:44:22,010 --> 00:44:25,330
这会创建我的牌堆

830
00:44:25,330 --> 00:44:31,020
然后我们返回_game 这很好地得到了惰性初始化

831
00:44:32,430 --> 00:44:35,200
我们再来讨论一下这个0

832
00:44:35,200 --> 00:44:37,360
我们怎么知道这里有多少牌

833
00:44:37,360 --> 00:44:43,320
实际上 它有可能创建一个outlet到UI中的多个事物

834
00:44:43,320 --> 00:44:45,510
记得吧 这里我们有这个outlet

835
00:44:45,510 --> 00:44:46,520
flipsLable

836
00:44:46,520 --> 00:44:52,260
这是到下面这个flipCount的outlet

837
00:44:52,260 --> 00:44:54,150
它是一个单outlet

838
00:44:54,160 --> 00:44:56,860
我们其实可以删掉这个单outlet

839
00:44:56,860 --> 00:45:00,450
但它只到一个对象 这个UILabel 我们删掉这个

840
00:45:00,450 --> 00:45:02,330
我们不再需要flipCount

841
00:45:02,330 --> 00:45:06,170
我们也不再需要deck 很多东西现在都可以删了

842
00:45:06,170 --> 00:45:11,250
我们将重新写这整个 删掉setFlipCount

843
00:45:11,250 --> 00:45:13,670
这个等下我们会删掉

844
00:45:13,670 --> 00:45:16,760
可以看到 现在游戏变得简单了很多

845
00:45:16,760 --> 00:45:20,030
模型接管了这里的很多东西

846
00:45:20,030 --> 00:45:22,330
把这些都删除后 它会变得更简单

847
00:45:22,330 --> 00:45:25,920
无论如何 这是单outlet

848
00:45:25,920 --> 00:45:28,330
我们可以让outlet到多个事物

849
00:45:28,330 --> 00:45:31,650
你们应该能够想到 这一outlet将是数组

850
00:45:31,650 --> 00:45:33,370
如何做到呢

851
00:45:33,370 --> 00:45:34,280
很简单

852
00:45:34,280 --> 00:45:37,570
方法和原来一样 我按住Control键

853
00:45:37,570 --> 00:45:41,540
选这张牌 按住Control并拖动到接口

854
00:45:41,540 --> 00:45:46,840
和之前创建outlet的方式一样 然后松手

855
00:45:46,840 --> 00:45:49,410
可以看到上面这里写有连接

856
00:45:49,410 --> 00:45:53,020
这里实际有选项可以创建outlet collection

857
00:45:53,020 --> 00:45:55,110
这是一个数组

858
00:45:55,110 --> 00:45:59,340
这里还可以选action 声明到这里

859
00:45:59,340 --> 00:46:01,760
或者到单个按钮的outlet

860
00:46:01,770 --> 00:46:03,650
但这里我要选outlet collection

861
00:46:03,650 --> 00:46:06,500
选outlet collection时 XCode

862
00:46:06,510 --> 00:46:08,970
不是Objective-C 而是XCode希望知道

863
00:46:08,970 --> 00:46:12,720
这里有怎样的对象 这完全是XCode想知道

864
00:46:12,720 --> 00:46:16,210
我讲过Objective-C中没办法知道数组中是什么

865
00:46:16,210 --> 00:46:17,690
编译器无法知道这个

866
00:46:17,690 --> 00:46:19,200
这纯粹是为XCode准备的

867
00:46:19,200 --> 00:46:21,910
等下你们就能看到XCode是如何记住这个的

868
00:46:21,910 --> 00:46:24,320
这里是它的名称 我将其起名为cardButtons(纸牌按钮)

869
00:46:24,320 --> 00:46:28,300
这就是这些 这些是容纳所有纸牌的按钮

870
00:46:28,300 --> 00:46:31,800
注意 这里没有问我是强是弱

871
00:46:31,800 --> 00:46:35,020
这是因为这一属性必须是强的

872
00:46:35,020 --> 00:46:36,670
它必须是强的

873
00:46:36,670 --> 00:46:41,650
因为视图虽然有一个强指针单独指向所有这些牌

874
00:46:41,650 --> 00:46:45,860
但视图没有一个强指针指向这一数组

875
00:46:45,860 --> 00:46:48,730
如果我们不将其设为强

876
00:46:48,730 --> 00:46:51,330
那么这就会被持续设为0

877
00:46:51,330 --> 00:46:54,150
因为没人拥有强指针指向它

878
00:46:54,150 --> 00:46:56,630
所以这里需要是强的

879
00:46:56,630 --> 00:46:58,760
因为它是数组 而不是一个按钮

880
00:46:58,760 --> 00:47:03,860
这一小段代码 会完全被编译器忽略

881
00:47:03,860 --> 00:47:06,080
它同IBAction很像

882
00:47:06,080 --> 00:47:09,700
不过是XCode加到这里的一些东西

883
00:47:09,700 --> 00:47:14,470
让它自身知道这一特定属性是outlet collection

884
00:47:14,470 --> 00:47:16,360
当我把鼠标悬停在这上面时

885
00:47:16,360 --> 00:47:19,180
它会显示我放在这里的这个按钮

886
00:47:19,180 --> 00:47:22,460
我倒想告诉你们 我们可以选择所有这些

887
00:47:22,460 --> 00:47:25,480
并Control拖动 但这是不行的

888
00:47:25,480 --> 00:47:28,910
我一直希望有这种功能 但设计者从来就没提供过

889
00:47:28,910 --> 00:47:32,540
所以 我们需要一个个拖动

890
00:47:32,540 --> 00:47:34,530
有些不幸 但至少 你知道

891
00:47:34,530 --> 00:47:36,700
我将它拖到已经存在的这个上

892
00:47:36,700 --> 00:47:40,950
我靠近时 它会高亮显示合适的位置

893
00:47:40,950 --> 00:47:45,020
因为它知道这是按钮的outlet collection

894
00:47:45,020 --> 00:47:47,870
所以这条属性会高亮显示

895
00:47:47,870 --> 00:47:50,260
我将把它们都集中到这里

896
00:47:50,260 --> 00:47:52,410
这样做时 有些容易犯错

897
00:47:52,410 --> 00:47:55,210
你可能会漏掉 所有最好是到这里来检验下

898
00:47:55,210 --> 00:47:58,220
你会看到所有12个按钮在这里

899
00:47:58,220 --> 00:47:59,420
有问题

900
00:48:00,710 --> 00:48:03,190
问得很好 问题是 顺序要不要紧

901
00:48:03,190 --> 00:48:04,560
顺序有没什么作用

902
00:48:04,560 --> 00:48:06,310
答案是没有

903
00:48:06,310 --> 00:48:09,670
这里对象的顺序对你完全是未知的

904
00:48:09,670 --> 00:48:11,220
你不能依赖于它

905
00:48:11,220 --> 00:48:14,690
如果你需要顺序 你需要用不同方式来做

906
00:48:14,690 --> 00:48:18,210
outlet collection中顺序是未知的

907
00:48:18,210 --> 00:48:21,310
所以不管我按什么顺序Control拖动它们

908
00:48:21,310 --> 00:48:23,570
这都不是数组中的顺序

909
00:48:23,570 --> 00:48:25,930
苹果这样决定是很好的

910
00:48:25,930 --> 00:48:29,580
也许你觉得这很好 但要放很多东西到这里

911
00:48:29,580 --> 00:48:31,820
要显示太难 而且你会被弄糊涂

912
00:48:31,820 --> 00:48:34,100
所以你需要使用别的机制

913
00:48:34,100 --> 00:48:37,800
我们后面的课上 会讲很多能够做到这个的机制

914
00:48:37,800 --> 00:48:39,850
这里只是一个很简单的做法

915
00:48:39,850 --> 00:48:42,340
对少量东西奏效

916
00:48:42,340 --> 00:48:45,650
无论如何 我们得到了到这些事物的连接

917
00:48:45,650 --> 00:48:47,990
现在 我们可以进行纸牌计数

918
00:48:47,990 --> 00:48:52,670
我们知道纸牌数量 我们可以说self.cardButtons

919
00:48:52,670 --> 00:48:56,740
也就是这个属性 count

920
00:48:59,170 --> 00:49:02,710
这就是这一数组中按钮的数量

921
00:49:02,730 --> 00:49:06,090
这很好 对我们而言很不错

922
00:49:06,090 --> 00:49:10,190
有了这个很好的按钮数组之后 我们还可以更新它们

923
00:49:10,190 --> 00:49:13,010
配合模型中发生的情况

924
00:49:13,010 --> 00:49:15,690
首先 让我们来讨论触摸一张牌时 该怎么做

925
00:49:15,690 --> 00:49:17,900
首先 让我们来讨论触摸一张牌时 该怎么做

926
00:49:17,900 --> 00:49:21,920
显然不是这一堆垃圾 删掉这些

927
00:49:21,920 --> 00:49:24,670
因为我们要让模型来处理

928
00:49:24,670 --> 00:49:28,780
要让模型来处理 我们需要做的是

929
00:49:28,780 --> 00:49:33,060
获得这一按钮所关联的纸牌

930
00:49:33,060 --> 00:49:35,460
因为这些按钮仍然在发送这个

931
00:49:35,460 --> 00:49:38,610
看这个 12个都在发送这个动作

932
00:49:38,610 --> 00:49:42,190
而发送器仍然是你实际触摸的按钮

933
00:49:42,190 --> 00:49:43,850
不是数组 而是实际按钮

934
00:49:43,850 --> 00:49:46,830
因为这是这里的目标动作事物

935
00:49:46,830 --> 00:49:50,790
我们仍然能够弄清 是谁发送的 实际上

936
00:49:50,790 --> 00:49:54,180
我们甚至还可以找到它在这个数组中的下标

937
00:49:54,180 --> 00:49:57,320
通过如下代码 cardIndex =

938
00:49:57,320 --> 00:50:02,490
[self.cardButtons indextOfObject:sender]

939
00:50:02,490 --> 00:50:03,800
这将告诉我们

940
00:50:03,800 --> 00:50:09,330
这一发送按钮处在数组中什么地方

941
00:50:10,760 --> 00:50:13,920
这样我们就知道了它是数组中哪张牌

942
00:50:13,920 --> 00:50:18,910
我们可以让游戏 选择那一下标处的纸牌

943
00:50:22,040 --> 00:50:25,170
我们会告诉我们的模型 嘿 选那张牌

944
00:50:25,170 --> 00:50:26,960
有一点要注意

945
00:50:26,960 --> 00:50:30,020
选那张牌可能改变游戏状态

946
00:50:30,020 --> 00:50:33,180
这会导致分数变化 或纸牌匹配

947
00:50:33,180 --> 00:50:34,670
很多东西会变

948
00:50:34,670 --> 00:50:37,980
所以这里需要updateUI来更新UI

949
00:50:37,980 --> 00:50:40,050
这个updateUI方法

950
00:50:40,050 --> 00:50:44,120
等下我们会写 它会让UI同模型同步

951
00:50:44,120 --> 00:50:47,170
记得吧 这是控制器的首要任务之一

952
00:50:47,170 --> 00:50:51,080
它会同步模型和UI

953
00:50:51,780 --> 00:50:54,930
这里我们来加一小段代码

954
00:50:54,930 --> 00:50:56,870
updateUI

955
00:50:56,870 --> 00:51:00,050
更新UI时我们需要做什么呢

956
00:51:00,050 --> 00:51:04,430
其实很简单 我们将遍历所有纸牌按钮

957
00:51:04,430 --> 00:51:09,800
获得那个纸牌按钮 同时在模型中观察相应纸牌

958
00:51:09,800 --> 00:51:13,910
确保纸牌按钮展示出它所应该展示的纸牌内容

959
00:51:13,910 --> 00:51:19,280
所以这里需要 for (UIButton *cardButton

960
00:51:19,280 --> 00:51:22,020
属于我们的cardButtons中)

961
00:51:22,020 --> 00:51:24,500
这里是遍历所有这些按钮

962
00:51:24,500 --> 00:51:27,770
carbButton是迭代变量

963
00:51:27,770 --> 00:51:31,800
让我们获取cardIndex 还是一样

964
00:51:31,800 --> 00:51:35,290
self.cardButtons indexOfObject

965
00:51:35,290 --> 00:51:38,550
carbButton是我们的迭代变量

966
00:51:38,550 --> 00:51:40,580
这些东西明白了吗

967
00:51:40,580 --> 00:51:43,370
我们弄清了这是哪张牌

968
00:51:43,370 --> 00:51:49,040
然后我们要让模型给我们那一下标处的牌

969
00:51:49,040 --> 00:51:51,200
使用cardAtIndex

970
00:51:54,450 --> 00:51:58,650
现在我们就有了纸牌按钮和纸牌 很棒

971
00:51:58,650 --> 00:52:03,610
下面我们来确保纸牌按钮反映了纸牌上的情况

972
00:52:03,610 --> 00:52:06,410
我们需要在按钮上设置什么

973
00:52:06,410 --> 00:52:10,500
我们需要设置纸牌按钮的标题

974
00:52:10,500 --> 00:52:12,390
这里是setTitle:

975
00:52:12,390 --> 00:52:18,040
forState:UIControlStateNormal

976
00:52:19,520 --> 00:52:22,700
我们还需要设置背景图像

977
00:52:23,160 --> 00:52:26,720
取决于这里是斯坦福logo还是空白背景

978
00:52:29,800 --> 00:52:33,700
而且 如果纸牌已被匹配

979
00:52:33,700 --> 00:52:35,730
我将禁用按钮

980
00:52:35,730 --> 00:52:37,730
因为纸牌已经被匹配

981
00:52:37,730 --> 00:52:39,980
你不能再点它 我将禁用它

982
00:52:39,980 --> 00:52:41,920
因为禁用的按钮会略显不同

983
00:52:41,920 --> 00:52:44,390
而我希望已匹配的按钮有所不同

984
00:52:44,390 --> 00:52:45,020
请讲

985
00:52:50,970 --> 00:52:51,840
确实

986
00:52:51,840 --> 00:52:54,760
问题是 这样的快速枚举

987
00:52:54,760 --> 00:52:56,570
使用这种for in结构

988
00:52:56,570 --> 00:52:59,690
是从0到N吗 答案是肯定的

989
00:52:59,690 --> 00:53:01,930
确实是按顺序来的

990
00:53:01,930 --> 00:53:05,690
你可以 问题是 这不是必需的吧

991
00:53:05,690 --> 00:53:07,680
你可以用别的迭代变量

992
00:53:07,680 --> 00:53:10,440
或者你也可以使用迭代变量i

993
00:53:10,440 --> 00:53:12,220
如for i = 0 to 长度

994
00:53:12,220 --> 00:53:13,540
你可以

995
00:53:13,550 --> 00:53:17,390
我不喜欢用那种0到具体长度

996
00:53:17,390 --> 00:53:20,540
所以我使用这个 这是风格问题

997
00:53:20,540 --> 00:53:21,650
完全是风格问题

998
00:53:21,650 --> 00:53:23,010
而且这样更清晰一些

999
00:53:23,010 --> 00:53:25,330
因为这里我说 我想要

1000
00:53:25,330 --> 00:53:28,320
这里的所有纸牌按钮

1001
00:53:28,320 --> 00:53:31,110
最后我要说的是

1002
00:53:31,110 --> 00:53:38,220
cardButton.enabled = !card.isMatched

1003
00:53:40,310 --> 00:53:43,980
只有纸牌没有被匹配时 按钮才启用

1004
00:53:45,120 --> 00:53:49,040
当然 我还有这两个东西没有提供

1005
00:53:49,040 --> 00:53:52,540
我们还没有这些参数

1006
00:53:52,540 --> 00:53:54,320
实际上对于这两者

1007
00:53:54,320 --> 00:53:59,210
我都将创建别的辅助方法

1008
00:53:59,210 --> 00:54:01,270
对于标题

1009
00:54:01,270 --> 00:54:04,150
我将创建一个辅助方法叫titleForCard

1010
00:54:04,980 --> 00:54:06,980
它使用card作为参数

1011
00:54:07,500 --> 00:54:10,320
而且它会返回card的标题

1012
00:54:10,320 --> 00:54:12,900
背景我将使用(UIImage *)

1013
00:54:12,910 --> 00:54:16,330
backgroundImageForCard

1014
00:54:18,360 --> 00:54:22,010
但愿随着课程推进 你们能理解我们的命名惯例

1015
00:54:22,010 --> 00:54:26,940
我们通常会把冒号前名称的最后这部分

1016
00:54:26,940 --> 00:54:29,190
用来表示我们要的东西

1017
00:54:29,190 --> 00:54:32,380
这里我们要的是一张牌

1018
00:54:32,380 --> 00:54:35,890
再看这个 按钮 对吧 这是一个按钮

1019
00:54:35,890 --> 00:54:38,680
这里我们是在告诉代码的读者

1020
00:54:38,680 --> 00:54:42,150
我们想要放到这里的是什么参数

1021
00:54:42,150 --> 00:54:44,460
对此 我们也不必太过拘泥

1022
00:54:44,460 --> 00:54:47,430
不过总的命名惯例就是这样

1023
00:54:47,430 --> 00:54:49,550
一张给定纸牌的标题是什么

1024
00:54:49,550 --> 00:54:51,970
我有一张牌 它的标题是什么

1025
00:54:51,970 --> 00:54:55,030
如果纸牌已被选择

1026
00:54:55,030 --> 00:54:58,220
那么我将返回纸牌的内容

1027
00:54:58,220 --> 00:55:01,110
否则 我会返回空字符串或nil

1028
00:55:01,110 --> 00:55:04,660
所以这里写 return card.isChosen

1029
00:55:04,660 --> 00:55:07,440
? card.contents

1030
00:55:07,440 --> 00:55:08,460
否则

1031
00:55:08,460 --> 00:55:11,150
空字符串或nil 这里都行

1032
00:55:11,150 --> 00:55:12,770
背景图像怎么办呢

1033
00:55:12,770 --> 00:55:16,220
这个很酷 这里我说 返回UIImage

1034
00:55:16,220 --> 00:55:22,200
图像名为card.isChosen

1035
00:55:22,200 --> 00:55:26,610
如果纸牌被选 那么我想要正面

1036
00:55:26,610 --> 00:55:28,610
否则我想要反面

1037
00:55:28,610 --> 00:55:34,070
你肯定会觉得 我很钟爱这种?:语法

1038
00:55:34,070 --> 00:55:36,140
我确实喜欢 它很简洁

1039
00:55:36,140 --> 00:55:37,850
反正你们是懂的 对吧

1040
00:55:37,850 --> 00:55:40,780
我在名称这里

1041
00:55:40,780 --> 00:55:42,980
嵌套了?:结构

1042
00:55:42,980 --> 00:55:45,920
这样来获得图像

1043
00:55:47,570 --> 00:55:50,050
下面 我就可以将其用到这里了

1044
00:55:50,050 --> 00:55:51,270
首先是标题

1045
00:55:51,270 --> 00:55:54,940
这里我写 self titleForCard:card

1046
00:55:54,940 --> 00:55:56,640
然后这里我写

1047
00:55:56,640 --> 00:55:59,420
self backgroundImageForCard:card

1048
00:55:59,420 --> 00:56:04,760
这两处我都加个回车 这样更清晰一些

1049
00:56:04,760 --> 00:56:08,060
这基本就算完了

1050
00:56:08,060 --> 00:56:11,980
我将UI同模型匹配了起来

1051
00:56:11,980 --> 00:56:16,250
触摸UI时 我让模型知道去选一张牌

1052
00:56:16,260 --> 00:56:19,180
我们基本上搞定了

1053
00:56:19,180 --> 00:56:23,230
我想我要做的都做了 分数我等下再处理

1054
00:56:23,230 --> 00:56:26,190
分数确实需要 但这之前

1055
00:56:26,190 --> 00:56:29,270
我们先来运行这个 确保它能工作

1056
00:56:29,270 --> 00:56:33,870
我点它 得到的应该是随机纸牌

1057
00:56:33,870 --> 00:56:37,180
再点它 应该得到相同的牌

1058
00:56:37,180 --> 00:56:39,810
如果总得到随机纸牌 那就糟了

1059
00:56:39,810 --> 00:56:42,180
但我们删掉了那部分代码 肯定不会是那样

1060
00:56:42,180 --> 00:56:43,620
这里是K

1061
00:56:43,630 --> 00:56:44,770
然后是5

1062
00:56:44,770 --> 00:56:46,640
2 我们得到了两个梅花

1063
00:56:46,640 --> 00:56:49,320
我可以这样做 哦 不能匹配

1064
00:56:49,320 --> 00:56:51,920
为什么不能匹配上呢

1065
00:56:51,920 --> 00:56:53,210
它们应该匹配上

1066
00:56:53,210 --> 00:56:55,980
原因有人能够告诉我吗 请讲

1067
00:56:57,400 --> 00:56:58,490
正是

1068
00:56:58,490 --> 00:57:01,900
我们唯一的匹配函数 是这个很糟糕的match函数

1069
00:57:01,900 --> 00:57:03,410
我们来看看

1070
00:57:03,410 --> 00:57:07,930
它在Card中 整个应用中就这唯一一个匹配函数

1071
00:57:07,930 --> 00:57:10,040
它在Card中 整个应用中就这唯一一个匹配函数

1072
00:57:10,040 --> 00:57:13,370
它说 只有两张牌完全相等时才匹配

1073
00:57:13,370 --> 00:57:15,880
这在我们的情况中永远无法成立

1074
00:57:15,880 --> 00:57:19,500
因为我们的牌堆中是52张不同的牌

1075
00:57:19,500 --> 00:57:22,310
这将永远无法匹配上 怎么解决呢

1076
00:57:22,310 --> 00:57:27,450
我们需要告诉PlayingCard如何更好地匹配

1077
00:57:27,450 --> 00:57:32,000
因为Card对match的这种实现根本不够

1078
00:57:32,000 --> 00:57:34,520
所以我们需要重写这个

1079
00:57:34,520 --> 00:57:35,940
我们使用面向对象编程

1080
00:57:35,940 --> 00:57:38,360
我们在这里就是做这个 我将重写它

1081
00:57:38,360 --> 00:57:40,500
我们来到PlayingCard 这是PlayingCard

1082
00:57:40,500 --> 00:57:45,900
注意到 PlayingCard没有在公共API中声明match

1083
00:57:45,920 --> 00:57:48,180
它是从Card中继承得到的

1084
00:57:48,180 --> 00:57:51,530
我不打算重新声明它 因为我只需要实现它

1085
00:57:51,530 --> 00:57:56,970
我将到这里重新实现match

1086
00:57:56,970 --> 00:58:00,020
它知道match是我继承的方法

1087
00:58:00,020 --> 00:58:02,300
因此 这里它能够自动补全

1088
00:58:02,300 --> 00:58:05,070
但我不打算把它放入我的公共API

1089
00:58:05,070 --> 00:58:06,630
这就是我们的一般做法

1090
00:58:06,630 --> 00:58:09,610
一般而言 如果你继承了一个公共方法

1091
00:58:09,610 --> 00:58:12,170
你重写它 你就不需要再把它放入你的头文件了

1092
00:58:12,170 --> 00:58:14,820
有些人的风格希望把它放到那里

1093
00:58:14,820 --> 00:58:17,090
这样别人就知道你在重写它

1094
00:58:17,090 --> 00:58:19,420
但大多数面向对象的人会说

1095
00:58:19,420 --> 00:58:21,890
你不需要知道你重写了它

1096
00:58:21,890 --> 00:58:23,640
这是面向对象编程

1097
00:58:23,640 --> 00:58:24,970
你无需知道这个

1098
00:58:24,970 --> 00:58:29,080
你重写了match只是实现细节

1099
00:58:29,080 --> 00:58:32,490
我是不将match写到PlayingCard中的支持者

1100
00:58:32,490 --> 00:58:34,570
它已经在PlayingCard公共API中了

1101
00:58:34,570 --> 00:58:36,620
因为这会继承自Card

1102
00:58:36,620 --> 00:58:38,510
match中我们怎么做呢

1103
00:58:38,510 --> 00:58:40,320
我这里随便弄一个

1104
00:58:40,320 --> 00:58:42,090
你们在作业中需要设计个更好的

1105
00:58:42,090 --> 00:58:44,950
我这个笨拙的match将只匹配一张牌

1106
00:58:44,950 --> 00:58:47,040
所以这里首先我要说的是

1107
00:58:47,040 --> 00:58:51,770
int score = 0以及return score

1108
00:58:51,770 --> 00:58:53,930
然后我要说的第一件事是

1109
00:58:53,930 --> 00:58:59,120
if ([otherCards count] == 1)

1110
00:58:59,120 --> 00:59:02,090
我将只匹配一张牌

1111
00:59:02,090 --> 00:59:04,660
有两张牌 则没有匹配

1112
00:59:04,660 --> 00:59:06,420
对我而言 太多了

1113
00:59:06,420 --> 00:59:09,070
所以我只处理这一张牌

1114
00:59:09,070 --> 00:59:12,040
但我需要这另外一张牌 如何获得呢

1115
00:59:12,040 --> 00:59:14,170
我要说的是

1116
00:59:14,170 --> 00:59:20,270
PlayingCard *otherCard =

1117
00:59:20,270 --> 00:59:22,390
这里我可以做很多事

1118
00:59:22,390 --> 00:59:25,080
我可以说 otherCards[0]

1119
00:59:25,090 --> 00:59:28,440
但这里 我想使用一个我希望你们知道的方法

1120
00:59:28,440 --> 00:59:31,290
叫作firstObject

1121
00:59:31,290 --> 00:59:34,840
otherCards firstObject

1122
00:59:34,840 --> 00:59:38,530
firstObject返回数组的第一个对象

1123
00:59:38,530 --> 00:59:41,720
如果数组为空 它会返回nil

1124
00:59:41,720 --> 00:59:44,810
这不同于otherCards[0]

1125
00:59:44,810 --> 00:59:47,660
otherCards[0]在数组为空时会崩溃

1126
00:59:47,660 --> 00:59:49,160
导致数组下标越界错误

1127
00:59:49,160 --> 00:59:50,160
明白这种差别吗

1128
00:59:50,160 --> 00:59:52,340
firstObject 还有lastObject

1129
00:59:52,340 --> 00:59:57,450
它们有这种避免数组下标越界的额外功效

1130
00:59:57,450 --> 00:59:59,790
firstObject会返回第一个对象或nil

1131
00:59:59,790 --> 01:00:01,360
如果没有对象的话

1132
01:00:01,360 --> 01:00:02,660
我想让你们知道这个

1133
01:00:02,660 --> 01:00:04,350
这里其实并不需要这样

1134
01:00:04,350 --> 01:00:06,830
因为我知道数组中有一个对象

1135
01:00:06,830 --> 01:00:09,700
所以这里并不必要 我可以说otherCards[0]

1136
01:00:09,700 --> 01:00:11,440
这里没有问题 我只是

1137
01:00:11,440 --> 01:00:14,050
希望教给你们firstObject方法 仅此而已

1138
01:00:14,050 --> 01:00:15,800
这就得到了另一张牌

1139
01:00:15,800 --> 01:00:18,960
我们来匹配它 好的匹配是怎样的呢

1140
01:00:18,960 --> 01:00:22,770
如果花色匹配上 我会给一点分数

1141
01:00:22,770 --> 01:00:25,130
如果大小匹配上 我会给更多分数

1142
01:00:25,130 --> 01:00:26,660
这里我说

1143
01:00:26,660 --> 01:00:35,740
if ([self.suit isEqualToString:otherCard.suit])

1144
01:00:35,740 --> 01:00:38,240
这是花色匹配的情况 例如都是梅花

1145
01:00:38,240 --> 01:00:41,900
这时我将把分数score设为1

1146
01:00:41,900 --> 01:00:46,300
这里可以用else 因为这里假设所有牌都不同

1147
01:00:46,300 --> 01:00:50,060
如果牌一样 只得到花色匹配的分数

1148
01:00:50,070 --> 01:00:52,100
就会显得很荒谬

1149
01:00:52,100 --> 01:00:54,840
但这里没问题 再有 if ([self.rank])

1150
01:00:54,840 --> 01:00:56,580
噢 这里不需要发送消息

1151
01:00:56,580 --> 01:01:00,380
if (self.rank == otherCards.rank)

1152
01:01:00,380 --> 01:01:02,430
那我们就给4分

1153
01:01:02,430 --> 01:01:04,720
为什么是4分对1分呢

1154
01:01:04,720 --> 01:01:06,790
想想这里的数学

1155
01:01:06,790 --> 01:01:09,810
你手里有一张梅花 牌堆里还有多少张梅花

1156
01:01:09,810 --> 01:01:12,140
你手里有一张梅花 牌堆里还有多少张梅花

1157
01:01:12,140 --> 01:01:17,260
12张 如果我有一张K 还有多少K

1158
01:01:17,260 --> 01:01:18,380
3张

1159
01:01:18,380 --> 01:01:23,320
12:3 所以一整副牌中 匹配花色要容易四倍

1160
01:01:23,320 --> 01:01:25,220
这里我只是随机选的数字

1161
01:01:25,220 --> 01:01:28,210
对于这里的评分 这并不糟糕

1162
01:01:28,210 --> 01:01:31,000
不过多数时候相对分值不能搞错

1163
01:01:31,000 --> 01:01:32,010
有问题

1164
01:01:33,510 --> 01:01:36,540
问题是 这里我是不是使用了固定数字 正是

1165
01:01:36,540 --> 01:01:40,120
在我们的简单实现中 整个评分系统都是用的固定数字

1166
01:01:40,120 --> 01:01:44,030
在我们的简单实现中 整个评分系统都是用的固定数字

1167
01:01:44,030 --> 01:01:46,940
你也许…

1168
01:01:46,940 --> 01:01:49,980
这里并不一定要是固定数字

1169
01:01:49,980 --> 01:01:55,380
如果你定义最简单的匹配得分为1

1170
01:01:55,380 --> 01:01:57,560
然后让更复杂的匹配

1171
01:01:57,560 --> 01:02:00,790
是它的乘数倍 例如像这样更难的情况

1172
01:02:00,790 --> 01:02:01,990
那么这就是对的

1173
01:02:01,990 --> 01:02:05,160
因为这个4对于扑克牌是基本的

1174
01:02:05,160 --> 01:02:09,490
这对于扑克牌的大小和花色是很基本的

1175
01:02:09,490 --> 01:02:11,300
只要你定义的匹配

1176
01:02:11,310 --> 01:02:13,700
只匹配相同牌堆中的其它扑克牌

1177
01:02:13,700 --> 01:02:16,830
这个4是固定的 但它对于这个类是固定的

1178
01:02:16,830 --> 01:02:18,540
没错 你可以使用#define

1179
01:02:18,540 --> 01:02:21,110
但这并没有减弱它的固定性质

1180
01:02:21,110 --> 01:02:23,490
它是固定的 但你可以把它用到这里

1181
01:02:23,490 --> 01:02:25,320
明白我说的了吗 明白差别了吗

1182
01:02:25,320 --> 01:02:27,320
这不同于控制器中的102

1183
01:02:27,320 --> 01:02:31,510
尝试把情况设置成通用的牌堆 这有些不同

1184
01:02:31,510 --> 01:02:33,290
问得很好

1185
01:02:33,290 --> 01:02:35,300
这样 我们有了更好的匹配

1186
01:02:35,300 --> 01:02:41,380
下面我们回到控制器中

1187
01:02:41,380 --> 01:02:43,060
回到这里的屏幕

1188
01:02:43,080 --> 01:02:45,430
然后运行

1189
01:02:48,320 --> 01:02:51,910
但愿这里我们能够找到匹配

1190
01:02:51,910 --> 01:02:54,030
好 这里有张梅花

1191
01:02:54,030 --> 01:02:56,550
这里也有一张梅花 将它们匹配起来

1192
01:02:56,550 --> 01:02:57,950
哦 确实能匹配上

1193
01:02:57,950 --> 01:02:59,880
而且禁用了这两个按钮

1194
01:02:59,880 --> 01:03:02,210
但我不知道我得到了多少分

1195
01:03:02,210 --> 01:03:04,060
因为这里没有显示分数

1196
01:03:04,060 --> 01:03:06,950
显然我们需要分数 下面把分数加进来

1197
01:03:06,950 --> 01:03:09,730
希望现在你们能够很容易地想象到

1198
01:03:09,730 --> 01:03:11,300
我们应该如何加入分数

1199
01:03:11,300 --> 01:03:13,190
很简单 就像翻牌计数一样

1200
01:03:13,190 --> 01:03:14,700
我们使用这里的标签

1201
01:03:14,700 --> 01:03:19,110
把它拖到这里 这里改成分数：0

1202
01:03:19,110 --> 01:03:23,010
因为这就是最开始我想要的分数情况

1203
01:03:23,010 --> 01:03:25,800
确实 你可以在开始时加载这些字符串

1204
01:03:25,800 --> 01:03:31,290
后面几讲中我会讲到代码中何时何地这样做

1205
01:03:31,290 --> 01:03:34,930
有了这个分数后 我显然需要能够同它通信

1206
01:03:34,930 --> 01:03:39,380
于是我Control拖动到接口创建一个outlet

1207
01:03:39,380 --> 01:03:41,110
松手 这个应该是outlet

1208
01:03:41,110 --> 01:03:43,260
不是outlet collection 而是outlet

1209
01:03:43,260 --> 01:03:46,650
我将它称作scoreLabel(分数标签)

1210
01:03:46,650 --> 01:03:47,780
它可以是弱的

1211
01:03:47,790 --> 01:03:51,680
因为我们知道视图会指向它 它是UILabel

1212
01:03:51,680 --> 01:03:53,330
这里有了它的outlet

1213
01:03:53,330 --> 01:03:56,120
我将在updateUI中更新它

1214
01:03:56,120 --> 01:03:57,210
所以这里我说

1215
01:03:57,210 --> 01:04:00,710
self.scoreLabel = [NSString

1216
01:04:00,710 --> 01:04:04,930
stringWithFormat:@"Score:%d"…

1217
01:04:04,930 --> 01:04:07,360
分数从哪里得到

1218
01:04:09,910 --> 01:04:13,450
有人知道分数从哪里得到吗

1219
01:04:13,450 --> 01:04:14,640
从game 正是

1220
01:04:14,640 --> 01:04:17,550
从我们的模型 self.game.score

1221
01:04:19,230 --> 01:04:22,600
下面我来展示一下 确保大家理解了

1222
01:04:22,600 --> 01:04:24,670
这是我的CardMatchingGame

1223
01:04:24,670 --> 01:04:30,710
记得吧 在它的公共API中有score

1224
01:04:30,710 --> 01:04:34,470
选择时 我们会计分

1225
01:04:34,470 --> 01:04:37,270
大家都明白了吗

1226
01:04:37,270 --> 01:04:38,690
这就是了

1227
01:04:38,690 --> 01:04:42,140
更新分数要做的事我们都做了

1228
01:04:42,140 --> 01:04:46,270
一般我们… 噢 这里需要scoreLabel.text

1229
01:04:46,270 --> 01:04:51,290
抱歉 我们需要UILabel类的text属性

1230
01:04:51,290 --> 01:04:53,540
我们会调用它的setter 设置text

1231
01:04:53,540 --> 01:04:56,380
这就是这里发生的情况 设置分数

1232
01:04:57,140 --> 01:04:58,900
我还要做一件事

1233
01:04:58,900 --> 01:05:03,490
也就是防止分数太大 把这个拉宽一些 然后运行

1234
01:05:03,490 --> 01:05:06,730
我们以后会讲到 文本框如何

1235
01:05:06,730 --> 01:05:09,600
随你输入的文本而增大

1236
01:05:09,600 --> 01:05:11,930
iOS中有处理这个的方式

1237
01:05:11,930 --> 01:05:15,360
不过我们一次讲不了那么多内容

1238
01:05:15,360 --> 01:05:16,390
这里我们看看

1239
01:05:16,390 --> 01:05:17,070
-1

1240
01:05:17,070 --> 01:05:18,480
为什么获得-1分

1241
01:05:18,480 --> 01:05:20,340
因为翻牌是有成本的

1242
01:05:20,340 --> 01:05:23,840
每次翻牌都有代价

1243
01:05:23,840 --> 01:05:26,960
这是黑桃 这也是黑桃 对吧

1244
01:05:26,960 --> 01:05:29,120
我点这个之后 分数会是多少

1245
01:05:29,120 --> 01:05:32,170
点这个还是会花掉1分

1246
01:05:32,170 --> 01:05:35,490
这会让我的分数减少为-6

1247
01:05:35,490 --> 01:05:39,370
但匹配正确后我能得到1分乘以4分的红利

1248
01:05:39,380 --> 01:05:40,880
也就是4分

1249
01:05:40,880 --> 01:05:43,040
所以我的分数应该是-2

1250
01:05:43,040 --> 01:05:45,280
对吧 确实也是

1251
01:05:45,280 --> 01:05:48,710
很好 看看能否找到匹配的大小

1252
01:05:50,990 --> 01:05:53,210
哦 这里有个6 这里也有个6

1253
01:05:53,210 --> 01:05:56,390
我将让这两个匹配上 分数会变成多少

1254
01:05:56,390 --> 01:05:58,740
现在是-9 点这个以后

1255
01:05:58,740 --> 01:06:01,370
分数降到-10 但它们会匹配上

1256
01:06:01,370 --> 01:06:02,260
我将得到4分

1257
01:06:02,260 --> 01:06:05,790
乘以4分的红利 总共得16分

1258
01:06:05,790 --> 01:06:07,560
因此分数将变成+6

1259
01:06:07,560 --> 01:06:09,090
大家都同意吗

1260
01:06:09,930 --> 01:06:12,820
没问题 分数为+6

1261
01:06:14,000 --> 01:06:15,720
这就完了

1262
01:06:15,720 --> 01:06:20,480
今天我要讲的就这些 最后还有一些幻灯片

1263
01:06:20,480 --> 01:06:22,940
不过demo就这些了

1264
01:06:22,940 --> 01:06:26,420
你们的作业是匹配两张或三张牌

1265
01:06:26,420 --> 01:06:28,530
你们的作业是匹配两张或三张牌

1266
01:06:28,530 --> 01:06:31,820
你可以在UI中加一个开关

1267
01:06:31,820 --> 01:06:35,230
在两张或三张牌的匹配之间切换

1268
01:06:35,230 --> 01:06:39,540
这需要模型中改变一些逻辑

1269
01:06:39,540 --> 01:06:42,600
也需要更多一点的UI

1270
01:06:42,600 --> 01:06:46,400
还需要你的控制器将两者衔接起来

1271
01:06:46,400 --> 01:06:52,100
你还需要在这里加一个标签 描述这里发生了什么

1272
01:06:52,100 --> 01:06:55,690
但我点这里时 它要告诉我 你选了红桃7

1273
01:06:55,690 --> 01:06:57,970
当我选这个时 它要告诉我

1274
01:06:57,970 --> 01:07:02,720
红心7和梅花2无法匹配上 -2 诸如此类

1275
01:07:04,020 --> 01:07:07,890
如果选了两张确实匹配的牌

1276
01:07:07,890 --> 01:07:09,980
例如

1277
01:07:09,990 --> 01:07:11,470
这两张红心

1278
01:07:11,470 --> 01:07:14,940
它应该说 红心4和红心7匹配 得多少分

1279
01:07:14,940 --> 01:07:15,290
有问题

1280
01:07:18,740 --> 01:07:20,220
如何在设备上测试它

1281
01:07:20,220 --> 01:07:23,240
我们在设备上运行一下试试 问得很好

1282
01:07:23,240 --> 01:07:26,910
这里我连了一个设备 你可以看到

1283
01:07:26,910 --> 01:07:30,110
它要求我更新 我们这里不会照做

1284
01:07:30,110 --> 01:07:34,320
在XCode上面 你会看到一些

1285
01:07:34,320 --> 01:07:37,020
不同的模拟器可供运行

1286
01:07:37,020 --> 01:07:39,740
你还可以在连接的设备上运行

1287
01:07:39,740 --> 01:07:43,880
下周五我们或许将有一节课

1288
01:07:43,880 --> 01:07:46,430
或下下周 我们会为你展示

1289
01:07:46,430 --> 01:07:50,020
如何注册你的设备 并将所有这些设置好

1290
01:07:50,020 --> 01:07:52,940
这可以说是一个预览 我将在iPad上运行

1291
01:07:52,940 --> 01:07:58,780
我将选择iPad 点击运行 它就会在iPad上运行了

1292
01:07:58,780 --> 01:08:01,980
我以后会为大多数demo这样做

1293
01:08:01,980 --> 01:08:05,980
在设备上运行 而不是在模拟器上

1294
01:08:05,980 --> 01:08:09,390
这更好一些 因为屏幕更大

1295
01:08:09,390 --> 01:08:12,930
如这里所示 这是在我的iPad上

1296
01:08:12,930 --> 01:08:16,590
我可以轻击它 噢 死机了

1297
01:08:16,590 --> 01:08:18,330
这不是很好

1298
01:08:18,330 --> 01:08:21,260
我做错了什么

1299
01:08:21,260 --> 01:08:23,520
我不知道哪里出了问题

1300
01:08:23,520 --> 01:08:26,130
反正过程中我搞砸了 很抱歉

1301
01:08:26,130 --> 01:08:27,420
我会展示这个的

1302
01:08:27,420 --> 01:08:32,740
下周三开始 我将在设备上运行所有这些东西

1303
01:08:32,740 --> 01:08:36,410
但愿到时候不会出现这样的错误 很抱歉

1304
01:08:36,410 --> 01:08:38,340
无论如何 今天就到这里

1305
01:08:38,340 --> 01:08:39,720
还有问题吗

1306
01:08:39,720 --> 01:08:44,000
更多内容 请访问我校官网stanford.edu

