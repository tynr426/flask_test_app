1
00:00:05,380 --> 00:00:09,000
斯坦福大学

2
00:00:09,000 --> 00:00:14,400
好 欢迎来到2013-14学年斯坦福CS193P秋季课程

3
00:00:14,440 --> 00:00:16,480
这是我们的第一讲

4
00:00:16,480 --> 00:00:20,030
我们要讲的是iOS应用开发

5
00:00:20,030 --> 00:00:22,960
这里将特别针对iOS7

6
00:00:22,980 --> 00:00:26,000
今天的课分为上下两部分

7
00:00:26,000 --> 00:00:28,000
前半部分是一些课务信息

8
00:00:28,000 --> 00:00:30,990
后半部分我将开始正式讲课

9
00:00:30,990 --> 00:00:33,000
因为要讲的有很多

10
00:00:33,000 --> 00:00:36,000
我需要尽早开始

11
00:00:36,000 --> 00:00:38,270
这门课会学到一些什么呢

12
00:00:38,290 --> 00:00:40,140
你应该知道这门课会教些什么

13
00:00:40,140 --> 00:00:42,570
你们会学到如何创建很酷的app

14
00:00:42,590 --> 00:00:45,700
iOS是一个很酷的app创建平台

15
00:00:45,720 --> 00:00:47,000
你们可能已经知道了

16
00:00:47,000 --> 00:00:51,010
app非常酷 会有动画

17
00:00:51,010 --> 00:00:53,350
真正酷的是 它们就在你的口袋里

18
00:00:53,360 --> 00:00:55,330
你可以拿出来炫耀给朋友们

19
00:00:55,350 --> 00:00:58,010
你不需要发网址给他们 让他们去电脑上看

20
00:00:58,030 --> 00:01:03,000
而且你们将能在很短时间内轻松开发出强大的app

21
00:01:03,000 --> 00:01:05,680
这门课其实只有10周时间

22
00:01:05,700 --> 00:01:08,000
虽然这是斯坦福

23
00:01:08,000 --> 00:01:10,000
你们都是很厉害的编程高手

24
00:01:10,000 --> 00:01:13,940
但10周还是有点短 到最后

25
00:01:13,940 --> 00:01:17,920
你们会发现 这是一个很便于创建应用的平台

26
00:01:17,940 --> 00:01:20,620
而且这个领域也非常活跃

27
00:01:20,640 --> 00:01:23,510
你可以通过app商店销售你的app

28
00:01:23,530 --> 00:01:26,700
而不需要用盒子装起来在商店货架上出售

29
00:01:26,700 --> 00:01:30,360
这对于销售产品而言是一个巨大的不同

30
00:01:30,380 --> 00:01:32,000
你们会看到这个

31
00:01:32,000 --> 00:01:36,510
从这门课你们将学到的第二点是 现实世界应用

32
00:01:36,530 --> 00:01:40,220
将其它课程中学到的很多计算机科学内容应用于现实

33
00:01:40,730 --> 00:01:42,500
我们会用到网络

34
00:01:42,500 --> 00:01:44,500
用到多线程

35
00:01:44,500 --> 00:01:46,100
用到各种图形

36
00:01:46,100 --> 00:01:47,500
用到动画

37
00:01:47,500 --> 00:01:49,500
用到面向对象的数据库

38
00:01:49,500 --> 00:01:51,310
这些东西都会被用于现实世界

39
00:01:51,310 --> 00:01:55,500
你们会了解到 如何应用所有这些计算机科学概念

40
00:01:55,500 --> 00:01:58,500
特别是将它们结合到现实世界的舞台

41
00:01:58,500 --> 00:02:00,500
你制作的可是真正的app

42
00:02:00,500 --> 00:02:04,960
我原来的很多学生 成十上百

43
00:02:04,960 --> 00:02:09,310
都将他们的app发布到了app商店 你们应该也能做到

44
00:02:09,330 --> 00:02:13,360
这是一门很好的课程 让你们能够

45
00:02:13,360 --> 00:02:16,880
将其它计算机科学课程上学到的很多知识

46
00:02:16,880 --> 00:02:20,680
完美地结合到现实世界中

47
00:02:20,680 --> 00:02:24,440
这门课的预备条件非常非常重要

48
00:02:24,440 --> 00:02:27,770
你们一定要确保满足这些预备条件

49
00:02:27,770 --> 00:02:31,500
你们要想好 不满足这些条件的 不要选这门课

50
00:02:31,500 --> 00:02:36,990
CS106 A和B或CS106X肯定是需要的

51
00:02:36,990 --> 00:02:40,500
如果没有相当的知识 想都不要想选这门课

52
00:02:40,500 --> 00:02:44,120
这学期我还基于经验加了第二个要求

53
00:02:44,140 --> 00:02:47,100
也就是CS107 或CS108更好

54
00:02:47,100 --> 00:02:50,500
选修过CS108的同学 可以说为这门课做好了充分准备

55
00:02:50,500 --> 00:02:53,500
或CS110就更好了

56
00:02:53,500 --> 00:02:56,500
我要求额外这些课程的原因在于

57
00:02:56,500 --> 00:03:00,010
希望你们有更多编程经验

58
00:03:00,030 --> 00:03:02,250
因为这门课中需要大量编程

59
00:03:02,250 --> 00:03:06,500
因此 习惯大量编程的同学 就能习惯这门课

60
00:03:06,500 --> 00:03:10,500
没有很多编程经验的同学会心想 喔 这里有很多编程

61
00:03:10,500 --> 00:03:14,500
这就有点让人心神不宁 所以我要求了这些条件

62
00:03:14,500 --> 00:03:16,500
如果你做过暑期实习

63
00:03:16,500 --> 00:03:18,500
过程中做过一些编程

64
00:03:18,500 --> 00:03:23,500
这显然也能替代CS107 108或110的作用

65
00:03:23,500 --> 00:03:27,440
或者如果你选修过更进阶的CS课程 当然也行

66
00:03:27,450 --> 00:03:30,160
你们需要了解这门课是一门

67
00:03:30,160 --> 00:03:32,160
编程课 有大量编程

68
00:03:32,160 --> 00:03:35,920
最重要的是 你需要很熟悉面向对象编程

69
00:03:35,940 --> 00:03:38,050
这里我列了一些术语

70
00:03:38,050 --> 00:03:41,530
如消息 实例变量 父类和子类

71
00:03:41,530 --> 00:03:44,500
如果你不能像手心手背那样熟悉这些术语

72
00:03:44,500 --> 00:03:46,500
要学好这门课将会很难

73
00:03:46,500 --> 00:03:48,790
因为我会不断随口说出这些

74
00:03:48,810 --> 00:03:51,500
iOS7完全是面向对象的

75
00:03:51,500 --> 00:03:54,500
其整个结构 设计都是面向对象的

76
00:03:54,500 --> 00:03:57,500
这是你必须知道的 如果你不知道

77
00:03:57,500 --> 00:03:59,500
你显然需要先学这些

78
00:03:59,500 --> 00:04:02,500
先去选CS106A&B或相当课程

79
00:04:02,500 --> 00:04:06,660
然后再去增加一些编程经验才行

80
00:04:06,680 --> 00:04:10,270
这门课需要大家编写app

81
00:04:10,270 --> 00:04:15,500
到第五周 第六周 你们需要写几十个类

82
00:04:15,500 --> 00:04:19,860
如果你原来写过的最大app只有3到5个类

83
00:04:19,860 --> 00:04:22,500
这将是大幅的跨越

84
00:04:23,950 --> 00:04:28,500
作业 前六七周是每周一次作业

85
00:04:28,500 --> 00:04:30,500
最后是一个期末项目

86
00:04:30,500 --> 00:04:32,500
所有作业都会详细给出 包括

87
00:04:32,500 --> 00:04:36,010
要求的任务是什么以及我们怎么评分

88
00:04:36,030 --> 00:04:37,800
而且我还会给出提示

89
00:04:37,810 --> 00:04:40,500
因为我不想把作业弄得奇难无比

90
00:04:40,500 --> 00:04:45,500
而且所有作业基本上都是为了

91
00:04:45,500 --> 00:04:49,500
巩固那一周课上所讲的知识

92
00:04:49,500 --> 00:04:52,180
而不是一些随机布置的新学习任务

93
00:04:52,190 --> 00:04:55,320
我相信这种教学理念 也就是

94
00:04:55,320 --> 00:04:59,640
首先我通过幻灯片给大家讲一个概念

95
00:04:59,640 --> 00:05:02,500
然后我再给大家演示例子

96
00:05:02,500 --> 00:05:04,500
实际写一个用到此概念的应用

97
00:05:04,500 --> 00:05:06,500
然后再让你们在作业中做这个

98
00:05:06,500 --> 00:05:10,500
课上的每一点内容我都会这么来讲

99
00:05:10,500 --> 00:05:13,080
到最后 你们就知道怎么做了

100
00:05:13,100 --> 00:05:15,500
你们就会很有信心 很有经验了

101
00:05:15,500 --> 00:05:17,500
作业都是这样的

102
00:05:17,500 --> 00:05:22,500
都是课堂上我讲过的 让你们去应用

103
00:05:22,500 --> 00:05:27,250
好 下面我将简要讲一下iOS中有些什么

104
00:05:27,250 --> 00:05:29,300
我想你们大多数人知道iOS中有什么

105
00:05:29,300 --> 00:05:31,770
你们都见过iOS设备

106
00:05:31,770 --> 00:05:35,500
我打赌 在座90%的人应该口袋里都有一个

107
00:05:35,500 --> 00:05:38,500
不过我准备总结一下

108
00:05:38,500 --> 00:05:40,500
这有些难

109
00:05:40,500 --> 00:05:43,500
因为我要用四五分钟或更少时间来讲

110
00:05:43,500 --> 00:05:46,270
这里内容其实很多 真要讲清楚可能需要两节课时间

111
00:05:46,270 --> 00:05:49,190
这里内容其实很多 真要讲清楚可能需要两节课时间

112
00:05:49,210 --> 00:05:54,620
这里我只是把事物组织成一些有意义的组

113
00:05:54,620 --> 00:05:58,380
让你们理解从开发视角应该怎么看它们

114
00:05:58,380 --> 00:06:02,190
然后我们就会开始做这些 你会开始意识到 哦

115
00:06:02,210 --> 00:06:04,500
你会开始学习如何查说明文档 你会意识到 哦

116
00:06:04,500 --> 00:06:06,500
查查这些 你就能知道怎么做

117
00:06:06,500 --> 00:06:08,230
这只是高层级的概览

118
00:06:08,250 --> 00:06:13,500
我将这些分为四组

119
00:06:13,500 --> 00:06:17,190
一是核心操作系统层 这是很接近硬件的一层

120
00:06:17,190 --> 00:06:20,500
核心服务层 这是之上的面向对象的一层

121
00:06:20,500 --> 00:06:24,010
这让你总能在面向对象的层上进行编程

122
00:06:24,010 --> 00:06:27,750
媒体层 因为这些设备基本上是iPod

123
00:06:27,750 --> 00:06:29,930
带一个手机或者大屏幕

124
00:06:29,950 --> 00:06:32,500
媒体在这些设备上很重要

125
00:06:32,500 --> 00:06:35,010
最后是触控应用层 这是UI层

126
00:06:35,030 --> 00:06:37,500
包括按钮和开关这些

127
00:06:37,500 --> 00:06:40,500
我们来谈谈这些层中都有什么

128
00:06:40,500 --> 00:06:43,500
浅析一下这些层

129
00:06:43,500 --> 00:06:48,500
在接近硬件的核心操作系统层 是一个Unix内核

130
00:06:48,500 --> 00:06:52,500
这个设备上是Unix操作系统

131
00:06:52,500 --> 00:06:55,860
基于BSD的Unix版本

132
00:06:55,860 --> 00:06:58,500
Unix有的一切它都有

133
00:06:58,500 --> 00:07:01,500
它有套接字 有文件系统

134
00:07:01,500 --> 00:07:03,780
权限 所有这些

135
00:07:03,780 --> 00:07:07,500
另外 这里还有一些特别用于移动设备的东西

136
00:07:07,500 --> 00:07:09,770
例如电源管理

137
00:07:09,770 --> 00:07:14,500
用于安全管理的钥匙串访问

138
00:07:14,500 --> 00:07:16,500
Bonjour 这是这种网络

139
00:07:16,500 --> 00:07:18,500
在网络上找其它东西

140
00:07:18,500 --> 00:07:23,040
所有这些都有 下方是这个很强大的操作系统

141
00:07:23,040 --> 00:07:26,500
但大多数API都是用C写的

142
00:07:26,500 --> 00:07:29,500
我们会完全在面向对象层进行编程

143
00:07:29,500 --> 00:07:32,500
我们主要需要触及到的

144
00:07:32,500 --> 00:07:35,500
是核心服务层的这些东西

145
00:07:35,500 --> 00:07:39,500
这一层有让语言更加强劲的东西

146
00:07:39,500 --> 00:07:41,280
这一层有让语言更加强劲的东西

147
00:07:41,280 --> 00:07:45,500
例如数组 字典 字符串等等

148
00:07:45,500 --> 00:07:49,080
而且它还有面向对象的方式来访问文件系统

149
00:07:49,100 --> 00:07:51,500
例如 它有面向对象的方式

150
00:07:51,500 --> 00:07:53,990
来寻找设备的GPS位置

151
00:07:54,010 --> 00:07:57,500
它还有方式来进行多线程操作

152
00:07:57,500 --> 00:08:00,450
所有这些你想要能够做到的事情

153
00:08:00,450 --> 00:08:04,930
不过所有这些你都希望以面向对象的方式来思考

154
00:08:04,950 --> 00:08:09,970
核心服务层有一个巨大的基础层用于做这些

155
00:08:09,970 --> 00:08:12,990
再看媒体层 不要小看这一层

156
00:08:12,990 --> 00:08:16,000
这一层很重要 这里有视频 有视频编辑

157
00:08:16,010 --> 00:08:18,280
当然 这里有能够显示的图像

158
00:08:18,280 --> 00:08:21,190
有很强大音频 用于3D音效

159
00:08:21,190 --> 00:08:23,500
例如游戏中 可以有泰拳打击的感觉

160
00:08:23,500 --> 00:08:25,500
就像真实的打斗一样

161
00:08:25,500 --> 00:08:27,260
所有这些都在这里

162
00:08:27,260 --> 00:08:29,500
iOS的这部分

163
00:08:29,500 --> 00:08:31,820
我无法很深入讲解

164
00:08:31,840 --> 00:08:35,150
我只是想让你们知道有这么一层

165
00:08:35,150 --> 00:08:39,500
你们可以根据未来应用程序需求来使用它

166
00:08:39,500 --> 00:08:44,500
不过这方面量很大 苹果设备根本上显然是多媒体设备

167
00:08:44,500 --> 00:08:48,500
最后是触控应用层 我们大多数时间都会花在这里

168
00:08:48,500 --> 00:08:53,690
这里你会设计一些按钮 滑动条 文本框

169
00:08:53,690 --> 00:08:57,580
这里有交互 动画发生 事物滑进滑出

170
00:08:57,580 --> 00:09:00,500
淡出淡入等等

171
00:09:00,500 --> 00:09:04,880
如果你要使用用户相机中的照片 你可以这样做

172
00:09:04,890 --> 00:09:06,520
还有本地化

173
00:09:06,520 --> 00:09:08,890
让你的app能够在世界上很多国家运行

174
00:09:08,890 --> 00:09:10,890
由此来提高销量

175
00:09:10,910 --> 00:09:15,500
还有一整套地图包 包括你们在iOS7中见过的3D地图

176
00:09:15,500 --> 00:09:17,500
所有这些都在这里

177
00:09:18,580 --> 00:09:23,500
视图中还可以将一整个网页浏览器放到一个小矩形中

178
00:09:23,500 --> 00:09:25,500
让它显示在你的app中

179
00:09:25,500 --> 00:09:28,740
这些是高层级的对象

180
00:09:28,750 --> 00:09:31,800
我们会深入探讨这一层

181
00:09:31,800 --> 00:09:33,500
这是最重要的内容

182
00:09:33,500 --> 00:09:36,780
这里触控叫作Cocoa Touch是因为

183
00:09:36,780 --> 00:09:40,500
这里的API最初是为Mac OS X开发的

184
00:09:40,500 --> 00:09:42,360
它叫Cocoa

185
00:09:42,360 --> 00:09:45,450
之后当它们被适用于iOS

186
00:09:45,450 --> 00:09:48,500
很多API都能在两平台之间共享

187
00:09:48,500 --> 00:09:51,500
如果你开发了一个iOS app 然后某天你想 哦

188
00:09:51,500 --> 00:09:54,990
我要为Mac开发一个app 使用Cocoa 这会非常类似

189
00:09:55,000 --> 00:09:58,500
你会感觉非常熟悉

190
00:09:58,500 --> 00:10:03,500
Cocoa Touch显然是Cocoa的触控版本

191
00:10:04,340 --> 00:10:08,500
Cocoa这个技术已经存在很久了

192
00:10:08,500 --> 00:10:11,500
也许三十年了 难以置信吧

193
00:10:11,500 --> 00:10:15,970
甚至在苹果开始使用Mac OS之前

194
00:10:15,970 --> 00:10:19,890
现在是Mac OS X 这是一种很成熟的API

195
00:10:19,910 --> 00:10:25,350
它是经过深思熟虑的 如果你能顺着它来

196
00:10:25,360 --> 00:10:28,500
你会发现创建强大的程序是很容易的

197
00:10:28,500 --> 00:10:30,500
这就是这其中的内容

198
00:10:30,500 --> 00:10:33,350
下面再来看作为程序员 作为开发者

199
00:10:33,360 --> 00:10:36,190
我们需要什么工具来创建app

200
00:10:36,190 --> 00:10:38,500
我把这些分成了四段

201
00:10:38,500 --> 00:10:42,500
一是实际编程用的工具

202
00:10:42,500 --> 00:10:47,860
这个平台很好的地方在于 它是一个工具满足所有用途

203
00:10:47,870 --> 00:10:49,980
只有一个工具 XCode 5

204
00:10:50,000 --> 00:10:51,500
一切都在这里面

205
00:10:51,500 --> 00:10:53,500
调试器在这里 源代码编辑

206
00:10:53,500 --> 00:10:57,850
源代码控制 UI构建 一切都在这个工具里

207
00:10:57,870 --> 00:11:00,500
然后还有一个辅助的Instruments

208
00:11:00,500 --> 00:11:05,500
用于app代码分析 内存管理等等

209
00:11:05,500 --> 00:11:08,610
不过这些都包含在XCode 5中

210
00:11:08,610 --> 00:11:10,500
这很棒 因为 要知道

211
00:11:10,500 --> 00:11:13,390
调试时 你一般是在同时编辑代码

212
00:11:13,390 --> 00:11:14,500
来来回回

213
00:11:14,500 --> 00:11:17,260
如果要在不同程序中来回切换 就会很烦人

214
00:11:17,260 --> 00:11:20,630
这个工具对屏幕空间的分配也做得很好

215
00:11:20,630 --> 00:11:23,840
所有不同任务很好地被分配到不同屏幕空间中

216
00:11:23,850 --> 00:11:25,980
这是首要工具XCode 5

217
00:11:25,980 --> 00:11:30,500
这堂课后 你们都应该到Mac App商店

218
00:11:30,500 --> 00:11:34,040
不是iOS设备商店 而是Mac上的Mac App商店

219
00:11:34,040 --> 00:11:38,150
下载这个 它是免费的 上周五刚出

220
00:11:38,150 --> 00:11:42,020
你们可以下载安装 然后开始倒弄

221
00:11:42,040 --> 00:11:45,170
有些人可能在CS106这样的课上用过XCode

222
00:11:45,190 --> 00:11:47,500
多少人用过XCode 举手我看看

223
00:11:47,500 --> 00:11:50,500
好 2/3或更多 大约3/4的人用过

224
00:11:50,500 --> 00:11:53,500
你们会很习惯它 你们将会把XCode

225
00:11:53,500 --> 00:11:55,500
用于iOS应用

226
00:11:55,500 --> 00:11:58,500
有一个新语言需要你们学 Objective-C

227
00:11:58,500 --> 00:12:00,500
这个语言样子有点滑稽

228
00:12:00,500 --> 00:12:04,500
它使用方括号和冒号 消息调用没有圆括号

229
00:12:04,500 --> 00:12:08,960
熟悉Jave或C++的人会觉得这有些奇怪

230
00:12:08,960 --> 00:12:11,500
参数不是放在圆括号里

231
00:12:11,500 --> 00:12:13,500
我将详细讲解Objective-C

232
00:12:13,500 --> 00:12:16,080
我不指望你们对它有任何了解

233
00:12:16,090 --> 00:12:19,960
你们应该都很熟悉Java和C++ 这是CS106A和B的内容

234
00:12:19,960 --> 00:12:23,390
那么Objective-C将不会有太大难度

235
00:12:23,390 --> 00:12:24,720
它有一点不同

236
00:12:24,720 --> 00:12:27,500
例如 它比Java更快更宽松

237
00:12:27,500 --> 00:12:30,890
比C++更简单 更优美

238
00:12:30,910 --> 00:12:32,630
当涉及到面向对象的东西时

239
00:12:32,630 --> 00:12:34,720
我想 你们会喜欢它的

240
00:12:34,740 --> 00:12:39,090
有些人可能很喜欢正确编程这类概念

241
00:12:39,090 --> 00:12:42,280
喜欢Java 觉得Objective-C太过宽松

242
00:12:42,280 --> 00:12:44,500
不过 你应该能够克服

243
00:12:44,500 --> 00:12:45,740
框架

244
00:12:45,740 --> 00:12:50,500
显然 任何像这样的大系统一般都会将对象组到库中

245
00:12:50,500 --> 00:12:53,170
iOS中我们称之为框架

246
00:12:53,190 --> 00:12:56,500
iOS中有数十个这样的框架

247
00:12:56,500 --> 00:12:59,240
课程最开始我们要讲两个主要框架

248
00:12:59,240 --> 00:13:02,440
一是Foundation框架 所有核心服务都在这里

249
00:13:02,450 --> 00:13:04,500
例如数字和字典 所有这些

250
00:13:04,500 --> 00:13:05,740
然后是UIKit

251
00:13:05,740 --> 00:13:08,060
按钮 滑动条这些东西就在这里

252
00:13:08,060 --> 00:13:10,500
这是两个主要框架 不过还有很多 例如

253
00:13:10,500 --> 00:13:12,500
看到这里写的Core Data了吗

254
00:13:12,500 --> 00:13:14,500
这是面向对象的数据库

255
00:13:14,500 --> 00:13:16,500
我们会谈到这个

256
00:13:16,500 --> 00:13:19,500
Core Motion 这是陀螺仪和加速计

257
00:13:19,500 --> 00:13:21,500
Map Kit 显然是地图

258
00:13:21,500 --> 00:13:23,500
还有很多其它的

259
00:13:23,500 --> 00:13:25,500
我们会尽可能多地讲到这些

260
00:13:25,500 --> 00:13:28,500
显然我们只有10周 但我会尽可能地多讲

261
00:13:28,500 --> 00:13:31,930
该平台中开发应用的最后一部分

262
00:13:31,930 --> 00:13:34,500
是一种叫作MVC的设计策略

263
00:13:35,110 --> 00:13:38,890
这并非iOS所独有的 其它平台也有使用MVC

264
00:13:38,910 --> 00:13:40,370
模型 视图 控制器

265
00:13:40,370 --> 00:13:42,500
作为基本设计策略

266
00:13:42,500 --> 00:13:46,500
在座有多少人曾使用过MVC

267
00:13:46,500 --> 00:13:48,850
大约有一半 你们知道这是什么

268
00:13:48,870 --> 00:13:52,070
我会为不了解的同学简单讲一遍MVC

269
00:13:52,070 --> 00:13:53,500
我会讲得很快

270
00:13:53,500 --> 00:13:56,720
因为有一半的人都用过它

271
00:13:56,720 --> 00:14:01,500
对于已经知道MVC是什么的人 这里我讲MVC

272
00:14:01,500 --> 00:14:03,960
是为了让你们了解我怎么讲到这些

273
00:14:03,960 --> 00:14:06,500
从而当我在iOS语境下讲到它时

274
00:14:06,500 --> 00:14:10,110
比如我讲你的模型是独立于UI的

275
00:14:10,110 --> 00:14:13,500
你们知道我在讲什么

276
00:14:13,500 --> 00:14:18,500
这里是为了让我们所有人在术语层面达成共识

277
00:14:18,500 --> 00:14:21,590
MVC 模型 视图 控制器

278
00:14:21,590 --> 00:14:28,500
也就是一种将应用中所有类组织起来的策略

279
00:14:28,500 --> 00:14:34,500
这里我们会将所有类归到三块中

280
00:14:34,500 --> 00:14:38,500
一块是模型 一块是控制器 一块是视图

281
00:14:38,500 --> 00:14:41,500
那你怎么知道哪个类属于哪一块呢

282
00:14:41,500 --> 00:14:46,500
模型实际上考虑的是"什么"的问题 程序是什么

283
00:14:46,500 --> 00:14:50,310
讲MVC时 我将讲到我们的第一个应用

284
00:14:50,310 --> 00:14:52,500
也就是一个纸牌匹配游戏

285
00:14:52,500 --> 00:14:54,160
我们将创建这个游戏

286
00:14:54,170 --> 00:14:56,500
它会在屏幕上给出一些纸牌

287
00:14:56,500 --> 00:14:58,780
比如梅花A这些

288
00:14:58,780 --> 00:15:01,500
你需要选择一些纸牌

289
00:15:01,500 --> 00:15:03,500
匹配上的话就能得分

290
00:15:03,500 --> 00:15:05,910
如花色匹配或大小匹配这些

291
00:15:05,910 --> 00:15:08,870
或多或少 反正匹配上你就会得分

292
00:15:08,870 --> 00:15:11,280
在这样的纸牌匹配小游戏中

293
00:15:11,280 --> 00:15:16,390
纸牌 牌堆 甚至游戏玩法的逻辑

294
00:15:16,390 --> 00:15:20,500
都是独立于UI且在模型中的

295
00:15:21,500 --> 00:15:25,500
纸牌如何抽取到屏幕上是控制器的工作

296
00:15:25,500 --> 00:15:28,500
控制器的任务是弄清如何

297
00:15:28,500 --> 00:15:31,500
将这些牌显示在屏幕上

298
00:15:31,500 --> 00:15:35,500
然后将其运动用动画形式展现出来 等等

299
00:15:35,500 --> 00:15:36,780
这是控制器的工作

300
00:15:36,790 --> 00:15:41,500
控制器控制模型如何呈现在屏幕上

301
00:15:41,500 --> 00:15:44,050
而视图则是"仆从"

302
00:15:44,050 --> 00:15:46,310
是控制器要使用的类

303
00:15:46,310 --> 00:15:48,500
就像是林肯积木一样

304
00:15:48,500 --> 00:15:51,500
这种积木对于你们而言可能已经有点过时了

305
00:15:51,500 --> 00:15:56,070
视图中的东西 会被用于构建UI

306
00:15:56,070 --> 00:15:59,500
视图中的东西非常通用

307
00:15:59,500 --> 00:16:01,220
通用UI元素

308
00:16:01,220 --> 00:16:04,500
而控制器中的东西非常特定地用于UI的工作

309
00:16:04,500 --> 00:16:08,500
而模型中的东西完全独立于UI的工作

310
00:16:10,290 --> 00:16:15,500
把MVC弄对需要知道事物怎么运行

311
00:16:15,500 --> 00:16:19,030
还需要知道这三块之间如何通信

312
00:16:19,040 --> 00:16:22,480
我将概述这三者之间的通信方式

313
00:16:22,480 --> 00:16:25,610
这里我用了一些道路标识 我画了双黄线

314
00:16:25,610 --> 00:16:29,260
还有白色虚线 就像你开车时看到的一样

315
00:16:29,260 --> 00:16:34,200
我打算这样来表示通信发生的方式

316
00:16:34,200 --> 00:16:36,550
哪里允许 哪里不允许

317
00:16:36,550 --> 00:16:39,960
首先来看控制器同模型的通信

318
00:16:39,980 --> 00:16:44,500
从道路这一侧到模型这一侧是白色虚线

319
00:16:44,500 --> 00:16:46,500
也就是说 你可以直接通过

320
00:16:46,500 --> 00:16:49,500
也许过马路之前要先左右看看 但是能过

321
00:16:49,500 --> 00:16:52,770
控制器需要知道模型的一切

322
00:16:52,780 --> 00:16:56,500
还需要有同模型完全通信的能力

323
00:16:56,500 --> 00:16:58,960
按照任何方式使用其公共API

324
00:16:58,980 --> 00:17:00,740
因为控制器的工作

325
00:17:00,740 --> 00:17:05,110
就是将模型呈现给用户 使用视图作为其仆从

326
00:17:05,110 --> 00:17:06,500
它需要能够这样访问

327
00:17:06,500 --> 00:17:10,790
控制器需要能够完全 不受限地访问模型

328
00:17:10,810 --> 00:17:15,500
这是从控制器到模型的单向箭头

329
00:17:15,500 --> 00:17:20,500
类似地 从控制器到视图 通信也是不受限的

330
00:17:20,500 --> 00:17:24,370
因为控制器需要随意使唤自己的仆从

331
00:17:24,370 --> 00:17:29,090
视图是控制器的仆从 来布局用户界面这些

332
00:17:29,110 --> 00:17:31,250
控制器可以做任何事情

333
00:17:31,260 --> 00:17:33,500
这里我用绿色写了一个词 outlet(出口)

334
00:17:33,500 --> 00:17:37,940
因为当我们有这样一个属性 从控制器指向视图时

335
00:17:37,940 --> 00:17:39,500
我们将它称作outlet

336
00:17:39,500 --> 00:17:41,740
这还会在周三的demo中出现

337
00:17:41,760 --> 00:17:45,240
我会说 让我们创建一个从控制器到视图的outlet

338
00:17:45,240 --> 00:17:47,500
这样控制器就能同视图通信

339
00:17:48,640 --> 00:17:50,960
从模型到视图的通信呢

340
00:17:50,960 --> 00:17:53,070
从不 为什么

341
00:17:53,090 --> 00:17:56,920
100%明显 模型完全是独立于UI的

342
00:17:56,940 --> 00:18:01,500
它绝对不能同视图这一块中的对象进行沟通

343
00:18:01,500 --> 00:18:04,830
因为视图对象本质上是UI对象 它们是通用的

344
00:18:04,830 --> 00:18:06,980
但它们仍然是UI对象

345
00:18:07,000 --> 00:18:09,500
类似地 由于视图对象是通用的

346
00:18:09,500 --> 00:18:11,500
它们无法同任何特定模型通信

347
00:18:11,500 --> 00:18:15,500
它们需要控制器来为它们解释模型

348
00:18:15,500 --> 00:18:19,500
这里没有任何通信发生 所以我用双黄线

349
00:18:19,500 --> 00:18:23,500
所以箭头是红色的 所以这里用着火表示

350
00:18:23,500 --> 00:18:26,500
绝对不能越过这条线

351
00:18:27,660 --> 00:18:29,980
视图往回同控制器通信呢

352
00:18:29,980 --> 00:18:32,270
这里有一些通用视图对象 如按钮

353
00:18:32,270 --> 00:18:34,030
它们能同控制器通信吗

354
00:18:34,070 --> 00:18:38,830
确实 它们能 但这里要小心

355
00:18:38,830 --> 00:18:41,110
因为视图对象是通用的

356
00:18:41,110 --> 00:18:44,500
所以它们不能对控制器知道得太多

357
00:18:44,500 --> 00:18:47,610
它们只能以一种"盲"的方式同控制器通信

358
00:18:47,610 --> 00:18:50,680
它们不知道通信对方的类

359
00:18:50,680 --> 00:18:52,500
而且这里需要一种结构化方式

360
00:18:52,500 --> 00:18:56,070
也就是说 我们都同意能够这样通信

361
00:18:56,070 --> 00:18:59,160
视图和控制器之间的结构化通信有哪些例子呢

362
00:18:59,160 --> 00:19:01,140
一种叫作目标动作

363
00:19:01,180 --> 00:19:04,140
控制器在自身身上设置一个目标

364
00:19:04,140 --> 00:19:08,500
它会提供一个动作 就像一支箭一样

365
00:19:08,500 --> 00:19:11,350
给到视图 对视图说

366
00:19:11,350 --> 00:19:14,480
当你要做什么时 例如你是按钮 有人按了你

367
00:19:14,480 --> 00:19:18,500
或你是滑动条 有人动了你 发送这个动作给我

368
00:19:18,500 --> 00:19:22,500
通过这种方式 通用的按钮或滑动条

369
00:19:22,500 --> 00:19:26,100
就能往回同控制器通信 它不知道这是纸牌游戏控制器

370
00:19:26,110 --> 00:19:29,500
还是空间游戏控制器 它不知道这是什么样的控制器

371
00:19:29,500 --> 00:19:32,160
它只知道自身发生什么之后

372
00:19:32,180 --> 00:19:33,500
将消息发给目标

373
00:19:33,500 --> 00:19:37,500
这是一种盲的 简单的 结构化的方式 让视图

374
00:19:37,500 --> 00:19:40,180
能够同控制器通信

375
00:19:40,180 --> 00:19:42,500
还有更复杂的方式吗

376
00:19:42,500 --> 00:19:47,420
有时 视图中发生的情况会更复杂一些

377
00:19:47,420 --> 00:19:50,100
而控制器需要知道发生了什么

378
00:19:50,110 --> 00:19:52,230
同步获知发生了什么

379
00:19:52,240 --> 00:19:57,660
一种考虑方法就是我这里写的几个单词 将要 应该 已经

380
00:19:57,660 --> 00:20:01,680
以滚动视图为例

381
00:20:01,680 --> 00:20:05,500
我在滚动 我想要控制器

382
00:20:05,500 --> 00:20:09,500
知道用户刚才"已经"滚动过

383
00:20:09,500 --> 00:20:12,730
或者用户刚按到这里准备滚动

384
00:20:12,740 --> 00:20:16,500
我要让控制器知道用户"将要"滚动

385
00:20:16,500 --> 00:20:19,500
或者当用户触碰到后 滚动视图想知道

386
00:20:19,500 --> 00:20:23,500
我"应该"允许滚动吗 这是允许的吗

387
00:20:23,500 --> 00:20:25,420
所有这些问题

388
00:20:25,420 --> 00:20:29,500
滚动视图自身都没有足够的逻辑去知道答案

389
00:20:29,500 --> 00:20:36,210
于是它会将回答这些问题的权力委托给其它对象

390
00:20:36,220 --> 00:20:38,200
它不知道这一对象的类

391
00:20:38,200 --> 00:20:40,730
它只知道这种对象能够回答这些问题

392
00:20:40,730 --> 00:20:43,210
将要 应该 已经做这个或那个

393
00:20:43,220 --> 00:20:48,140
例如应该允许滚动 已经滚动过 诸如此类

394
00:20:48,140 --> 00:20:52,250
这些就是这类委托协议中你们会看到的方法

395
00:20:52,250 --> 00:20:55,900
我知道CS106A和B课程没有讲授协议

396
00:20:55,900 --> 00:20:59,500
多少人知道面向对象编程中协议表示什么

397
00:20:59,500 --> 00:21:02,500
很少有人 那我就来讲了

398
00:21:02,500 --> 00:21:05,500
协议是一种同另一对象通信的盲方式

399
00:21:05,500 --> 00:21:08,500
我给你讲时 你可能会想 哦 对 我知道这个

400
00:21:08,500 --> 00:21:10,500
我们不叫它协议 等等

401
00:21:10,500 --> 00:21:15,500
不过 这就是我们进行委托的方式 这种盲的通信

402
00:21:15,500 --> 00:21:18,500
另外还有一点很重要

403
00:21:18,500 --> 00:21:22,900
视图不应该"拥有"它们所显示的数据

404
00:21:22,900 --> 00:21:25,940
也就是说 数据不应该是它们内部的属性

405
00:21:25,940 --> 00:21:28,250
数据是数据

406
00:21:28,250 --> 00:21:30,700
最简单的例子是

407
00:21:30,700 --> 00:21:34,290
iPod iPhone或iPad中的所有歌曲

408
00:21:34,290 --> 00:21:37,050
你可能有一万首歌

409
00:21:37,050 --> 00:21:40,500
如果你有某种通用的列表视图在视图中

410
00:21:40,500 --> 00:21:44,990
你不能将一万首歌转给它的实例变量

411
00:21:44,990 --> 00:21:48,500
指望它能容纳一万首歌 然后逐个列出

412
00:21:48,500 --> 00:21:50,400
一 这很低效

413
00:21:50,400 --> 00:21:54,290
二 这一万首歌属于哪里

414
00:21:54,700 --> 00:21:55,880
在模型里

415
00:21:55,900 --> 00:21:58,500
因为音乐数据库是一个模型

416
00:21:58,500 --> 00:22:02,140
它无关于UI 只是一个歌曲 艺术家 专辑列表

417
00:22:02,140 --> 00:22:03,310
这在模型中

418
00:22:03,310 --> 00:22:05,500
某控制器需要访问这个数据库

419
00:22:05,500 --> 00:22:09,770
告诉视图如何显示这些歌曲

420
00:22:09,770 --> 00:22:13,050
我们需要这种通信在这里发生

421
00:22:13,070 --> 00:22:15,500
而视图要呈现某种列表

422
00:22:15,500 --> 00:22:18,500
你触控屏幕 轻按打开列表

423
00:22:18,500 --> 00:22:20,160
试图看到更多歌曲

424
00:22:20,160 --> 00:22:23,050
这种互动如何进行 答案是

425
00:22:23,070 --> 00:22:25,500
我们另一种特殊的委托

426
00:22:25,500 --> 00:22:27,500
我们称之为数据源

427
00:22:27,500 --> 00:22:30,500
数据源不会考虑将要 已经 应该

428
00:22:30,500 --> 00:22:32,500
它会要求计数这些

429
00:22:32,500 --> 00:22:34,500
例如有多少歌曲

430
00:22:34,500 --> 00:22:37,500
控制器去模型中看 一万

431
00:22:37,500 --> 00:22:39,500
回给视图 有一万首

432
00:22:39,500 --> 00:22:42,860
视图会在内部预留一万个事物的空间

433
00:22:42,860 --> 00:22:43,950
它不知道具体是什么

434
00:22:43,970 --> 00:22:46,500
将滚动条指示器移动一些

435
00:22:46,500 --> 00:22:48,010
这样你就知道在哪

436
00:22:48,010 --> 00:22:50,290
然后你开始滚动翻阅

437
00:22:50,290 --> 00:22:52,080
然后它开始向控制器发送消息

438
00:22:52,080 --> 00:22:57,510
例如 给我第150行处的数据 后面10个项目

439
00:22:57,530 --> 00:22:59,560
明白吗 然后你继续往下 它会要求

440
00:22:59,570 --> 00:23:02,010
250行处的后面10个项目

441
00:23:02,010 --> 00:23:05,340
控制器会回到模型 要求更多数据

442
00:23:05,340 --> 00:23:07,880
它会以这种盲的方式提供给视图

443
00:23:07,900 --> 00:23:12,030
这就是视图通过控制器从模型获取数据的方式

444
00:23:12,030 --> 00:23:14,470
这是一种盲的结构化方式

445
00:23:14,490 --> 00:23:16,920
大家都明白了吗

446
00:23:16,940 --> 00:23:18,970
数据源其实是一种委托

447
00:23:18,970 --> 00:23:20,880
它是一类用于获取数据的特殊委托

448
00:23:20,880 --> 00:23:24,950
你们会看到 iOS中有一些类具有数据源

449
00:23:24,950 --> 00:23:27,160
它们通常也还有委托

450
00:23:27,180 --> 00:23:29,680
iOS中大多数精密的类中都有委托

451
00:23:29,680 --> 00:23:31,500
将要 已经 应该这类东西

452
00:23:31,500 --> 00:23:33,800
有些类中还有数据源

453
00:23:33,810 --> 00:23:36,730
取决于它们是不是要展示出数据

454
00:23:36,750 --> 00:23:38,770
简单数据 比如某个视图

455
00:23:38,770 --> 00:23:42,500
我在纸牌游戏中创建了一个视图叫PlayingCard

456
00:23:42,500 --> 00:23:44,790
它只有花色和大小

457
00:23:44,790 --> 00:23:47,860
我们不会对花色和大小进行数据计数

458
00:23:47,860 --> 00:23:49,500
我们会把它们设为属性

459
00:23:49,500 --> 00:23:52,790
视图中会设置有这些数据

460
00:23:52,790 --> 00:23:55,060
但它并不"拥有"它

461
00:23:55,080 --> 00:23:57,500
模型仍然拥有花色和大小

462
00:23:57,500 --> 00:24:00,500
视图只获得数据来进行显示

463
00:24:00,500 --> 00:24:06,500
简单数据可以转给视图 但这只是给视图来显示

464
00:24:06,500 --> 00:24:12,170
好 所有这些说的是 控制器的工作是为视图

465
00:24:12,180 --> 00:24:16,140
解释并格式化提供模型数据

466
00:24:16,140 --> 00:24:17,500
这是控制器的工作

467
00:24:17,500 --> 00:24:20,500
我们讲demo时 我会提醒你们注意

468
00:24:20,500 --> 00:24:22,500
我写这些代码

469
00:24:22,500 --> 00:24:25,120
是为了让控制器执行它的工作

470
00:24:25,120 --> 00:24:28,990
也就是将模型数据用到视图中

471
00:24:28,990 --> 00:24:30,500
然后显示到屏幕上

472
00:24:30,500 --> 00:24:32,250
这就是控制器的作用

473
00:24:32,250 --> 00:24:36,500
那从模型到控制器的通信呢

474
00:24:36,500 --> 00:24:41,160
还是一样 这显然也是不允许的 因为模型对UI一无所知

475
00:24:41,170 --> 00:24:44,230
所以它不能同控制器这样的UI对象进行通信

476
00:24:44,230 --> 00:24:46,500
但有时 模型中的事物会发生变化

477
00:24:46,500 --> 00:24:48,080
控制器需要知道它

478
00:24:48,100 --> 00:24:52,500
例如数据变化 数据库变化 或者模型是某种网络数据库

479
00:24:52,500 --> 00:24:54,770
某人改变了网络上的东西 造成它变化

480
00:24:54,790 --> 00:24:56,500
控制器需要知道这些

481
00:24:56,500 --> 00:24:59,500
这种通信如何做到呢

482
00:24:59,500 --> 00:25:03,500
这可以通过一种电台的概念来理解

483
00:25:03,500 --> 00:25:06,500
这可以通过一种电台的概念来理解

484
00:25:06,500 --> 00:25:12,500
模型会使用这一概念来广播信息

485
00:25:12,500 --> 00:25:14,500
给任何感兴趣的人

486
00:25:14,500 --> 00:25:18,770
iOS中执行这一功能的叫作通知

487
00:25:18,770 --> 00:25:21,860
和键值观察 键值观察简称KVO

488
00:25:21,860 --> 00:25:24,500
模型可以说 哦

489
00:25:24,500 --> 00:25:28,500
模型中任何东西发生变化 我会通过我的电台进行广播

490
00:25:28,500 --> 00:25:32,500
然后控制器会接收来自电台的信息

491
00:25:32,500 --> 00:25:35,500
它会发现事物正在变化 发现事物变化时

492
00:25:35,500 --> 00:25:39,500
它会通过它的绿箭头同模型通信

493
00:25:39,500 --> 00:25:42,500
让模型把变化了的数据给它

494
00:25:42,500 --> 00:25:44,300
能理解吗

495
00:25:44,300 --> 00:25:45,500
学期最后

496
00:25:45,500 --> 00:25:48,710
我们将会看到 例如通知如何知道

497
00:25:48,710 --> 00:25:50,840
数据库中的数据变化了

498
00:25:50,860 --> 00:25:53,500
我们获得通知 UI然后

499
00:25:53,500 --> 00:25:58,500
控制器然后能够到模型去获取信息

500
00:25:58,500 --> 00:26:01,500
有人问 视图能否接收电台信号

501
00:26:01,500 --> 00:26:04,500
它们也许能 但你最好不要这样做

502
00:26:04,500 --> 00:26:07,500
这可能会违反MVC

503
00:26:07,500 --> 00:26:13,560
好 我们这样做 我们有这些很好的通信和规则

504
00:26:13,560 --> 00:26:17,380
我们可以设想使用这个创建一些简单的程序

505
00:26:17,380 --> 00:26:19,860
但如果我们想创建更大更复杂的app呢

506
00:26:19,880 --> 00:26:23,230
在iPhone或iPad上具有多屏幕的app

507
00:26:23,230 --> 00:26:26,500
例如屏幕上有三四个不同区域

508
00:26:26,500 --> 00:26:28,970
在发生着事情 如何做到呢

509
00:26:28,990 --> 00:26:33,500
我们会合并多个MVC

510
00:26:33,500 --> 00:26:40,500
因为MVC能够将另一MVC作为其视图的一部分

511
00:26:40,500 --> 00:26:44,500
所以 一整个MVC

512
00:26:44,500 --> 00:26:49,600
可以作为另一个较大MVC的仆从

513
00:26:49,620 --> 00:26:53,150
这样可以一直往下串联

514
00:26:53,150 --> 00:26:55,890
你就能创建越来越复杂的应用

515
00:26:55,910 --> 00:27:01,150
例如 你可以有一个日历app

516
00:27:01,150 --> 00:27:03,540
它会显示出一整年

517
00:27:03,540 --> 00:27:06,190
你点击月 这时就会显示出月视图

518
00:27:06,190 --> 00:27:08,500
月视图会非常不同于年视图

519
00:27:08,500 --> 00:27:11,500
月视图上有日期和一些圈

520
00:27:11,500 --> 00:27:13,230
告诉你哪天有预约

521
00:27:13,250 --> 00:27:16,500
然后点击日期 你会得到日视图

522
00:27:16,500 --> 00:27:20,000
日视图会显示给你不同时间的预约

523
00:27:20,010 --> 00:27:22,500
点击某一预约 你会进入预约视图

524
00:27:22,500 --> 00:27:25,500
它会显示给你具体细节 包括时间地点这些

525
00:27:25,500 --> 00:27:29,020
所有这些视图 年视图 月视图

526
00:27:29,020 --> 00:27:33,500
日视图 预约视图都是自身的MVC

527
00:27:33,500 --> 00:27:38,320
但是你可以看到 后三个视图被用作

528
00:27:38,320 --> 00:27:44,500
顶级视图 即年视图的仆从 用以显示更多细节

529
00:27:44,500 --> 00:27:46,500
年视图 你点击一个月

530
00:27:46,500 --> 00:27:51,020
它会使用一个月视图MVC来显示更多细节

531
00:27:51,040 --> 00:27:53,500
这是年视图的一部分

532
00:27:53,500 --> 00:27:57,500
iOS中这还被用于标签栏控制器

533
00:27:57,500 --> 00:28:01,520
标签栏列在下方 有四五个可以选

534
00:28:01,520 --> 00:28:03,500
上方有一些MVC

535
00:28:03,500 --> 00:28:06,500
它有四个指针指向四个仆从

536
00:28:06,500 --> 00:28:11,060
也就是四个出现在标签栏中的MVC

537
00:28:11,060 --> 00:28:14,190
我们在作业二或三中可能会做这个

538
00:28:14,190 --> 00:28:18,500
我们会制作标签栏 你们需要使用多MVC

539
00:28:18,500 --> 00:28:23,500
这就得到了一个大致是这样的图像

540
00:28:23,500 --> 00:28:26,500
这里有一个MVC 看到together下的紫色那个了吗

541
00:28:26,500 --> 00:28:29,240
这里有一个MVC 看到together下的紫色那个了吗

542
00:28:29,250 --> 00:28:34,500
它从视图指向三个其它MVC

543
00:28:34,500 --> 00:28:37,500
这就是我们创建标签栏控制器的方式

544
00:28:37,500 --> 00:28:39,500
这些可能就是三个标签

545
00:28:39,500 --> 00:28:43,820
每一个都是自己的MVC 完全独立运行

546
00:28:43,840 --> 00:28:48,130
这时它就是一个类似于通用 可重用视图的东西

547
00:28:48,130 --> 00:28:50,500
它甚至不知道它在标签栏中

548
00:28:50,500 --> 00:28:53,100
它只知道要做自己该做的事

549
00:28:53,100 --> 00:28:54,820
这方面来看 它是模块化的

550
00:28:54,820 --> 00:28:58,500
可以看到 这里不再有其它箭头

551
00:28:58,500 --> 00:29:01,120
除了一些模型

552
00:29:01,130 --> 00:29:03,500
某些模型之间在相互通信

553
00:29:03,500 --> 00:29:07,110
要知道 一个大的应用也许会有一单个共享的模型

554
00:29:07,120 --> 00:29:13,690
或者 模型会被划分开来给子MVC使用

555
00:29:13,710 --> 00:29:16,150
但这里就只有这种通信了

556
00:29:16,150 --> 00:29:20,170
其它通信要么是我们看过的MVC中的结构化通信

557
00:29:20,170 --> 00:29:24,500
要么是将MVC用作另一个MVC视图的一部分

558
00:29:24,500 --> 00:29:27,500
关于这个有问题吗

559
00:29:27,500 --> 00:29:31,840
当然 我们显然不希望设计像这样乱糟糟

560
00:29:31,840 --> 00:29:35,040
所有人都在相互通信 我们不知道谁和什么在通信

561
00:29:35,040 --> 00:29:38,500
这无疑让程序调试变得很难 而且这无法规模化

562
00:29:38,500 --> 00:29:40,500
你无法像这样创建出大程序

563
00:29:40,500 --> 00:29:44,500
这样做的话 你永远无法弄清什么地方容易崩溃掉

564
00:29:44,500 --> 00:29:48,500
所以 我们肯定不要这样做

565
00:29:50,210 --> 00:29:53,500
这是MVC 关于这方面有问题吗

566
00:29:53,500 --> 00:29:55,730
好 再看Objective-C

567
00:29:55,740 --> 00:29:59,320
Objective-C是C的严格父集

568
00:29:59,320 --> 00:30:02,500
C中能做的事 Objective-C中都能做

569
00:30:02,500 --> 00:30:05,500
这门课中我们会做很多C方面的事情

570
00:30:05,500 --> 00:30:10,500
我们也会做很多面向对象的东西 但C也会经常用到

571
00:30:10,500 --> 00:30:14,500
但这里显然有些东西你们需要改变思考方式

572
00:30:14,500 --> 00:30:17,980
毕竟这里有面向对象性加入到一个语言中

573
00:30:17,980 --> 00:30:20,130
今天我会讲到其中一点

574
00:30:20,150 --> 00:30:24,500
除了我会展示的一些语法外

575
00:30:24,500 --> 00:30:26,390
我会谈到Objective-C中不同于

576
00:30:26,390 --> 00:30:29,320
我会谈到Objective-C中不同于

577
00:30:29,320 --> 00:30:33,110
C++或Java的内容 也就是属性

578
00:30:33,110 --> 00:30:36,260
这些我就不读了 我会展示给你们

579
00:30:36,260 --> 00:30:40,500
属性是我们访问实例变量的方式

580
00:30:40,500 --> 00:30:45,300
大家都懂吗 知道实例变量的请举手

581
00:30:45,300 --> 00:30:47,170
很好 基本上所有人都懂

582
00:30:47,170 --> 00:30:52,500
我们希望访问对象的实例数据

583
00:30:52,500 --> 00:30:56,500
通常 在Java或C++中 你只需要

584
00:30:56,500 --> 00:31:00,500
有一些访问它们的语法 然后访问它们

585
00:31:00,500 --> 00:31:02,500
在Objective-C中 我们不这样做

586
00:31:02,500 --> 00:31:05,220
Objective-C 我们有所谓的属性

587
00:31:05,240 --> 00:31:09,500
属性实际上是一个setter方法和一个getter方法

588
00:31:09,500 --> 00:31:12,500
所有对实例变量的访问都是如此

589
00:31:12,500 --> 00:31:15,500
通过setter方法设置值 通过getter方法获取值

590
00:31:15,500 --> 00:31:21,150
有些人可能很在意性能 会说 我的天

591
00:31:21,150 --> 00:31:24,240
竟然每一个实例变量都需要调用方法来设置或获取

592
00:31:24,240 --> 00:31:27,500
不过记住 这里是为用户界面系统创建的

593
00:31:27,500 --> 00:31:34,500
当用户触到屏幕 这么一点时间内

594
00:31:34,500 --> 00:31:38,500
就会执行上百万条指令

595
00:31:38,500 --> 00:31:41,950
多一点setter和getter方法根本不值得一提

596
00:31:41,960 --> 00:31:44,500
这仍然可行

597
00:31:44,500 --> 00:31:47,500
你不需要去优化没有必要优化的事物

598
00:31:47,500 --> 00:31:50,040
你要优化的是很花时间的东西

599
00:31:50,040 --> 00:31:53,110
而访问实例变量不会花太多时间

600
00:31:53,110 --> 00:31:56,130
我们来看看这是怎样的

601
00:31:56,130 --> 00:31:59,300
不要被这些语法所吓到

602
00:31:59,300 --> 00:32:02,500
这些都是新的 所以需要花点时间才能习惯

603
00:32:02,500 --> 00:32:05,670
在Objective-C中 每一个类是这样的

604
00:32:05,670 --> 00:32:10,500
我要展示的类实际上在我将创建的

605
00:32:10,500 --> 00:32:13,500
纸牌匹配游戏app的模型里

606
00:32:13,500 --> 00:32:16,500
我们会有一个Card类和一个Deck类

607
00:32:16,500 --> 00:32:19,130
我们还有一个Card的子类叫PlayingCard

608
00:32:19,130 --> 00:32:21,040
还有一个Deck的子类叫作PlayingCardDeck

609
00:32:21,040 --> 00:32:23,910
这是我们最开始的模型中的四个类

610
00:32:23,930 --> 00:32:28,610
今天的课上 我将只展示Card类

611
00:32:28,630 --> 00:32:30,350
周三我再展示Deck

612
00:32:30,350 --> 00:32:33,500
PlayingCardDeck和PlayingCard

613
00:32:33,500 --> 00:32:37,870
Objective-C中的每一个类都有一个头文件 如Card.h

614
00:32:37,890 --> 00:32:40,500
还有一个实现文件Card.m

615
00:32:40,500 --> 00:32:45,090
就像C++中你有.h和.c文件一样

616
00:32:45,090 --> 00:32:49,500
这里.m 我猜m表示的是实现 我不知道

617
00:32:49,500 --> 00:32:53,280
反正是m 这些是分开的

618
00:32:53,280 --> 00:32:58,040
不同之处在于Card.h是公共API

619
00:32:58,040 --> 00:33:03,020
这就是.h 它是公共API

620
00:33:03,020 --> 00:33:08,830
Card.m则是私有API 以及你所有的实现

621
00:33:08,830 --> 00:33:11,810
不要把.h和.m搞混

622
00:33:11,810 --> 00:33:14,960
.h是你的公共API 它就是这个

623
00:33:14,960 --> 00:33:21,040
它是类中你希望具有公共性质 让其他人能够调用的方法

624
00:33:21,040 --> 00:33:23,980
我们来看看语法是怎样的

625
00:33:23,980 --> 00:33:28,500
公共API中 你必须说明父类是谁

626
00:33:28,500 --> 00:33:33,500
你不能够将父类保密

627
00:33:33,500 --> 00:33:36,500
它需要是公共的 需要放到头文件中

628
00:33:36,500 --> 00:33:39,500
这里是使用的语法 我们使用@interface

629
00:33:39,500 --> 00:33:40,920
然后是类名

630
00:33:40,930 --> 00:33:43,500
这必须同文件名一样

631
00:33:43,500 --> 00:33:47,110
Card.h应该总是有Card类的接口

632
00:33:47,110 --> 00:33:49,500
然后冒号 后面是父类

633
00:33:49,500 --> 00:33:52,500
Card类的父类是NSObject

634
00:33:52,500 --> 00:33:57,110
NSObject在Foundation框架中

635
00:33:57,110 --> 00:34:01,540
它可以说是iOS中每一个类的根类

636
00:34:01,540 --> 00:34:03,500
包括你所写的所有类

637
00:34:03,500 --> 00:34:07,110
这是一种基本的类 我在Foundation中会讲到

638
00:34:07,110 --> 00:34:10,500
总之 它是每一个类的最终父类

639
00:34:10,500 --> 00:34:13,500
一切最终都是从NSObject继承

640
00:34:13,500 --> 00:34:17,500
在实现端 情况也很类似

641
00:34:17,500 --> 00:34:19,500
不过这里不说@interface

642
00:34:19,500 --> 00:34:22,500
而说@implementation 后跟类名

643
00:34:22,500 --> 00:34:25,500
这里不需要指定父类

644
00:34:25,500 --> 00:34:28,740
因为这只需要指定一次 而它是公共的

645
00:34:28,740 --> 00:34:30,500
所以是在头文件中

646
00:34:30,500 --> 00:34:34,500
注意到两者的底部都有@end

647
00:34:34,500 --> 00:34:38,500
这里表示的是接口或实现的结束

648
00:34:38,500 --> 00:34:43,890
所有公共API都在@interface和@end之间

649
00:34:43,890 --> 00:34:47,500
而所有私有实现都在

650
00:34:47,500 --> 00:34:49,920
@implementation和@end之间

651
00:34:49,940 --> 00:34:56,020
要指定父类 你需要导入

652
00:34:56,020 --> 00:34:58,370
这就像是#include一样

653
00:34:58,370 --> 00:35:00,330
不过它比#include要强大

654
00:35:00,330 --> 00:35:03,110
强大很多 等下我就会讲到

655
00:35:03,110 --> 00:35:04,500
你必须导入

656
00:35:04,500 --> 00:35:08,110
否则Objective-C编译器就不知道你的父类是什么

657
00:35:08,110 --> 00:35:10,240
所以你必须导入父类

658
00:35:10,240 --> 00:35:15,000
不过 通常对于iOS中的父类

659
00:35:15,020 --> 00:35:19,500
我们不会只导入类的头文件 这里是Foundation

660
00:35:19,500 --> 00:35:23,500
我们会导入整个框架

661
00:35:23,500 --> 00:35:26,500
你也许会说 这太低效了吧

662
00:35:26,500 --> 00:35:29,150
框架得有多大

663
00:35:29,160 --> 00:35:32,500
当然 这是已经经过预编译和优化的

664
00:35:32,500 --> 00:35:39,130
iOS7中 实际语法是@import Foundation

665
00:35:39,130 --> 00:35:44,500
这意味着我将使用Foundation框架中的所有公共类

666
00:35:44,500 --> 00:35:47,240
iOS7仍然支持原来的

667
00:35:47,240 --> 00:35:49,440
import Foundation/Foundation.h

668
00:35:49,440 --> 00:35:51,500
希望的话 你也可以用这个

669
00:35:51,500 --> 00:35:57,500
在实现文件中 我们显然需要导入头文件

670
00:35:57,500 --> 00:35:59,700
因为实现文件需要知道

671
00:35:59,700 --> 00:36:03,850
就API而言 我们使用的什么公共API

672
00:36:03,850 --> 00:36:07,050
我们需要把这个导入 很好理解

673
00:36:07,050 --> 00:36:11,500
我们还可以有私有声明

674
00:36:11,500 --> 00:36:16,500
声明私有的属性和方法

675
00:36:16,500 --> 00:36:20,130
在实现文件内 使用这种@interface

676
00:36:20,130 --> 00:36:23,500
类名 开闭圆括号

677
00:36:23,500 --> 00:36:25,200
@end结尾

678
00:36:25,220 --> 00:36:27,870
这里我们可以加入私有声明

679
00:36:27,890 --> 00:36:30,500
Objective-C并不要求你

680
00:36:30,500 --> 00:36:33,870
在实际使用之前进行声明

681
00:36:33,890 --> 00:36:35,290
知道我说的什么吗

682
00:36:35,310 --> 00:36:37,500
很多语言中

683
00:36:37,500 --> 00:36:40,500
在调用一个方法前 你需要声明这个函数

684
00:36:40,500 --> 00:36:42,500
但Objective-C中你可以颠倒过来

685
00:36:42,500 --> 00:36:45,000
例如你可以实现一个方法A 调用方法B

686
00:36:45,000 --> 00:36:47,500
例如你可以实现一个方法A 调用方法B

687
00:36:47,500 --> 00:36:50,500
然后方法B在文件后面某处才实现

688
00:36:50,500 --> 00:36:52,500
你不需要在前面声明方法B

689
00:36:52,500 --> 00:36:56,500
再去实现方法A 再实现方法B

690
00:36:56,500 --> 00:37:01,500
这种私有@interface主要被用于属性

691
00:37:01,500 --> 00:37:03,810
因为当我们声明属性时

692
00:37:03,810 --> 00:37:06,500
setter和getter会为我们写好

693
00:37:06,500 --> 00:37:10,500
我们来看看怎么声明属性

694
00:37:10,500 --> 00:37:13,500
这里是一个简单属性 叫作contents

695
00:37:13,500 --> 00:37:17,110
表示纸牌的内容 纸牌上印有什么

696
00:37:17,110 --> 00:37:19,500
可以是梅花A

697
00:37:19,500 --> 00:37:23,500
由于这是你们第一天上课

698
00:37:23,500 --> 00:37:26,500
我们会让内容非常简单 仅仅是一个字符串

699
00:37:26,500 --> 00:37:29,500
这些纸牌可能是抽认卡

700
00:37:29,500 --> 00:37:31,500
也许是用于学外语用的

701
00:37:31,500 --> 00:37:34,500
也许内容是你要学的单词

702
00:37:34,500 --> 00:37:36,500
也许它是图像抽认卡

703
00:37:36,500 --> 00:37:40,500
内容是图像的名字

704
00:37:40,500 --> 00:37:43,500
交给UI来显示匹配的图像

705
00:37:43,500 --> 00:37:45,500
在我们的纸牌游戏中

706
00:37:45,500 --> 00:37:48,140
我们的内容是字母A

707
00:37:48,140 --> 00:37:49,500
及梅花符号

708
00:37:49,500 --> 00:37:51,980
有一个Unicode字符表示梅花

709
00:37:51,980 --> 00:37:54,010
梅花A 这就是内容

710
00:37:54,050 --> 00:37:56,500
这是纸牌内容 纸牌上印有什么

711
00:37:56,500 --> 00:38:00,220
这里可以看到有NSString

712
00:38:00,220 --> 00:38:02,380
前面有@property

713
00:38:02,380 --> 00:38:06,490
这会声明每一个纸牌实例都需要空间

714
00:38:06,500 --> 00:38:10,500
换言之 每一张纸牌都有自己的内容contents

715
00:38:10,500 --> 00:38:13,010
这是一个字符串 所以我们说

716
00:38:13,010 --> 00:38:15,200
property NSString

717
00:38:15,200 --> 00:38:19,500
在Objective-C中理解这个很重要 所有对象

718
00:38:19,500 --> 00:38:23,500
都在堆中 我们有指针指向它们

719
00:38:23,500 --> 00:38:29,500
这里没有将对象放到栈上等等这样的情况

720
00:38:29,500 --> 00:38:32,500
它们都在堆中 大家知道什么是堆吗 有问题吗

721
00:38:32,500 --> 00:38:34,980
也就是分配闲置内存的地方

722
00:38:34,990 --> 00:38:36,500
所有对象都在那里

723
00:38:36,500 --> 00:38:38,940
Objective-C很酷的地方在于

724
00:38:38,960 --> 00:38:43,070
Objective-C会为你管理所有这些存储

725
00:38:43,090 --> 00:38:45,980
它会进行分配 也会进行释放

726
00:38:45,990 --> 00:38:49,500
它怎么知道何时释放呢

727
00:38:49,500 --> 00:38:51,500
答案就是这个strong

728
00:38:51,500 --> 00:38:54,500
看到strong了吗

729
00:38:54,500 --> 00:38:57,310
属性可以是强的 就像这个这样

730
00:38:57,310 --> 00:38:58,730
或者弱的

731
00:38:58,740 --> 00:39:00,500
就两种 强或弱

732
00:39:00,500 --> 00:39:03,050
所有指针属性要么强 要么弱

733
00:39:03,050 --> 00:39:06,290
因为Objective-C需要知道怎么处理内存和堆

734
00:39:06,310 --> 00:39:09,500
强表示保持对这个的存储

735
00:39:09,500 --> 00:39:13,180
在堆中 保持这个所指的东西

736
00:39:13,200 --> 00:39:18,160
只要我或其他任何人有一个强指针指向它

737
00:39:18,160 --> 00:39:20,500
这被叫作引用计数

738
00:39:20,500 --> 00:39:22,500
这不是垃圾收集 而是引用计数

739
00:39:22,500 --> 00:39:25,090
Objective-C会追踪

740
00:39:25,090 --> 00:39:28,440
每一个指向堆中对象的强指针

741
00:39:28,440 --> 00:39:31,590
只要有一个强指针存在

742
00:39:31,590 --> 00:39:33,220
它就会把其留在堆中

743
00:39:33,220 --> 00:39:35,500
只有不再存在任何强指针时

744
00:39:35,500 --> 00:39:37,860
它才会从堆中释放内存 立刻释放

745
00:39:37,880 --> 00:39:39,500
不是之后的垃圾收集

746
00:39:39,500 --> 00:39:43,140
而立刻释放内存

747
00:39:43,200 --> 00:39:45,500
这对你们而言可能是新东西

748
00:39:45,500 --> 00:39:48,500
你们可能习惯了Java中的垃圾收集

749
00:39:48,500 --> 00:39:52,500
或其它语言中的显式内存管理

750
00:39:52,500 --> 00:39:55,140
这个叫作自动引用计数 它非常棒

751
00:39:55,140 --> 00:39:58,500
可预见性很强 比垃圾收集要好很多

752
00:39:58,500 --> 00:40:01,500
因为垃圾收集器会在之后过来

753
00:40:01,500 --> 00:40:04,050
在从堆中收集垃圾时

754
00:40:04,050 --> 00:40:06,270
对应用性能会造成严重影响

755
00:40:06,270 --> 00:40:09,160
这个可预见性很强 你知道什么时候内存会释放

756
00:40:09,160 --> 00:40:11,500
也就是不再有强指针存在时

757
00:40:11,500 --> 00:40:13,270
如果是弱呢

758
00:40:13,270 --> 00:40:16,120
弱指针会告诉Objective-C

759
00:40:16,140 --> 00:40:18,500
我有一个指针指向堆中的这个

760
00:40:18,500 --> 00:40:22,290
只要还有强指针指向它 就将它留在内存中

761
00:40:22,290 --> 00:40:26,450
只要不再有强指针指向它 内存就会释放

762
00:40:26,460 --> 00:40:30,160
此时这个弱指针 会被设置为nil

763
00:40:30,160 --> 00:40:33,500
nil表示 这个指针不指向任何东西

764
00:40:33,500 --> 00:40:36,500
nil也就是零

765
00:40:36,500 --> 00:40:40,960
在其它语言中 你们可能会害怕nil指针

766
00:40:40,970 --> 00:40:45,500
因为引用nil指针会让你的程序崩溃

767
00:40:45,500 --> 00:40:49,500
在Objective-C中 你可以发送消息给nil指针

768
00:40:49,500 --> 00:40:51,580
这不会让你的程序崩溃掉

769
00:40:51,590 --> 00:40:55,920
实际上 如果你将消息发送给nil指针

770
00:40:55,920 --> 00:40:58,230
它显然不会执行任何代码

771
00:40:58,230 --> 00:41:00,500
因为这里没有实例

772
00:41:00,500 --> 00:41:02,320
而且它会返回0

773
00:41:02,330 --> 00:41:05,500
如果那个消息有返回值 它会返回0

774
00:41:05,500 --> 00:41:09,500
你需要小心返回struct类型的消息

775
00:41:09,500 --> 00:41:12,500
但只要它返回的是原始类型或指针

776
00:41:12,500 --> 00:41:13,990
它会返回0

777
00:41:14,010 --> 00:41:16,500
这需要时间才能习惯

778
00:41:16,500 --> 00:41:18,500
我们在编程过程中

779
00:41:18,500 --> 00:41:23,500
知道能发消息给nil指针 这是有好处的

780
00:41:23,500 --> 00:41:27,940
我们会利用这个让代码工作得更好

781
00:41:27,960 --> 00:41:30,160
这对于你们来说是个改变

782
00:41:30,160 --> 00:41:31,250
你们原来都习惯

783
00:41:31,250 --> 00:41:34,400
如果指针非nil 那么发送消息这些

784
00:41:34,400 --> 00:41:35,880
以此来防止崩溃

785
00:41:35,880 --> 00:41:39,500
Objective-C中不需要这样编写代码

786
00:41:39,500 --> 00:41:44,180
这个指针可以有值nil

787
00:41:44,180 --> 00:41:46,500
也就是说它不指向任何东西

788
00:41:46,500 --> 00:41:49,310
如果你有一个强指针 它指向什么东西

789
00:41:49,310 --> 00:41:50,730
然后你把它设为nil

790
00:41:50,750 --> 00:41:52,680
那个强指针不再指向那个东西

791
00:41:52,680 --> 00:41:54,140
只要没有其它指针指向它

792
00:41:54,140 --> 00:41:57,500
你就能够释放这里的内存 Objective-C会帮你释放内存

793
00:41:57,500 --> 00:41:59,500
或者 如果你有一个指针指向堆中某东西

794
00:41:59,500 --> 00:42:01,500
你让它指向堆中别的东西

795
00:42:01,500 --> 00:42:04,500
然后不再有强指针指向原来那个东西

796
00:42:04,500 --> 00:42:07,500
只要不再有强指针如此 内存就会释放

797
00:42:07,500 --> 00:42:10,500
记住 弱的情况 不仅是释放

798
00:42:10,500 --> 00:42:12,180
指针还会被设为nil

799
00:42:12,180 --> 00:42:13,860
因为你只想要一个弱指针

800
00:42:13,860 --> 00:42:16,500
你只希望有强指针指向对象时它才指向对象

801
00:42:16,500 --> 00:42:19,500
这就是强和弱

802
00:42:19,500 --> 00:42:24,120
括号里我们还要加一个nonatomic(非原子)

803
00:42:24,120 --> 00:42:29,530
非原子是说同该属性一同的setter和getter

804
00:42:29,530 --> 00:42:31,500
不是线程安全的

805
00:42:31,500 --> 00:42:36,140
你不能有两个线程 同时尝试设置该属性

806
00:42:36,140 --> 00:42:39,500
为什么这里要非原子呢 为什么不能是线程安全的呢

807
00:42:39,500 --> 00:42:42,930
因为iOS中的多线程

808
00:42:42,940 --> 00:42:46,140
不是一个对象上多个线程在设置

809
00:42:46,140 --> 00:42:49,270
我们通常有另外一组对象 运行在另外一个线程

810
00:42:49,270 --> 00:42:51,030
例如你的模型

811
00:42:51,030 --> 00:42:54,500
然后UI这些东西运行在UI线程

812
00:42:54,500 --> 00:42:57,030
它们在线程间进行通信

813
00:42:57,050 --> 00:43:00,500
所以我们不需要这个 不仅如此

814
00:43:00,500 --> 00:43:03,250
这里使用@property时

815
00:43:03,250 --> 00:43:06,500
Objective-C会创建我讲过的getter和setter方法

816
00:43:06,500 --> 00:43:09,500
来自动为我们设置contents

817
00:43:09,500 --> 00:43:12,500
而我们希望它们很简单

818
00:43:12,500 --> 00:43:14,500
它们是这样的

819
00:43:14,500 --> 00:43:16,500
我们希望它们很简单

820
00:43:16,500 --> 00:43:20,210
如果我们不说nonatomic 这里会有各种锁定代码

821
00:43:20,210 --> 00:43:22,360
如果你有多线程

822
00:43:22,360 --> 00:43:26,010
你允许多线程访问这里的setter和getter

823
00:43:26,030 --> 00:43:28,500
那你就需要锁定代码 我们不想要锁定代码

824
00:43:28,500 --> 00:43:31,820
尤其是我们要自己实现setter和getter时

825
00:43:31,820 --> 00:43:34,500
有时我们确实会这样做

826
00:43:34,500 --> 00:43:38,500
不过默认情况下 我们不用实现setter和getter

827
00:43:38,500 --> 00:43:40,500
它会自动为我们实现

828
00:43:40,500 --> 00:43:42,500
可以看到这里的三部分

829
00:43:42,500 --> 00:43:45,030
这里有@synthesize(合成) 看到了吗

830
00:43:45,050 --> 00:43:50,500
这里 _contents是实例变量的名字

831
00:43:50,500 --> 00:43:53,500
属性contents将存储于此

832
00:43:53,500 --> 00:43:57,210
我们也可以说@synthesize contents = foo

833
00:43:57,210 --> 00:44:00,500
然后contents属性会被存在这个实例变量foo中

834
00:44:00,500 --> 00:44:02,210
但这很让人犯迷糊

835
00:44:02,210 --> 00:44:05,500
所以我们总是使用下划线属性名

836
00:44:05,500 --> 00:44:07,660
这是第一部分

837
00:44:07,660 --> 00:44:12,500
只是分配实例变量来存储contents属性

838
00:44:12,500 --> 00:44:14,060
然后是getter

839
00:44:14,060 --> 00:44:15,970
也就是 (NSString *)contents

840
00:44:15,970 --> 00:44:17,270
return _contents

841
00:44:17,270 --> 00:44:20,430
- (NSString *)contents

842
00:44:20,430 --> 00:44:23,500
是Objective-C中的一个方法声明

843
00:44:23,500 --> 00:44:25,500
-表示这是一个方法

844
00:44:25,500 --> 00:44:27,400
(NSString *)表示

845
00:44:27,400 --> 00:44:30,500
这一方法返回指向字符串的指针

846
00:44:30,500 --> 00:44:33,500
contents则是方法名

847
00:44:33,500 --> 00:44:37,500
getter的方法名同属性名一样

848
00:44:37,500 --> 00:44:43,500
然后 实现就是返回我们所合成的实例变量

849
00:44:43,500 --> 00:44:49,170
类似地 下一个方法是Objective-C中设置的方法

850
00:44:49,170 --> 00:44:51,500
还是一样 -表示这是一个方法

851
00:44:51,500 --> 00:44:55,500
(void)表示这个方法不返回任何东西

852
00:44:55,500 --> 00:44:57,500
(void)就是这个意思

853
00:44:57,500 --> 00:45:00,880
然后setContents: 这是该方法的名

854
00:45:00,880 --> 00:45:03,080
意思是设置内容

855
00:45:03,080 --> 00:45:07,500
(NSString *)是该方法的参数

856
00:45:07,500 --> 00:45:10,910
contents则是参数名

857
00:45:10,910 --> 00:45:14,230
局部环境下变量的局部名

858
00:45:14,230 --> 00:45:17,210
实现是 _contents

859
00:45:17,210 --> 00:45:20,500
我们的实例变量 =那个参数

860
00:45:20,500 --> 00:45:25,640
在我继续推进之前 大家是否都理解了这两个方法

861
00:45:25,640 --> 00:45:33,500
它们让你能够在Card内设置和获取NSString存储空间

862
00:45:33,500 --> 00:45:35,500
大家都明白这个了吗

863
00:45:35,500 --> 00:45:36,780
有问题

864
00:45:38,500 --> 00:45:41,060
好 synthesize这一行

865
00:45:41,060 --> 00:45:44,300
只是指定实例变量名

866
00:45:44,300 --> 00:45:47,500
用以存储这个 _contents

867
00:45:47,500 --> 00:45:50,990
这有些奇怪 也许更好的说法是

868
00:45:50,990 --> 00:45:53,380
@synthesize contents

869
00:45:53,380 --> 00:45:56,500
去使用名为_contents的实例变量

870
00:45:56,500 --> 00:45:58,260
我知道 这个等号有点奇怪

871
00:45:58,270 --> 00:46:03,080
看起来就像赋值语句 不过你们可以把这个等号看成

872
00:46:03,080 --> 00:46:07,080
使用名为_contents的实例变量

873
00:46:07,100 --> 00:46:08,500
这就是synthesize

874
00:46:08,500 --> 00:46:12,860
没有synthesize 你将无法为Card实例创建空间

875
00:46:12,860 --> 00:46:17,500
而且它没有名 你无法在getter和setter中引用它

876
00:46:17,500 --> 00:46:19,500
大家都懂了吗

877
00:46:19,500 --> 00:46:21,300
还有问题吗

878
00:46:21,300 --> 00:46:26,060
好 当你在左侧键入@property时

879
00:46:26,060 --> 00:46:28,450
这会添加到你的@implementation

880
00:46:28,450 --> 00:46:31,500
但是 你不会在那里看到它

881
00:46:32,230 --> 00:46:34,500
它在那里 但你看不到

882
00:46:34,500 --> 00:46:38,910
Objective-C为你做了那些 但它不会显示出来

883
00:46:38,930 --> 00:46:44,230
不过它在那里 setter和getter方法都在那里

884
00:46:44,230 --> 00:46:45,300
它们存在

885
00:46:45,300 --> 00:46:47,500
不仅这样 它们还是公共的

886
00:46:47,500 --> 00:46:51,500
因为你在头文件中用了@property声明

887
00:46:51,500 --> 00:46:53,500
都明白吗

888
00:46:53,500 --> 00:46:56,500
我们再来看另一个属性 以此进一步熟悉语法

889
00:46:56,500 --> 00:46:59,500
这里有两个属性 它们是布尔型的

890
00:46:59,500 --> 00:47:02,500
C中没有布尔原始类型

891
00:47:02,500 --> 00:47:06,500
所以Objective-C使用类型定义全大写的BOOL

892
00:47:06,500 --> 00:47:09,500
也许是一个短整型 或整型 或字符型

893
00:47:09,500 --> 00:47:12,500
我不知道具体是什么 不过你可以把它当作原始类型

894
00:47:12,500 --> 00:47:15,500
布尔型的值可以是真

895
00:47:15,500 --> 00:47:18,500
用某非0值表示 也可以是非 用0表示

896
00:47:18,500 --> 00:47:21,500
这些属性不需要强或弱来修饰

897
00:47:22,170 --> 00:47:24,260
能理解为什么吗

898
00:47:24,260 --> 00:47:25,500
因为它们是原始类型

899
00:47:25,500 --> 00:47:27,500
它们没有存储在堆中

900
00:47:27,500 --> 00:47:31,060
这里只是整型或浮点型 没有内存需要管理

901
00:47:31,080 --> 00:47:34,260
所以不需要强或弱指针 这里不涉及到指针

902
00:47:34,260 --> 00:47:35,990
只是BOOL 布尔型

903
00:47:36,000 --> 00:47:39,060
所以没有强或弱 但这里仍然有非原子性

904
00:47:39,080 --> 00:47:41,500
因为我们仍然希望setter和getter简单

905
00:47:41,500 --> 00:47:43,100
没有锁定代码这些

906
00:47:43,120 --> 00:47:46,890
这个类中的每一种属性我们都用非原子性来修饰

907
00:47:46,910 --> 00:47:50,040
这个类中没有任何一个属性不是非原子的

908
00:47:50,060 --> 00:47:52,430
这里写下它 我希望它是默认的

909
00:47:52,450 --> 00:47:54,500
这就是我们这里的做法

910
00:47:54,500 --> 00:47:57,500
可以看到这里两者都会合成

911
00:47:57,500 --> 00:47:59,500
两者都能得到setter和getter

912
00:47:59,500 --> 00:48:02,500
这些都由Objective-C为我们自动完成

913
00:48:02,500 --> 00:48:04,910
这里有一点很酷

914
00:48:04,910 --> 00:48:07,230
我们并不一定喜欢getter的名字

915
00:48:07,230 --> 00:48:12,870
因为我们希望 当纸牌被选择时 做点什么

916
00:48:12,890 --> 00:48:14,910
如果纸牌匹配时 做点什么

917
00:48:14,910 --> 00:48:18,500
所以我们更愿意getter叫isChosen 而不是只是chosen

918
00:48:18,500 --> 00:48:22,500
isChosen强调纸牌是否"是"被选择

919
00:48:22,500 --> 00:48:25,500
我们可以为getter重命名

920
00:48:25,500 --> 00:48:29,100
只需要在这里加上getter=你想要的新名字

921
00:48:29,100 --> 00:48:31,500
这就是重命名

922
00:48:31,500 --> 00:48:34,500
下面这个也一样 重命名getter=isMatched

923
00:48:34,500 --> 00:48:37,170
这时getter就叫isMatched了

924
00:48:37,190 --> 00:48:38,650
我讲这个是想告诉你们

925
00:48:38,650 --> 00:48:40,500
iOS如何像这样处理布尔型属性

926
00:48:40,500 --> 00:48:43,870
它会重命名它们为"是"这个 或"有"这个

927
00:48:43,870 --> 00:48:46,500
取决于动词是什么

928
00:48:46,500 --> 00:48:51,760
还是一样 Objective-C会把所有这些代码写到实现中

929
00:48:51,780 --> 00:48:53,500
但你看不到

930
00:48:53,500 --> 00:48:55,500
不过它在那里

931
00:48:55,500 --> 00:49:00,190
以后的课上我会讲到为什么说属性很好

932
00:49:00,190 --> 00:49:05,540
为什么说它比直接访问实例变量要好

933
00:49:05,560 --> 00:49:09,500
总的来说 它便于平衡检验

934
00:49:09,500 --> 00:49:13,500
便于你设置属性后更新UI

935
00:49:13,500 --> 00:49:16,500
便于初始化指针

936
00:49:16,500 --> 00:49:21,240
比如NSString *contents属性将以nil开始

937
00:49:21,240 --> 00:49:25,500
Objective-C中所有属性都是以0开始

938
00:49:25,500 --> 00:49:27,500
对于指针 也就是nil

939
00:49:27,500 --> 00:49:30,800
这是我们创建新纸牌时的contents属性

940
00:49:30,800 --> 00:49:32,820
它不会指向任何内容

941
00:49:32,840 --> 00:49:35,500
纸牌是空的 上面什么都没有

942
00:49:35,500 --> 00:49:38,500
能使用setter和getter很好

943
00:49:38,500 --> 00:49:41,500
我们实现我们自己的setter和getter来检验

944
00:49:41,500 --> 00:49:43,830
是不是nil 如果不是 有时

945
00:49:43,840 --> 00:49:46,210
不是对于contents 而是对于其它属性

946
00:49:46,210 --> 00:49:49,500
如果是nil 我们将在内存中创建一些东西

947
00:49:49,500 --> 00:49:50,850
这是另一个用它的原因

948
00:49:50,870 --> 00:49:55,500
下一讲 你会看到我们使用属性是有各种原因的

949
00:49:55,500 --> 00:49:59,500
下面 我们来看一个方法

950
00:49:59,500 --> 00:50:01,240
一个很常规的方法

951
00:50:01,240 --> 00:50:03,500
你们见过一些方法 setter和getter方法

952
00:50:03,500 --> 00:50:06,820
但我们希望有自己的方法 公共方法

953
00:50:06,820 --> 00:50:09,280
我将定义这个方法为match(匹配)

954
00:50:09,280 --> 00:50:12,590
记得吧 我这里要为纸牌匹配游戏创建一个模型

955
00:50:12,610 --> 00:50:14,690
我需要将所有纸牌放到屏幕上

956
00:50:14,690 --> 00:50:16,500
用户需要进行匹配

957
00:50:16,500 --> 00:50:18,020
选取匹配的那些

958
00:50:18,020 --> 00:50:19,500
所以我需要一个match方法

959
00:50:19,500 --> 00:50:23,500
这个方法告诉我两张纸牌是否匹配

960
00:50:23,500 --> 00:50:26,500
我想要让它保持简单

961
00:50:26,500 --> 00:50:29,500
所以我写了一个简单方法 语义如下

962
00:50:29,500 --> 00:50:31,910
它将另一张纸牌作为参数

963
00:50:31,930 --> 00:50:33,500
它返回一个整数

964
00:50:33,500 --> 00:50:36,960
如果纸牌不匹配 该整数为0

965
00:50:36,960 --> 00:50:42,500
否则 匹配越好 整数值就越大

966
00:50:42,500 --> 00:50:45,500
非常好的匹配可能是1000

967
00:50:45,500 --> 00:50:49,500
不过不算很好的匹配可能只有100 甚至1

968
00:50:49,500 --> 00:50:53,670
这个数字是多少的语义 完全取决于纸牌

969
00:50:53,670 --> 00:50:56,500
因为我们只会将纸牌和其它纸牌进行匹配

970
00:50:56,500 --> 00:50:58,910
我们会弄清它们匹配得有多好

971
00:50:58,930 --> 00:51:01,500
不管Card类是什么

972
00:51:01,500 --> 00:51:05,500
我们会有一个子类 叫作PlayingCard

973
00:51:05,500 --> 00:51:09,060
它会给大小匹配更多分

974
00:51:09,060 --> 00:51:11,500
花色匹配得分相对较少

975
00:51:11,500 --> 00:51:16,500
分数系统由Card的这个子类决定

976
00:51:16,500 --> 00:51:20,060
这里我们的match方法

977
00:51:20,060 --> 00:51:23,060
实现会非常简单

978
00:51:23,060 --> 00:51:25,500
首先假设它们不匹配

979
00:51:25,500 --> 00:51:28,500
这里设分数的局部变量int score = 0

980
00:51:28,500 --> 00:51:30,500
这里是给变量赋值

981
00:51:30,500 --> 00:51:33,500
实际上 所有局部变量默认值都是0

982
00:51:33,500 --> 00:51:35,500
所以这里其实并不真的需要=0

983
00:51:35,500 --> 00:51:37,500
但我认为写明会更好

984
00:51:37,500 --> 00:51:39,960
毕竟这就是你想要的值

985
00:51:39,980 --> 00:51:42,950
这里我确实要让分数为0

986
00:51:42,960 --> 00:51:46,500
分数一直为0 直到有纸牌匹配成功

987
00:51:46,500 --> 00:51:48,830
这更多的是一种编程风格

988
00:51:48,850 --> 00:51:51,500
我怎么知道

989
00:51:51,500 --> 00:51:56,960
纸牌能够匹配和它比较的纸牌呢

990
00:51:56,980 --> 00:52:02,130
答案是 我将发送一些消息

991
00:52:02,280 --> 00:52:04,500
看到这里的开方括号了吗

992
00:52:04,500 --> 00:52:09,590
这是你们第一次看到我在Objective-C中发送消息

993
00:52:09,590 --> 00:52:13,500
这一行中我还将发送另外两条消息

994
00:52:13,500 --> 00:52:18,240
card.contents和self.contents 看到它俩了吗

995
00:52:18,240 --> 00:52:20,350
这些也是消息发送

996
00:52:20,350 --> 00:52:23,280
这里有两种发送消息的语法

997
00:52:23,280 --> 00:52:27,500
一种是开方括号 等下我会具体讲到

998
00:52:27,500 --> 00:52:31,500
另一种是点符号 例如card.contents

999
00:52:31,500 --> 00:52:32,940
什么时候使用呢

1000
00:52:32,960 --> 00:52:37,500
点符号只用于属性

1001
00:52:37,500 --> 00:52:41,500
这是调用属性setter和getter的方式 使用点符号

1002
00:52:41,500 --> 00:52:44,760
这里我们调用的是getter

1003
00:52:44,780 --> 00:52:46,670
card.contents调用的是

1004
00:52:46,670 --> 00:52:52,500
card实例contents属性的getter方法

1005
00:52:52,500 --> 00:52:54,500
如何调用setter呢

1006
00:52:54,500 --> 00:52:55,500
完全一样

1007
00:52:55,500 --> 00:52:59,500
card.contents 但是要放在等号左侧

1008
00:52:59,500 --> 00:53:01,150
card.contents =

1009
00:53:01,150 --> 00:53:04,500
这就是调用contents的setter 明白吗

1010
00:53:04,500 --> 00:53:06,070
这里我们在调用getter

1011
00:53:06,090 --> 00:53:09,760
我们还为self(自身)的contents调用了getter

1012
00:53:09,780 --> 00:53:12,500
其它语言中 这个可能用的是this

1013
00:53:12,500 --> 00:53:14,330
但你们知道self是什么

1014
00:53:14,330 --> 00:53:17,500
self也就是这段代码正在起作用的实例

1015
00:53:17,500 --> 00:53:20,780
我们将对比这两个字符串

1016
00:53:20,780 --> 00:53:23,150
card.contents和self.contents

1017
00:53:23,150 --> 00:53:25,500
看它们是否相等

1018
00:53:25,500 --> 00:53:30,030
使用的是NSString方法isEqualToString:

1019
00:53:30,040 --> 00:53:34,410
isEqualToString:只能被发送给一个字符串

1020
00:53:35,180 --> 00:53:38,350
isEqualToString只能被发送给一个字符串

1021
00:53:38,350 --> 00:53:40,160
而card.contents

1022
00:53:40,170 --> 00:53:42,850
是一个返回NSString的getter方法

1023
00:53:42,850 --> 00:53:43,830
这很好

1024
00:53:43,850 --> 00:53:46,630
我们将isEqualToString发送给一个字符串

1025
00:53:46,630 --> 00:53:50,790
而且isEqualToString将一个NSString作为参数

1026
00:53:50,790 --> 00:53:52,090
重复一次 self.contents

1027
00:53:52,090 --> 00:53:54,500
是返回NSString的getter方法

1028
00:53:54,500 --> 00:53:58,410
这样 我们就满足了isEqualToString的所有要求

1029
00:53:58,420 --> 00:54:00,500
外面打上方括号

1030
00:54:00,500 --> 00:54:02,500
这会返回一个布尔值

1031
00:54:02,500 --> 00:54:05,150
isEqualToString的作用是返回布尔值

1032
00:54:05,150 --> 00:54:07,500
看两个字符串是否相同

1033
00:54:07,500 --> 00:54:10,500
注意到这里用的不是==

1034
00:54:10,500 --> 00:54:14,290
我们没有说card.contents==self.contents

1035
00:54:14,290 --> 00:54:16,500
因为==比较的是指针

1036
00:54:16,500 --> 00:54:20,500
而不是指针指向的内容

1037
00:54:20,500 --> 00:54:24,130
大家明白为什么不用==来看两字符串是否相等了吗

1038
00:54:24,150 --> 00:54:27,500
如果两个字符串相等 我将给1分

1039
00:54:27,500 --> 00:54:32,180
这是一种极度简单化的匹配实现

1040
00:54:32,180 --> 00:54:35,500
也就是 如果纸牌内容完全相同

1041
00:54:35,500 --> 00:54:38,130
我得到1分 否则得0分

1042
00:54:38,150 --> 00:54:42,500
后面在PlayingCard中 匹配实现会更好一些

1043
00:54:42,500 --> 00:54:44,500
这里只是一个极简单的例子

1044
00:54:44,500 --> 00:54:48,500
关于Objective-C我再讲一点

1045
00:54:48,500 --> 00:54:50,500
如果我们改变这个方法… 哦 对

1046
00:54:50,500 --> 00:54:55,500
这是关于谁是发送者 谁是接收者的一点内容

1047
00:54:55,500 --> 00:54:57,500
你们可以自己看这些幻灯片

1048
00:54:57,500 --> 00:55:00,500
不过我打算让这个更复杂一些

1049
00:55:00,500 --> 00:55:04,500
我将让match的参数是一个纸牌的数组

1050
00:55:04,500 --> 00:55:09,500
现在我要将这张牌 同其它很多牌进行匹配

1051
00:55:10,070 --> 00:55:14,500
现在我需要新的算法来匹配

1052
00:55:14,500 --> 00:55:16,500
这里纸牌的匹配还是

1053
00:55:16,500 --> 00:55:18,500
假设要匹配三张牌

1054
00:55:18,500 --> 00:55:21,700
如果三张牌大小都一样 你能得很多分

1055
00:55:21,700 --> 00:55:24,110
例如都是J 你会得到很多分

1056
00:55:24,130 --> 00:55:26,500
如果只有两张是J 其它都是别的

1057
00:55:26,500 --> 00:55:28,500
你就没有之前得分多

1058
00:55:28,500 --> 00:55:31,110
如果它们都是相同花色 你会得到中等量的分

1059
00:55:31,110 --> 00:55:32,500
知道我讲的什么吗

1060
00:55:32,500 --> 00:55:37,500
这里match的参数是一整个数组 而不只是一张牌

1061
00:55:37,500 --> 00:55:41,200
如何改变实现来应对这个呢

1062
00:55:41,200 --> 00:55:44,500
这里我将使用一个for循环在if外

1063
00:55:44,500 --> 00:55:47,020
遍历所有纸牌

1064
00:55:47,030 --> 00:55:51,200
这种实现 但愿你们能很快反应过来

1065
00:55:51,200 --> 00:55:52,500
这有什么用

1066
00:55:52,500 --> 00:55:53,850
这会在

1067
00:55:53,850 --> 00:55:58,500
纸牌同数组中任何一张纸牌匹配时给你1分

1068
00:55:58,500 --> 00:56:01,090
任何一张 不是所有 而是任一

1069
00:56:01,090 --> 00:56:03,500
当然 你们也可以想象更好的算法

1070
00:56:03,500 --> 00:56:07,000
例如数组中每匹配上一张牌就得1分

1071
00:56:07,010 --> 00:56:10,890
或者匹配一个得2分 两个4分 三个8分

1072
00:56:10,900 --> 00:56:14,500
使用某种指数得分算法

1073
00:56:14,500 --> 00:56:16,530
但今天只是第一天课

1074
00:56:16,530 --> 00:56:19,140
弄简单一些 有任意一个匹配就得1分

1075
00:56:19,160 --> 00:56:21,420
这里我只是想展示给大家

1076
00:56:21,420 --> 00:56:25,500
参数中如果是一个数组 而不是一张牌时会怎样

1077
00:56:25,500 --> 00:56:29,070
让你们理解方法的参数是什么

1078
00:56:29,070 --> 00:56:31,870
同时我还想展示for循环

1079
00:56:31,880 --> 00:56:35,500
这里有for in 很多语言中现在都有这样的结构

1080
00:56:35,500 --> 00:56:37,770
也就是说它是一个for循环

1081
00:56:37,770 --> 00:56:41,370
它会遍历NSArray中的每一个对象

1082
00:56:41,370 --> 00:56:43,000
将它赋值给card

1083
00:56:43,010 --> 00:56:44,750
card是迭代变量

1084
00:56:44,750 --> 00:56:48,000
对于数组中每一张牌执行一次if

1085
00:56:48,010 --> 00:56:49,940
大家都能理解这个吗

1086
00:56:49,940 --> 00:56:52,500
有问题的话请提出来

1087
00:56:53,010 --> 00:56:54,380
请讲

1088
00:56:58,570 --> 00:57:00,500
哦 好 问得很好

1089
00:57:00,500 --> 00:57:04,500
问题是 for行如果写for Card card

1090
00:57:04,500 --> 00:57:09,120
而不是for Card *card in otherCards 会怎样

1091
00:57:09,120 --> 00:57:11,700
我们会得到语法错误 为什么

1092
00:57:11,740 --> 00:57:15,500
因为所有对象都有指针指着 所以总有这个星号

1093
00:57:15,500 --> 00:57:17,500
总是

1094
00:57:17,500 --> 00:57:22,000
没有哪张牌没有指针指着

1095
00:57:22,030 --> 00:57:25,500
所以这里 Objective-C会告诉你语法错误

1096
00:57:25,500 --> 00:57:27,500
不能没有这个星号

1097
00:57:27,500 --> 00:57:31,180
有类名时 就总得有这个星号 请讲

1098
00:57:35,720 --> 00:57:37,940
是 问题问得很好

1099
00:57:37,960 --> 00:57:41,250
我能否使用方括号来调用setter和getter

1100
00:57:41,250 --> 00:57:43,160
来代替点符号

1101
00:57:43,180 --> 00:57:46,810
这个问题很有深度 答案是完全可以

1102
00:57:46,810 --> 00:57:50,500
这完全是合法的 因为setter和getter也是正常的方法

1103
00:57:50,500 --> 00:57:52,500
它们没有什么特殊之处

1104
00:57:52,500 --> 00:57:57,500
点符号只是语法上一点精简 一点甜头

1105
00:57:57,500 --> 00:58:00,860
如果问题是setter和getter是否应该用方括号

1106
00:58:00,860 --> 00:58:02,900
我想这是风格问题

1107
00:58:02,900 --> 00:58:05,140
反正你需要100%保持一致

1108
00:58:05,140 --> 00:58:06,500
不要混用

1109
00:58:06,500 --> 00:58:10,310
我想大多数人都会用点符号

1110
00:58:10,310 --> 00:58:13,500
这会更清楚 更简单 更美观

1111
00:58:13,500 --> 00:58:15,290
但是你也可以不这样

1112
00:58:15,290 --> 00:58:17,180
这门课中请使用点符号

1113
00:58:17,180 --> 00:58:19,500
我要确保你们懂得如何用点符号

1114
00:58:19,500 --> 00:58:20,420
有问题

1115
00:58:24,860 --> 00:58:26,500
又是一个很棒的问题

1116
00:58:26,500 --> 00:58:28,120
天啊 你们太厉害了

1117
00:58:28,140 --> 00:58:32,500
我能否将点符号用于getter和setter之外

1118
00:58:32,500 --> 00:58:34,500
一个没有参数的方法

1119
00:58:34,500 --> 00:58:37,920
答案是这样做的话 Objective-C会警告你

1120
00:58:37,940 --> 00:58:39,830
不是错误 而是警告

1121
00:58:39,850 --> 00:58:41,880
这门课中不可以这样做

1122
00:58:41,900 --> 00:58:44,310
这不是一个很好的做法

1123
00:58:44,310 --> 00:58:46,880
他所讲的那个还可以探讨

1124
00:58:46,900 --> 00:58:48,750
但你这个 不要这样做

1125
00:58:48,770 --> 00:58:52,500
点符号只能用于setter和getter

1126
00:58:52,500 --> 00:58:53,500
还有问题吗

1127
00:58:55,070 --> 00:58:56,050
请讲

1128
00:58:59,500 --> 00:59:02,500
问题是 如何用点符号来使用setter

1129
00:59:02,500 --> 00:59:04,500
同getter完全一样

1130
00:59:04,500 --> 00:59:07,500
只是需要用到等号的左边

1131
00:59:07,500 --> 00:59:12,160
例如card.contents 等号 梅花A

1132
00:59:12,160 --> 00:59:15,500
这就会调用contents的setter

1133
00:59:15,500 --> 00:59:19,840
这里则会调用getter 因为它没在等号左侧

1134
00:59:21,470 --> 00:59:23,360
很好 今天就这些了

1135
00:59:23,360 --> 00:59:26,810
周三 我会讲Deck

1136
00:59:26,830 --> 00:59:29,530
PlayingCard和PlayingCardDeck

1137
00:59:29,530 --> 00:59:33,500
我会详细讲解XCode 5中的一个经典demo

1138
00:59:33,500 --> 00:59:35,500
看这些实际是怎么做到的

1139
00:59:35,500 --> 00:59:38,500
下周 我们会更进一步讲Objective-C

1140
00:59:38,500 --> 00:59:40,400
非常感谢大家

1141
00:59:41,720 --> 00:59:45,660
更多内容 请访问我校官网stanford.edu

