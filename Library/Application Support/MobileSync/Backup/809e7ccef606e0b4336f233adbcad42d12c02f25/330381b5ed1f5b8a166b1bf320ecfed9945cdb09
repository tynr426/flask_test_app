1
00:00:05,250 --> 00:00:11,500
斯坦福大学

2
00:00:11,500 --> 00:00:20,860
欢迎来到2013/2014学年秋CS193P课程的第二课

3
00:00:20,860 --> 00:00:24,990
今天最开始我们将有一些幻灯片

4
00:00:24,990 --> 00:00:28,950
一点讲课 然后我将有一个很大的demo

5
00:00:28,950 --> 00:00:31,220
我希望用它来综合前两讲

6
00:00:31,220 --> 00:00:33,570
我讲过的这些内容

7
00:00:33,590 --> 00:00:36,850
也就是 我们将开始创建我们的纸牌游戏

8
00:00:36,850 --> 00:00:38,640
这个纸牌匹配游戏

9
00:00:38,640 --> 00:00:43,700
将是我们头两周的基础材料 用以学习Objective-C

10
00:00:43,700 --> 00:00:47,870
学习Xcode 学习iOS如何衔接起

11
00:00:47,870 --> 00:00:52,540
控制器 视图以及模型 来建立UI

12
00:00:52,540 --> 00:00:58,950
记得上次 我讲了这整个Card类

13
00:00:58,950 --> 00:01:00,240
这个类很简单

14
00:01:00,240 --> 00:01:04,110
它有三个属性和一个方法

15
00:01:04,110 --> 00:01:05,730
就这么简单

16
00:01:05,730 --> 00:01:09,840
今天我们将继续考虑另一个类 也就是Deck

17
00:01:09,840 --> 00:01:11,360
表示牌堆

18
00:01:11,360 --> 00:01:14,900
记住 Card和Deck是通用的

19
00:01:14,900 --> 00:01:17,300
它们并非专门针对扑克牌

20
00:01:17,300 --> 00:01:20,190
扑克牌是PlayingCard 诸如梅花A 红心K这些

21
00:01:20,190 --> 00:01:22,790
扑克牌是PlayingCard 诸如梅花A 红心K这些

22
00:01:22,790 --> 00:01:24,380
这里是笼统的纸牌和牌堆

23
00:01:24,380 --> 00:01:26,660
可以是一副抽认卡

24
00:01:26,660 --> 00:01:30,560
一副外语单词卡等等

25
00:01:30,560 --> 00:01:33,900
所以 我们希望这些Deck和Card类具有通用性

26
00:01:33,900 --> 00:01:34,840
这是Deck

27
00:01:34,840 --> 00:01:37,680
其基础结构你们应该熟悉

28
00:01:37,680 --> 00:01:40,790
这里导入我们的父类框架

29
00:01:40,790 --> 00:01:45,440
然后在实现中导入我们的头文件

30
00:01:45,440 --> 00:01:50,310
Deck的接口将有这样两个基础方法

31
00:01:50,310 --> 00:01:52,150
一是将纸牌加到牌堆中

32
00:01:52,150 --> 00:01:55,590
一是随机从牌堆中抽取一张牌

33
00:01:55,590 --> 00:02:00,820
添加纸牌到牌堆中的方法对你们而言有些新

34
00:02:00,820 --> 00:02:03,150
因为你们会看到它有两个参数

35
00:02:03,150 --> 00:02:05,880
这是你们第一次看到有两个参数的方法

36
00:02:05,880 --> 00:02:08,620
之前你们看到的方法要么是没有参数

37
00:02:08,620 --> 00:02:10,710
要么只有一个参数 如match

38
00:02:10,720 --> 00:02:13,910
match只有一个参数 或setter也只有一个参数

39
00:02:13,910 --> 00:02:17,790
注意Objective-C中当你有多个参数时

40
00:02:17,790 --> 00:02:22,230
它们会穿插在方法名中间

41
00:02:22,230 --> 00:02:28,200
这个方法的名称是addCard冒号 atTop冒号

42
00:02:28,200 --> 00:02:29,950
这是该方法的名称

43
00:02:29,950 --> 00:02:33,320
atTop这部分其实也是方法名的一部分

44
00:02:33,320 --> 00:02:35,560
而参数 像这里要加的纸牌card

45
00:02:35,560 --> 00:02:38,190
和表示在牌堆上方还是下方的布尔值atTop

46
00:02:38,190 --> 00:02:40,340
和表示在牌堆上方还是下方的布尔值atTop

47
00:02:40,340 --> 00:02:43,580
这些参数穿插在方法名中间

48
00:02:43,580 --> 00:02:47,680
等下你们会看到 这种方法如何调用

49
00:02:47,680 --> 00:02:50,800
然后随机抽取一张牌的方法

50
00:02:50,800 --> 00:02:55,140
没有参数 会返回一个值 这方面同getter类似

51
00:02:55,140 --> 00:02:58,700
但这不是getter 因为我们没有将它作为一个属性

52
00:02:58,700 --> 00:03:00,650
很重要的一点是

53
00:03:00,650 --> 00:03:02,620
你可以把它弄成一个属性

54
00:03:02,620 --> 00:03:04,970
例如只读属性这些

55
00:03:04,970 --> 00:03:08,520
但随机抽取一张牌做了一些事情

56
00:03:08,520 --> 00:03:12,320
它有一个算法 一个机制

57
00:03:12,320 --> 00:03:13,910
通常不要把它弄成属性

58
00:03:13,910 --> 00:03:16,540
让getter做这个可以说是滥用

59
00:03:16,540 --> 00:03:18,810
getter的作用只是设置和获取一个值

60
00:03:18,810 --> 00:03:22,200
它可能有副作用 设置可能更新UI

61
00:03:22,210 --> 00:03:26,160
或者获取可能确保先初始化了 诸如此类

62
00:03:26,160 --> 00:03:28,020
做一些事的方法

63
00:03:28,020 --> 00:03:31,870
例如抽取一张牌不要弄成属性

64
00:03:31,870 --> 00:03:36,950
如果你想要atTop这样的参数可选

65
00:03:36,950 --> 00:03:39,770
Objective-C中的唯一做法是

66
00:03:39,770 --> 00:03:42,420
显然我们这里需要一个头文件

67
00:03:42,420 --> 00:03:44,010
Objective-C中唯一的做法是

68
00:03:44,010 --> 00:03:48,860
声明新方法 addCard: 不带atTop

69
00:03:48,860 --> 00:03:51,490
这是一个完全不同的方法

70
00:03:51,490 --> 00:03:54,710
只不过在实现中 我们需要调用另一个方法

71
00:03:54,710 --> 00:03:57,840
只不过在实现中 我们需要调用另一个方法

72
00:03:57,840 --> 00:04:00,030
所以addCard中 我们会说self addCard

73
00:04:00,030 --> 00:04:00,890
atTop:

74
00:04:00,890 --> 00:04:03,970
后面跟默认情况 这里也就是NO

75
00:04:03,970 --> 00:04:07,420
这里只是要你们理解 在某些语言中

76
00:04:07,420 --> 00:04:10,610
某些参数可以是可选的

77
00:04:10,610 --> 00:04:16,170
或者重载 让相同方法具有不同参数

78
00:04:16,170 --> 00:04:19,690
不像Objective-C中 每种方法完全不同

79
00:04:19,690 --> 00:04:21,150
有不同的名称

80
00:04:21,150 --> 00:04:23,860
多出来的参数会像这样穿插

81
00:04:23,860 --> 00:04:26,240
所以 这是两种不同方法

82
00:04:26,240 --> 00:04:27,590
能理解吗

83
00:04:27,590 --> 00:04:31,710
好 我们再来看看Deck的实现

84
00:04:31,710 --> 00:04:34,480
Deck包含一些纸牌

85
00:04:34,480 --> 00:04:38,290
我们需要某种内部数据结构来存储所有这些牌

86
00:04:38,290 --> 00:04:43,450
我们将会用到的是一个可变数组

87
00:04:43,450 --> 00:04:47,590
你们已经见过NSArray类 这是一种基础类数组

88
00:04:47,590 --> 00:04:49,250
其中是一组对象

89
00:04:49,250 --> 00:04:51,690
数组中这些对象可以是任何类的

90
00:04:51,690 --> 00:04:56,950
数组中是哪类对象没法指定

91
00:04:56,950 --> 00:04:58,460
有些语言让你这样做

92
00:04:58,460 --> 00:05:02,800
你可以指定"这是字符串数组" 它于是知道

93
00:05:02,800 --> 00:05:04,380
但Objective-C不能这样

94
00:05:04,380 --> 00:05:06,970
我将讲到我们怎么处理这个

95
00:05:06,990 --> 00:05:08,930
这在Objective-C中有些狂放

96
00:05:08,930 --> 00:05:11,750
不过如果想确保安全的话

97
00:05:11,750 --> 00:05:14,460
我们有办法检查对象是什么

98
00:05:14,460 --> 00:05:16,350
而这里 我们用这个可变数组

99
00:05:16,350 --> 00:05:18,950
可变意思是说我们可以给数组添加对象

100
00:05:18,950 --> 00:05:21,840
一般的NSArray都是不可变的

101
00:05:21,840 --> 00:05:24,390
创建后 不管其中放入了什么对象

102
00:05:24,390 --> 00:05:25,620
这些对象就永远在里面

103
00:05:25,620 --> 00:05:27,910
你无法将它们删除 也无法继续添加

104
00:05:27,910 --> 00:05:29,800
如果我们希望数组能添加东西

105
00:05:29,800 --> 00:05:33,310
我们需要使用NSArray的子类 NSMutableArray

106
00:05:33,310 --> 00:05:35,790
可以看到 它是一个属性

107
00:05:35,790 --> 00:05:38,530
它是强的 因为我们希望只要指着数组时

108
00:05:38,530 --> 00:05:40,550
它就应该保留在堆中

109
00:05:40,550 --> 00:05:43,060
当然 还有我们总会加的非原子性

110
00:05:43,080 --> 00:05:45,940
这就是一个纸牌的数组

111
00:05:45,940 --> 00:05:49,840
有了这个之后 我们可以轻松实现addCard

112
00:05:49,840 --> 00:05:54,380
例如 我们可以说 "如果在顶部 那么插入对象"

113
00:05:54,380 --> 00:05:57,860
card是这个方法的第一个参数

114
00:05:57,860 --> 00:05:59,200
在下标0处

115
00:05:59,200 --> 00:06:03,970
insertObject atIndex是NSMutableArray中的方法

116
00:06:03,970 --> 00:06:07,280
不是在NSArray中 而是NSMutableArray中

117
00:06:07,290 --> 00:06:09,030
因为这会让数组变化

118
00:06:09,030 --> 00:06:11,990
该方法是将对象插入到数组指定下标处

119
00:06:11,990 --> 00:06:13,740
下标0表示是在顶端

120
00:06:13,740 --> 00:06:15,160
我们会定义的

121
00:06:15,160 --> 00:06:17,060
如果我们不把它放到顶部 那就放在底部

122
00:06:17,060 --> 00:06:17,910
如果我们不把它放到顶部 那就放在底部

123
00:06:17,910 --> 00:06:21,140
这要用到另一个NSMutableArray方法addObject

124
00:06:21,140 --> 00:06:23,880
作用是将数组添加到数组末尾

125
00:06:23,880 --> 00:06:25,360
大家都明白了吗

126
00:06:25,360 --> 00:06:27,530
这里给出这些方法只是为了

127
00:06:27,530 --> 00:06:30,730
展示给你们可变数组的不同方法

128
00:06:30,730 --> 00:06:32,970
以及如何使用参数

129
00:06:32,970 --> 00:06:35,020
这里并没有什么大不了

130
00:06:35,030 --> 00:06:38,210
只是为了让你们习惯这里的情况

131
00:06:38,210 --> 00:06:40,970
好 这是addCard 非常非常简单

132
00:06:40,970 --> 00:06:43,140
不过有个问题

133
00:06:43,140 --> 00:06:49,180
在这个addCard中 如果我们只是创建一个Deck

134
00:06:49,180 --> 00:06:52,230
然后调用addCard 它无法奏效

135
00:06:52,230 --> 00:06:53,930
它什么都做不了

136
00:06:53,930 --> 00:06:55,480
为什么呢

137
00:06:55,480 --> 00:06:58,780
因为属性cards

138
00:06:58,780 --> 00:07:01,400
self.cards是我们访问属性的方式

139
00:07:01,400 --> 00:07:05,230
其getter根据默认是那样的

140
00:07:05,230 --> 00:07:07,630
如果我们不自定义getter getter就是那样

141
00:07:07,630 --> 00:07:10,580
它会返回这个_cards实例变量

142
00:07:10,580 --> 00:07:14,300
而这个_cards实例变量最开始会是0

143
00:07:14,300 --> 00:07:18,590
因为Objective-C中所有实例变量都从0开始

144
00:07:18,590 --> 00:07:19,440
所有

145
00:07:19,440 --> 00:07:21,880
包括指针

146
00:07:21,880 --> 00:07:24,900
那个指针会是0 也就是nil

147
00:07:24,900 --> 00:07:29,370
也就是说它没有指向任何东西 也就是说没有数组

148
00:07:29,370 --> 00:07:33,180
指向数组的指针现在什么都没指到

149
00:07:33,180 --> 00:07:34,670
这是一个问题

150
00:07:34,670 --> 00:07:36,850
所以当我们执行addCard中

151
00:07:36,850 --> 00:07:39,670
self.cards addObject:card这样的代码时

152
00:07:39,670 --> 00:07:43,780
程序不会崩溃 但也不会做任何事情

153
00:07:43,780 --> 00:07:47,440
因为我说过 你可以将消息发送给nil

154
00:07:47,440 --> 00:07:51,750
发送消息给没有指向任何对象的指针

155
00:07:51,770 --> 00:07:53,710
这不会崩溃掉

156
00:07:53,710 --> 00:07:58,350
如果发送返回某个值的消息 该消息不会执行任何代码

157
00:07:58,350 --> 00:07:59,890
它会返回0

158
00:07:59,890 --> 00:08:02,140
这里只是一堆0在飞舞

159
00:08:02,140 --> 00:08:04,050
这个如何修正呢

160
00:08:04,050 --> 00:08:06,570
我们如何让addCard工作呢

161
00:08:06,570 --> 00:08:09,490
我们可以在addCard最开始加这样一段

162
00:08:09,510 --> 00:08:12,560
如果self.cards为nil

163
00:08:12,560 --> 00:08:17,790
那么在堆中分配一个数组并指向它 我们会用到它

164
00:08:17,790 --> 00:08:21,120
这就意味着每次使用self.cards时

165
00:08:21,120 --> 00:08:23,560
我们都需要检验它是否为nil

166
00:08:23,560 --> 00:08:25,350
这很让人不爽

167
00:08:25,350 --> 00:08:29,350
这很易于出错 易于产生bug 我们可能忘记掉

168
00:08:29,350 --> 00:08:30,310
所有这些

169
00:08:30,310 --> 00:08:35,320
所以 加入这一段的最佳位置是在getter中

170
00:08:35,320 --> 00:08:37,220
也就是cards的那个getter

171
00:08:37,220 --> 00:08:40,270
这是私有属性cards的getter

172
00:08:40,270 --> 00:08:42,540
我们让这里不仅仅是返回_cards

173
00:08:42,540 --> 00:08:47,260
前面我们再加一行 如果_cards为nil

174
00:08:47,260 --> 00:08:52,190
那么 我们就要在堆中分配空间 并赋值给实例变量

175
00:08:52,190 --> 00:08:57,730
这里在堆中分配数组的方式是用

176
00:08:57,730 --> 00:09:00,390
[[NSMutableArray alloc] init]

177
00:09:00,390 --> 00:09:04,170
这是两个消息调用嵌套在一起

178
00:09:04,170 --> 00:09:06,260
alloc在堆中分配内存

179
00:09:06,260 --> 00:09:10,540
init则用于初始化内存 让它成为一个合理的数组

180
00:09:10,540 --> 00:09:15,290
过几张幻灯片 我会讲到如何构建我们自己的初始化程序

181
00:09:15,290 --> 00:09:20,970
这样一来 每次调用self.cards都能保证它不是nil

182
00:09:20,970 --> 00:09:23,690
它至少会是一个空数组

183
00:09:23,710 --> 00:09:25,910
大家都明白这段代码了吗

184
00:09:25,910 --> 00:09:28,510
理解这个非常重要 请讲

185
00:09:28,510 --> 00:09:37,470
[学生提问 声音不清]

186
00:09:37,480 --> 00:09:39,610
Paul Hegarty：好 问题是

187
00:09:39,620 --> 00:09:42,900
可不可以不将初始化代码放到这个getter中

188
00:09:42,900 --> 00:09:48,970
而将初始化代码放到Deck的init中 放到Deck中

189
00:09:48,970 --> 00:09:50,630
这是另一种可选做法

190
00:09:50,630 --> 00:09:53,820
等下在PlayingCardDeck中 我会写一段初始化程序

191
00:09:53,820 --> 00:09:55,440
等下在PlayingCardDeck中 我会写一段初始化程序

192
00:09:55,440 --> 00:09:57,450
我们可以这样做

193
00:09:57,450 --> 00:10:01,100
但让这些的初始化更接近于

194
00:10:01,100 --> 00:10:04,820
实际获得属性的地方更加…

195
00:10:04,820 --> 00:10:08,970
它让你的init中这样的垃圾更少

196
00:10:08,970 --> 00:10:13,010
顺便说下 这样做被称作惰性实例化

197
00:10:13,010 --> 00:10:18,180
我们是惰性地等到最后一秒再实例化

198
00:10:18,180 --> 00:10:21,250
这种做法是Objective-C中每个人都习惯的

199
00:10:21,250 --> 00:10:23,930
你们也应当用这个 而不是写到init中

200
00:10:23,930 --> 00:10:27,530
init中 你希望设置各种

201
00:10:27,530 --> 00:10:30,290
不能简单像这样初始化的值

202
00:10:30,290 --> 00:10:32,470
不过你问得很好

203
00:10:32,470 --> 00:10:34,720
过几张幻灯我们就会看到init

204
00:10:34,720 --> 00:10:37,860
这样我们就保证了self.cards不为nil 请讲

205
00:10:37,890 --> 00:10:40,630
[学生提问 声音不清]

206
00:10:40,630 --> 00:10:43,180
Paul Hegarty：对 下划线来自上一讲

207
00:10:43,180 --> 00:10:46,530
记得吧 当我们创建一个属性时

208
00:10:46,530 --> 00:10:48,670
Objective-C会自动给出

209
00:10:48,670 --> 00:10:51,850
@synthesize cards = _cards

210
00:10:51,850 --> 00:10:56,510
也就是说 这赋值了一个实例变量 叫下划线属性名

211
00:10:56,510 --> 00:10:58,570
作为该属性的存储空间

212
00:10:58,570 --> 00:11:02,990
因此_cards是自动创建的 这是幕后完成的

213
00:11:02,990 --> 00:11:06,850
@synthesize没出现在我的代码里 但它确实存在

214
00:11:06,850 --> 00:11:09,180
问得很好

215
00:11:09,180 --> 00:11:11,860
这里还有问题吗

216
00:11:11,860 --> 00:11:18,140
好 下面继续来看随机抽取纸牌方法

217
00:11:18,140 --> 00:11:24,520
随机抽取纸牌希望从self.cards中随机抽选一张牌

218
00:11:24,520 --> 00:11:27,330
代码很简单

219
00:11:27,330 --> 00:11:30,250
我们获取一个随机整数

220
00:11:30,250 --> 00:11:34,040
arc4random就是做这个的 它是一个C库函数

221
00:11:34,040 --> 00:11:35,530
用于获取一个随机整数

222
00:11:35,530 --> 00:11:39,800
之后的%表示求余数

223
00:11:39,800 --> 00:11:42,090
然后self.cards count是

224
00:11:42,100 --> 00:11:44,870
self.cards中纸牌的数目

225
00:11:44,870 --> 00:11:49,170
这就得到随机数index作为self.cards的下标

226
00:11:49,170 --> 00:11:51,450
然后赋值给randomCard

227
00:11:51,450 --> 00:11:55,390
= self.cards[index]

228
00:11:55,390 --> 00:12:01,480
这里方括号是数组访问的标准语法

229
00:12:01,480 --> 00:12:05,050
有趣的是 self.cards[index]实际上

230
00:12:05,050 --> 00:12:07,290
也是一个消息发送 信不信由你

231
00:12:07,290 --> 00:12:12,450
这等价于self.cards objectAtIndex:index

232
00:12:12,450 --> 00:12:15,800
这里只是一种特殊的语法甜头

233
00:12:15,800 --> 00:12:18,450
这样你就不需要写很长的objectAtIndex了

234
00:12:18,450 --> 00:12:22,460
不需要objectAtIndexedSubscript这样的长方法名

235
00:12:22,460 --> 00:12:26,100
这里只是一些简短美妙的语法

236
00:12:26,100 --> 00:12:30,820
不过这是一种消息发送 来得到数组该下标处的牌

237
00:12:30,820 --> 00:12:35,560
然后我们还要从数组中删除这张牌

238
00:12:35,560 --> 00:12:38,260
因为这张牌已经被抽出

239
00:12:38,260 --> 00:12:42,450
抽出后就不在这一叠牌中了

240
00:12:42,450 --> 00:12:45,660
这段代码也有问题 也就是

241
00:12:45,660 --> 00:12:48,500
如果这一叠牌是空的怎么办

242
00:12:48,500 --> 00:12:53,610
如果这一叠牌是空的 那么unsigned index将是0

243
00:12:53,630 --> 00:12:56,910
这里将是arc4random % 0

244
00:12:56,910 --> 00:12:58,780
这将是0

245
00:12:58,800 --> 00:13:02,180
于是后面就是randomCard = self.cards[0]

246
00:13:02,180 --> 00:13:05,140
这会让你的程序崩溃掉

247
00:13:05,140 --> 00:13:07,940
因为self.cards是一个空数组

248
00:13:07,940 --> 00:13:12,380
那么下标0处将没有对象 这是数组下标越界错误

249
00:13:12,380 --> 00:13:14,470
小心这个

250
00:13:14,470 --> 00:13:18,710
数组在某下标处没有对象时 你就无法得到它

251
00:13:18,710 --> 00:13:20,980
数组在某下标处没有对象时 你就无法得到它

252
00:13:20,980 --> 00:13:22,710
这很好修正

253
00:13:22,710 --> 00:13:26,800
我们可以加上 if ([self.cards count])

254
00:13:26,800 --> 00:13:29,760
也就是说 如果数组中有内容 那么我们就这样做

255
00:13:29,760 --> 00:13:32,700
否则我们将返回randomCard

256
00:13:32,700 --> 00:13:35,480
方法最开始时我就已经将其初始化为nil了

257
00:13:35,500 --> 00:13:37,550
所以我喜欢这样做

258
00:13:37,560 --> 00:13:40,110
初始化得到你想要的默认值

259
00:13:40,110 --> 00:13:41,830
然后设置 然后返回

260
00:13:41,830 --> 00:13:44,100
这样一来 如果设置不幸失败的话

261
00:13:44,100 --> 00:13:46,120
例如像这样 一叠牌根本就没牌

262
00:13:46,120 --> 00:13:48,330
它会返回合适的默认值

263
00:13:48,330 --> 00:13:50,610
这是一种编程风格

264
00:13:50,610 --> 00:13:53,600
我们对score和match也做了相同的事情

265
00:13:53,600 --> 00:13:57,050
关于这个有问题吗 请讲

266
00:13:57,050 --> 00:14:03,580
[学生提问 声音不清]

267
00:14:03,580 --> 00:14:04,960
Paul Hegarty：问得很好

268
00:14:04,960 --> 00:14:11,170
问题是 什么时候用NSInteger或NSUInteger

269
00:14:11,170 --> 00:14:15,370
而不用int 甚至我们还没讲到过的NSNumber

270
00:14:15,370 --> 00:14:17,620
答案是 这是一个风格问题

271
00:14:17,620 --> 00:14:20,920
我会简单讲到这种风格 以及何时使用这些

272
00:14:20,920 --> 00:14:24,010
只是在局部使用时

273
00:14:24,010 --> 00:14:27,810
不要用NSNumber这种对象

274
00:14:27,810 --> 00:14:28,630
不要那样

275
00:14:28,630 --> 00:14:32,910
使用NSNumber通常是为了将其传递给方法

276
00:14:32,930 --> 00:14:35,550
哪怕这时你也可以传递int或float值

277
00:14:35,550 --> 00:14:41,810
下周讲NSNumber时这会变得很明显

278
00:14:41,810 --> 00:14:43,600
这是Deck

279
00:14:43,600 --> 00:14:46,150
Deck也是很简单的类

280
00:14:46,170 --> 00:14:49,080
下面看另一个类 也就是PlayingCard

281
00:14:49,080 --> 00:14:50,650
我展示PlayingCard

282
00:14:50,650 --> 00:14:52,720
是为了跟你们讲解某一类的子类怎么写

283
00:14:52,720 --> 00:14:54,140
是为了跟你们讲解某一类的子类怎么写

284
00:14:54,140 --> 00:14:56,740
PlayingCard是Card的子类

285
00:14:56,740 --> 00:14:59,910
它专指扑克牌 例如红心K

286
00:14:59,910 --> 00:15:02,980
方片3这些牌

287
00:15:02,980 --> 00:15:08,580
PlayingCard具有特有属性 suit和rank

288
00:15:08,580 --> 00:15:11,840
rank也就是大小 3 4 J K这些

289
00:15:11,840 --> 00:15:14,260
suit是花色 红心 方片 梅花

290
00:15:14,260 --> 00:15:17,680
我将用单字符表示suit

291
00:15:17,680 --> 00:15:19,500
红心字符 梅花字符

292
00:15:19,500 --> 00:15:23,340
我好像展示过扑克牌中梅花字符的输入

293
00:15:23,340 --> 00:15:25,190
反正 你可以输入一个字符

294
00:15:25,190 --> 00:15:27,680
Unicode对这四种花色都有相应字符

295
00:15:27,700 --> 00:15:28,750
这是suit

296
00:15:28,750 --> 00:15:33,070
而rank是从0到13数字

297
00:15:33,070 --> 00:15:34,640
13表示K

298
00:15:34,640 --> 00:15:36,620
这些表示大小

299
00:15:36,620 --> 00:15:39,260
这就是公共API中的表示

300
00:15:39,280 --> 00:15:42,130
注意这里我用的是NSUInteger

301
00:15:42,130 --> 00:15:43,940
而不是unsigned int

302
00:15:43,940 --> 00:15:47,270
NSUInteger和unsigned int几乎是一回事

303
00:15:47,270 --> 00:15:50,120
NSUInteger唯一不同的是 它是一个typedef

304
00:15:50,120 --> 00:15:52,540
它在不同平台下可能略有不同

305
00:15:52,540 --> 00:15:56,520
例如新的iPhone 5S是64位处理器

306
00:15:56,520 --> 00:16:01,550
所以NSUInteger是64位无符号整型

307
00:16:01,550 --> 00:16:05,320
而之前的iPhone则只有32位

308
00:16:05,320 --> 00:16:08,680
这里有些不同

309
00:16:08,680 --> 00:16:10,430
很细枝末节

310
00:16:10,430 --> 00:16:12,470
我们可能要不了那么大的整数

311
00:16:12,470 --> 00:16:14,410
显然 这里只是从0到13

312
00:16:14,410 --> 00:16:15,800
问题不大

313
00:16:15,800 --> 00:16:19,030
要知道 我们用不到33位那么大的数

314
00:16:19,030 --> 00:16:21,630
要知道 我们用不到33位那么大的数

315
00:16:22,660 --> 00:16:25,110
注意到PlayingCard中

316
00:16:25,110 --> 00:16:28,320
我们重写了Card方法contents

317
00:16:28,320 --> 00:16:30,980
我们从父类继承了contents

318
00:16:30,980 --> 00:16:33,240
根据默认 contents仅仅返回

319
00:16:33,240 --> 00:16:36,310
contents属性的值

320
00:16:36,310 --> 00:16:39,550
但这里在PlayingCard中 我们将重写contents

321
00:16:39,550 --> 00:16:43,920
基于其它两个属性来实际计算contents

322
00:16:43,920 --> 00:16:46,630
我们重写contents的getter

323
00:16:46,630 --> 00:16:49,330
也就是这张扑克牌的内容

324
00:16:49,330 --> 00:16:53,540
让它总是返回一个计算自花色和大小的字符串

325
00:16:53,540 --> 00:16:54,680
明白吗

326
00:16:54,680 --> 00:16:58,330
我们从父类取存储contents的_contents

327
00:16:58,330 --> 00:17:00,240
然后忽略它

328
00:17:00,260 --> 00:17:02,770
因为我们重写了其getter

329
00:17:02,790 --> 00:17:06,940
这就是使用这些属性的一个很好理由

330
00:17:06,940 --> 00:17:10,060
因为我们可能有比单纯存储更好的做法

331
00:17:10,060 --> 00:17:13,350
这是可以进行实现的方式 我们可以返回一个字符串

332
00:17:13,350 --> 00:17:15,000
NSString stringWithFormat

333
00:17:15,000 --> 00:17:17,110
类似于printf一个字符串

334
00:17:17,110 --> 00:17:19,780
别太担心这里的语法

335
00:17:19,780 --> 00:17:22,950
printf字符串的格式是%d%@

336
00:17:22,950 --> 00:17:26,700
%d表示整数 %@表示一个对象

337
00:17:26,700 --> 00:17:28,420
一个对象的字符串表示

338
00:17:28,420 --> 00:17:31,030
然后我将使用rank和suit

339
00:17:31,030 --> 00:17:32,840
这是处理contents的一种方式

340
00:17:32,840 --> 00:17:35,380
这不是一个很好的方式 因为

341
00:17:35,380 --> 00:17:38,570
例如红心J是11红心

342
00:17:38,570 --> 00:17:42,870
至少J我们想用J 而不是11

343
00:17:42,870 --> 00:17:44,320
这个方式不怎么好

344
00:17:44,320 --> 00:17:47,450
所以我想让一个数组中

345
00:17:47,450 --> 00:17:51,310
有所有正确的东西 比如A表示1

346
00:17:51,310 --> 00:17:55,380
J表示11 Q表示12 K表示13

347
00:17:55,380 --> 00:17:57,750
这里我创建一个数组

348
00:17:57,750 --> 00:18:01,190
中间我需要删去 让它能够显示出来

349
00:18:01,190 --> 00:18:03,210
我还让0为问号

350
00:18:03,210 --> 00:18:07,220
如果rank为0 它会是问号 如未设

351
00:18:07,220 --> 00:18:09,570
大小没有设定

352
00:18:09,570 --> 00:18:12,220
然后我返回一个字符串

353
00:18:12,220 --> 00:18:15,290
它会取出那个数组中的rank

354
00:18:15,310 --> 00:18:18,340
然后追加表示suit的字符串

355
00:18:18,340 --> 00:18:20,730
红心 梅花 方片这些

356
00:18:20,730 --> 00:18:22,080
都明白吗

357
00:18:22,080 --> 00:18:25,010
给你们讲这些是为了让你们明白

358
00:18:25,010 --> 00:18:31,750
如何无缝混合数组符号 消息发送所有这些东西

359
00:18:31,750 --> 00:18:38,920
这时contents会返回J红心 或5方块这些

360
00:18:38,920 --> 00:18:41,960
注意到rank很棒

361
00:18:41,960 --> 00:18:45,780
因为在我们说new PlayingCard时rank会为0

362
00:18:45,780 --> 00:18:48,000
所有实例变量为0 所以rank为0

363
00:18:48,000 --> 00:18:49,360
我们得到这个问号

364
00:18:49,360 --> 00:18:51,720
但suit开始时是nil

365
00:18:51,720 --> 00:18:56,790
如果suit在未设或为nil时也能返回问号就好了

366
00:18:56,790 --> 00:18:59,350
所以这里我重写suit的getter如下

367
00:18:59,350 --> 00:19:04,320
如果suit是nil 那么返回问号

368
00:19:04,320 --> 00:19:07,660
否则当suit不是nil时 那么返回suit的实际值

369
00:19:07,660 --> 00:19:10,780
我是在保护我的API

370
00:19:10,780 --> 00:19:14,490
保证我在rank或suit未设时 总是返回问号

371
00:19:14,500 --> 00:19:15,010
请讲

372
00:19:15,030 --> 00:19:16,750
[学生提问 声音不清]

373
00:19:18,750 --> 00:19:22,650
Paul Hegarty：抱歉 你是说的红色@号吗

374
00:19:22,650 --> 00:19:26,540
对 我们在Card中应该没碰到过这个

375
00:19:26,540 --> 00:19:28,050
也可能碰到过

376
00:19:28,090 --> 00:19:28,940
记得吧

377
00:19:28,940 --> 00:19:32,790
我们这门课碰到的所有字符串都是字符串对象

378
00:19:32,790 --> 00:19:34,700
而非const char

379
00:19:34,700 --> 00:19:36,260
它们是字符串对象

380
00:19:36,260 --> 00:19:39,060
如果你在字符串前加一个@

381
00:19:39,060 --> 00:19:42,000
编译器会为你创建字符串对象

382
00:19:42,000 --> 00:19:45,350
这些@的作用是让所有字符串为字符串对象

383
00:19:45,350 --> 00:19:47,900
因为我们不能将const char *放到NSArray中

384
00:19:47,900 --> 00:19:51,270
NSArray中只能是对象 所以只能用NSString这些

385
00:19:51,270 --> 00:19:53,670
这些才是对象 问得很好

386
00:19:53,670 --> 00:19:55,510
请讲

387
00:19:55,510 --> 00:20:00,540
[学生提问 声音不清]

388
00:20:09,540 --> 00:20:11,820
Paul Hegarty：对 好 问得很好

389
00:20:11,820 --> 00:20:16,180
如果我们用了getter=符号

390
00:20:16,180 --> 00:20:18,910
就像isChosen和isMatched那样 来改名

391
00:20:18,910 --> 00:20:21,820
那么重写时 我们就需要使用新名

392
00:20:21,820 --> 00:20:25,170
我们就需要用is什么 这里不需要那样

393
00:20:25,170 --> 00:20:28,960
但我知道你说的是什么 对 你需要用新名

394
00:20:28,960 --> 00:20:30,230
问得很好

395
00:20:30,230 --> 00:20:32,290
这方面还有问题吗

396
00:20:32,290 --> 00:20:37,850
好 这能帮助suit在为nil或未设时总是返回问号

397
00:20:37,850 --> 00:20:42,540
我们再加一层保护 以防有人错误设置了suit

398
00:20:42,540 --> 00:20:46,530
我们将只让人使用属性的公共setter来设置suit

399
00:20:46,530 --> 00:20:48,460
我们将只让人使用属性的公共setter来设置suit

400
00:20:48,460 --> 00:20:53,200
suit将只被允许设置为四种花色之一

401
00:20:53,200 --> 00:20:57,640
我简单在这里创建了四种花色的数组

402
00:20:57,640 --> 00:20:59,700
然后用到方法containsObject

403
00:20:59,700 --> 00:21:04,550
从这里看 你们觉得containsObject是什么

404
00:21:04,550 --> 00:21:05,220
谁讲讲

405
00:21:05,230 --> 00:21:08,310
[学生提问 声音不清]

406
00:21:08,330 --> 00:21:10,280
Paul Hegarty：这是一种NSArray方法 正确

407
00:21:10,280 --> 00:21:12,240
containsObject是一种NSArray方法

408
00:21:12,240 --> 00:21:15,030
我将它送往我刚创建的数组

409
00:21:15,030 --> 00:21:18,440
包含红心 方片 黑桃 梅花的那个数组

410
00:21:18,440 --> 00:21:20,750
我问 你是否包含这个字符串

411
00:21:20,750 --> 00:21:23,760
containsObject会使用isEqual方法对比

412
00:21:23,760 --> 00:21:27,290
这个字符串的内容和所有这些

413
00:21:27,290 --> 00:21:30,600
它会将suit作为参数用isEqual一一对比四个字符串

414
00:21:30,600 --> 00:21:32,760
不是isEqualToString 而是isEqual

415
00:21:32,760 --> 00:21:35,570
isEqual是由isEqualToString来实现的

416
00:21:35,570 --> 00:21:37,550
如果参数是字符串的话

417
00:21:37,550 --> 00:21:39,920
这里讲了太多无关紧要的细节

418
00:21:39,920 --> 00:21:41,390
这里显然能起到保护作用

419
00:21:41,390 --> 00:21:44,790
这样内部花色存储变量就无法设置为

420
00:21:44,790 --> 00:21:48,510
这四种花色以外任何东西了 请讲

421
00:21:48,510 --> 00:21:58,940
[学生提问 声音不清]

422
00:21:58,940 --> 00:22:01,990
Paul Hegarty：问得很棒 你们理解得真不错

423
00:22:01,990 --> 00:22:04,830
每次我使用@[这样的符号

424
00:22:04,830 --> 00:22:06,380
如这里蓝色的部分

425
00:22:06,380 --> 00:22:10,170
这实际是在创建新数组 每次都是这样

426
00:22:10,170 --> 00:22:13,080
因为我讲过 @[…]

427
00:22:13,080 --> 00:22:15,790
及所有这些数组东西 只是在调用方法

428
00:22:15,790 --> 00:22:19,200
这就像是调用数组 对象这些的alloc init方法

429
00:22:19,200 --> 00:22:20,810
这就像是调用数组 对象这些的alloc init方法

430
00:22:20,810 --> 00:22:21,830
这是在创建

431
00:22:21,830 --> 00:22:25,250
将它移出来也很好 我们会这样做

432
00:22:25,250 --> 00:22:28,380
不过 注意不要预优化

433
00:22:28,380 --> 00:22:29,870
它可能不会有任何不同

434
00:22:29,870 --> 00:22:31,810
移出来只是为了让代码更简洁

435
00:22:31,810 --> 00:22:34,680
移出来不是出于任何性能考虑 请讲

436
00:22:34,710 --> 00:22:38,010
[学生提问 声音不清]

437
00:22:38,010 --> 00:22:39,180
Paul Hegarty：问题是

438
00:22:39,180 --> 00:22:41,430
LLVM会处理这个 为你优化好吗

439
00:22:41,430 --> 00:22:44,000
它可能不会 因为这是一个消息发送

440
00:22:44,000 --> 00:22:45,900
它不确定这样有没有副作用

441
00:22:45,900 --> 00:22:48,990
无论如何 我们这样做是为了让代码更简洁

442
00:22:48,990 --> 00:22:51,540
性能在这里可以忽略

443
00:22:51,540 --> 00:22:54,240
我们讲的是UI 这相差很远

444
00:22:54,240 --> 00:22:56,900
在这之前 还有一点要讲

445
00:22:56,900 --> 00:23:00,270
由于我们现在已经实现了suit的setter和getter

446
00:23:00,270 --> 00:23:04,440
这就必须处理@synthesize了

447
00:23:04,440 --> 00:23:08,130
换言之 一般我们不需要处理@synthesize

448
00:23:08,130 --> 00:23:09,070
它会自动生成

449
00:23:09,070 --> 00:23:12,670
但当同时实现setter和getter时 就需要处理了

450
00:23:12,670 --> 00:23:15,870
这很容易 因为形式总是一样

451
00:23:15,870 --> 00:23:18,610
但容易也需要做

452
00:23:18,610 --> 00:23:21,300
这里 做我刚才讲的事情

453
00:23:21,300 --> 00:23:26,820
我们将花色的数组放入到另一个方法中

454
00:23:26,820 --> 00:23:29,870
我说过 这样做不会有任何性能好处

455
00:23:29,870 --> 00:23:32,020
这样做只是代码更简洁一些

456
00:23:32,020 --> 00:23:35,170
因为每次调用validSuits时还是会重新创建

457
00:23:35,170 --> 00:23:37,000
我可以使用一个静态变量

458
00:23:37,000 --> 00:23:39,320
这是C 我可以存储这个数组

459
00:23:39,320 --> 00:23:40,710
开始是nil

460
00:23:40,710 --> 00:23:44,240
如果是nil 设置到这个数组 然后它只会创建一次

461
00:23:44,240 --> 00:23:45,470
但要小心

462
00:23:45,470 --> 00:23:47,200
还是那句话 代码简洁性

463
00:23:47,200 --> 00:23:49,840
还有易理解性 比这样的性能重要十倍

464
00:23:49,840 --> 00:23:52,850
只要你不是在循环中上千次地调用validSuits

465
00:23:52,850 --> 00:23:54,420
这个影响都很小

466
00:23:54,420 --> 00:23:57,790
我把它往上移动到一个不同方法中

467
00:23:57,790 --> 00:24:00,720
但这个方法有些不同

468
00:24:00,720 --> 00:24:02,500
注意到它前面是个加号

469
00:24:02,500 --> 00:24:06,080
最开始是加号 而不是减号 看到了吗

470
00:24:06,080 --> 00:24:08,380
+ (NSArray *)validSuits

471
00:24:08,380 --> 00:24:11,090
+方法是一个类方法

472
00:24:11,090 --> 00:24:17,130
这意味着你将它发送给类 而不是对象实例

473
00:24:17,850 --> 00:24:19,590
因为不是发送给一个实例

474
00:24:19,590 --> 00:24:23,020
所以你不能使用任何实例变量

475
00:24:23,020 --> 00:24:25,250
你只能做一些通用性的事情

476
00:24:25,250 --> 00:24:30,140
实际上+方法 类方法只用于两种情况

477
00:24:30,140 --> 00:24:31,860
创建事物

478
00:24:31,860 --> 00:24:36,010
例如上一张幻灯片中我们有带格式的字符串时

479
00:24:36,010 --> 00:24:38,910
这是类方法 为我们创建一个字符串

480
00:24:38,910 --> 00:24:41,880
然后就是这样的工具方法

481
00:24:41,880 --> 00:24:43,930
例如返回常数

482
00:24:43,930 --> 00:24:47,210
还有其它我们的类需要工具方法的情况

483
00:24:47,210 --> 00:24:48,260
这是一个例子

484
00:24:48,260 --> 00:24:50,250
再看调用类方法的方式

485
00:24:50,250 --> 00:24:52,160
你们已经看过我调用了一些

486
00:24:52,160 --> 00:24:55,250
这里就是在调用它 首先是开方括号

487
00:24:55,250 --> 00:24:58,100
然后是类名 然后是方法名

488
00:24:58,100 --> 00:25:00,540
同其它方法一样 它也可以有参数

489
00:25:00,560 --> 00:25:02,910
大家都能理解吗

490
00:25:03,690 --> 00:25:05,630
好 回头几张幻灯片

491
00:25:05,630 --> 00:25:09,140
你会看到 [NSString 带格式的字符串

492
00:25:09,140 --> 00:25:12,030
完全相同的语法

493
00:25:12,030 --> 00:25:13,720
这就是类方法的样子

494
00:25:13,720 --> 00:25:19,350
用于创建事物 以及用作工具方法

495
00:25:19,350 --> 00:25:20,460
我们会谈到

496
00:25:20,460 --> 00:25:23,880
用类方法创建和用alloc init创建的不同

497
00:25:23,880 --> 00:25:25,660
不久后我就会讲到

498
00:25:25,660 --> 00:25:28,970
我还让validSuits是公共的

499
00:25:28,970 --> 00:25:33,360
这样PlayingCard的使用者就知道validSuits是什么

500
00:25:33,360 --> 00:25:35,290
我只需要把它放到头文件中

501
00:25:35,290 --> 00:25:36,770
现在就是公共的了

502
00:25:36,770 --> 00:25:41,420
这里对扑克牌大小字符串也做相同的事情

503
00:25:41,420 --> 00:25:45,790
我将把上面的大小字符串

504
00:25:45,790 --> 00:25:48,900
放入到一个类方法中

505
00:25:48,900 --> 00:25:52,280
还是那句话 这是为了可读性 而非性能

506
00:25:52,280 --> 00:25:56,680
因为每次调用rankStrings 这都会重新创建

507
00:25:56,680 --> 00:26:00,360
然后 我在这上面调用它

508
00:26:00,360 --> 00:26:03,700
我不打算让rankStrings本身成为公共的

509
00:26:03,700 --> 00:26:06,880
但我打算让另一个类方法maxRank成为公共的

510
00:26:06,880 --> 00:26:09,710
这个方法考虑的是rankStrings中有多少字符串

511
00:26:09,710 --> 00:26:13,080
我将把这作为公共方法返回

512
00:26:13,080 --> 00:26:16,510
这里有三个类方法 让你们钻研

513
00:26:16,510 --> 00:26:19,880
两个是公共的 一个不是

514
00:26:19,880 --> 00:26:22,110
这些都是工具方法

515
00:26:22,110 --> 00:26:26,320
我们没有在任何这些方法中访问任何实例变量

516
00:26:26,320 --> 00:26:28,700
我讲这些的唯一原因

517
00:26:28,700 --> 00:26:31,650
就是让你们了解类方法是怎样的

518
00:26:33,170 --> 00:26:35,880
我们还可以重写rank的setter

519
00:26:35,880 --> 00:26:38,210
来保证这里不允许

520
00:26:38,210 --> 00:26:40,970
设置错误的大小 例如15

521
00:26:40,970 --> 00:26:42,320
没有大小为15的牌

522
00:26:42,320 --> 00:26:45,820
我们需要确保大小小于最大大小

523
00:26:45,820 --> 00:26:47,610
刚那个工具方法做了这个

524
00:26:47,610 --> 00:26:50,930
大家都理解了吗

525
00:26:50,930 --> 00:26:53,030
这里只是参考材料

526
00:26:53,030 --> 00:26:56,500
你们的幻灯片中 有我讲的所有这些注释

527
00:26:56,500 --> 00:26:59,210
你们可以回头看幻灯片当作复习

528
00:26:59,210 --> 00:27:01,950
关于这些NSArray 语法

529
00:27:01,950 --> 00:27:04,490
这些类方法 等等

530
00:27:04,490 --> 00:27:08,510
最后我们要看的是init方法

531
00:27:08,510 --> 00:27:12,080
这里我们还有一个类叫PlayingCardDeck

532
00:27:12,080 --> 00:27:15,850
PlayingCardDeck是Deck的一个子类

533
00:27:15,850 --> 00:27:18,970
它没有公共API

534
00:27:18,970 --> 00:27:25,340
它将只是重写一个间接继承自NSObject的方法

535
00:27:25,340 --> 00:27:28,150
NSObject通过Deck 这里没动它

536
00:27:28,150 --> 00:27:29,710
直到PlayingCardDeck

537
00:27:29,730 --> 00:27:32,110
这个方法叫作init

538
00:27:32,110 --> 00:27:37,910
这个init同之前我们创建那个可变数组时所说的

539
00:27:37,910 --> 00:27:41,280
[NSMutableArray alloc] init中的init一样

540
00:27:41,280 --> 00:27:45,000
有人需要调用这个PlayingCardDeck init方法

541
00:27:45,000 --> 00:27:47,340
也就是你们 在作业中

542
00:27:47,340 --> 00:27:50,440
会通过PlayingCardDeck alloc 调用这个

543
00:27:50,440 --> 00:27:52,780
然后外面再写init

544
00:27:52,780 --> 00:27:55,380
这就是创建一个PlayingCardDeck的方式

545
00:27:55,380 --> 00:27:59,230
这就是我们创建大多数对象实例的方式 并非所有

546
00:27:59,230 --> 00:28:02,140
有时我们会使用NSString 带格式的字符串

547
00:28:02,140 --> 00:28:04,070
但大多数时候 大于一半的时候

548
00:28:04,070 --> 00:28:06,640
我们会用alloc 然后外面用init

549
00:28:06,640 --> 00:28:08,040
听好

550
00:28:08,040 --> 00:28:13,030
除了外面有init时 永远别调用alloc那些东西

551
00:28:13,030 --> 00:28:14,350
不要犯忌

552
00:28:14,350 --> 00:28:18,520
不初始化就分配对象在堆中毫无意义

553
00:28:18,520 --> 00:28:19,960
只有嵌套才对

554
00:28:19,960 --> 00:28:25,220
反之 除了里面有alloc 外面也不要调用init

555
00:28:25,220 --> 00:28:27,790
而且一定不要超过一次地调用init

556
00:28:27,790 --> 00:28:31,360
如果你按照我说的 只在里面有alloc时才调用

557
00:28:31,360 --> 00:28:32,870
调用就不可能超过一次

558
00:28:32,870 --> 00:28:36,170
init没有说你能重新init的

559
00:28:36,170 --> 00:28:39,580
init只能发生一次 紧接alloc之后 这就完了

560
00:28:39,580 --> 00:28:43,490
这是一条硬性规定 永远不要违反

561
00:28:43,490 --> 00:28:45,060
这里我讲了

562
00:28:45,060 --> 00:28:46,110
别忘记

563
00:28:46,630 --> 00:28:50,920
好 我们来看看这个init方法的怪异返回类型

564
00:28:50,920 --> 00:28:55,410
你也许会以为init方法会返回一个PlayingCardDeck

565
00:28:55,430 --> 00:28:58,900
因为它在初始化 也许会返回它自身

566
00:28:58,900 --> 00:29:02,530
实际上 init确实总返回self

567
00:29:02,530 --> 00:29:04,760
init总会返回自身

568
00:29:04,760 --> 00:29:07,030
这里比较怪异 我会讲到

569
00:29:07,030 --> 00:29:10,320
方便起见 它总返回self 让你能够写

570
00:29:10,320 --> 00:29:14,320
[PlayingCardDeck alloc] init这些 发送一条消息

571
00:29:14,320 --> 00:29:17,330
它返回self是很方便的

572
00:29:17,330 --> 00:29:21,280
但它的返回类型不能是PlayingCardDeck

573
00:29:21,300 --> 00:29:23,480
因为这些它继承于NSObject

574
00:29:23,480 --> 00:29:28,480
而NSObject已经将其定义为NSObject

575
00:29:28,480 --> 00:29:30,520
明白吗 所以说有些奇怪

576
00:29:30,520 --> 00:29:32,790
你继承了一个方法 其返回值

577
00:29:32,790 --> 00:29:36,870
需要在每次重写时发生变化

578
00:29:36,870 --> 00:29:40,370
于是人们发明了这个新东西 这是iOS7的新属性

579
00:29:40,390 --> 00:29:42,010
叫实例类型

580
00:29:42,010 --> 00:29:43,940
实例类型也就是说

581
00:29:43,940 --> 00:29:49,490
这会返回一个对象 具有相同类类型

582
00:29:49,490 --> 00:29:52,180
同这条消息要发送到的对象一样

583
00:29:52,180 --> 00:29:54,750
这对init很有意义

584
00:29:54,750 --> 00:29:58,140
这门课上 只有这里会用到这个

585
00:29:58,140 --> 00:30:00,800
听不懂我刚讲的这些不要紧 我在幻灯片中也讲了

586
00:30:00,800 --> 00:30:02,050
听不懂我刚讲的这些不要紧 我在幻灯片中也讲了

587
00:30:02,050 --> 00:30:04,080
你只需知道 凡是初始化时

588
00:30:04,080 --> 00:30:07,680
它都会返回实例类型作为返回类型

589
00:30:07,680 --> 00:30:10,020
你将总是返回self

590
00:30:11,670 --> 00:30:14,490
还有一点 也是记住就行

591
00:30:14,490 --> 00:30:18,280
后面这几行代码也非常奇怪

592
00:30:18,280 --> 00:30:21,880
第一行 self = [super init] 这很奇怪

593
00:30:21,880 --> 00:30:23,110
这非常奇怪

594
00:30:23,110 --> 00:30:26,890
Objective-C中将什么东西复制给self

595
00:30:26,890 --> 00:30:30,300
永远不要这样做 唯独除了init里

596
00:30:30,300 --> 00:30:35,880
对self赋值 调用父类初始化器

597
00:30:35,880 --> 00:30:37,950
于是父类会被初始化

598
00:30:37,950 --> 00:30:40,990
为什么将结果赋值给self呢

599
00:30:40,990 --> 00:30:42,990
可以说是古老的历史残留

600
00:30:42,990 --> 00:30:45,440
因为人们这样做了很长时间

601
00:30:45,440 --> 00:30:48,850
一般 我们会检验父类init的返回

602
00:30:48,850 --> 00:30:50,670
确保它正确被初始化

603
00:30:50,670 --> 00:30:55,080
因为任何初始化器无法初始化自身的时候

604
00:30:55,080 --> 00:30:56,990
它应返回nil

605
00:30:56,990 --> 00:31:00,310
这让所有人知道 你的任意子类

606
00:31:00,310 --> 00:31:02,670
或任何人尝试分配和初始化你

607
00:31:02,670 --> 00:31:05,090
你无法创建一个结构良好的对象

608
00:31:05,090 --> 00:31:07,540
你可以看到 这个代码很奇怪

609
00:31:07,540 --> 00:31:09,560
self = [super init] 然后if (self)

610
00:31:09,560 --> 00:31:12,500
我将初始化自身 返回self

611
00:31:12,500 --> 00:31:16,800
这将能确保 当我的父类在我调用init时

612
00:31:16,800 --> 00:31:21,370
如果无法初始化自身 我就不用尝试初始化我自己

613
00:31:21,370 --> 00:31:24,270
照做就行了

614
00:31:24,270 --> 00:31:27,730
不懂不要紧 照做就行了

615
00:31:27,730 --> 00:31:31,140
有一点我要讲明 init没有参数

616
00:31:31,140 --> 00:31:33,830
让初始化器有参数是完全有可能的

617
00:31:33,830 --> 00:31:36,940
因为有时你需要参数来恰当地初始化一个类

618
00:31:36,940 --> 00:31:40,050
周一我会进一步讲到这个

619
00:31:40,050 --> 00:31:43,050
今天只讲解init的梗概

620
00:31:43,050 --> 00:31:45,110
这个init需要做什么

621
00:31:45,110 --> 00:31:46,320
我需要怎样做

622
00:31:46,320 --> 00:31:48,560
才能得到初始化良好的PlayingCardDeck

623
00:31:48,560 --> 00:31:53,300
PlayingCardDeck有52张牌 一样一张

624
00:31:53,300 --> 00:31:57,750
梅花K 方片3 总共52张

625
00:31:57,750 --> 00:32:03,160
我只需要遍历所有花色 遍历所有大小

626
00:32:03,160 --> 00:32:06,240
创建一张牌 然后添加到我自身

627
00:32:06,240 --> 00:32:09,810
这里我遍历花色 遍历大小

628
00:32:09,810 --> 00:32:12,380
大家都明白吗

629
00:32:12,380 --> 00:32:16,020
然后我将导入PlayingCard

630
00:32:16,020 --> 00:32:18,570
因为我要创建一张PlayingCard

631
00:32:18,580 --> 00:32:20,520
[PlayingCard alloc] init

632
00:32:20,520 --> 00:32:23,830
然后我要设置这张牌的大小 设置花色

633
00:32:23,830 --> 00:32:28,400
rank和suit是这里的迭代变量

634
00:32:28,400 --> 00:32:31,050
然后我把它加到我自身

635
00:32:31,050 --> 00:32:35,500
我是一个Deck 这很好

636
00:32:35,500 --> 00:32:39,360
大家都明白这段代码吗

637
00:32:39,360 --> 00:32:42,930
现在我就得到一个结构良好的PlayingCardDeck

638
00:32:42,930 --> 00:32:45,390
可以被用于随机抽取纸牌 等等动作

639
00:32:45,390 --> 00:32:47,450
这将是你们的作业内容

640
00:32:48,500 --> 00:32:51,660
实际上 你们的作业是将所有这四个类补全

641
00:32:51,660 --> 00:32:54,570
我希望你们体会到录入类 键入内容

642
00:32:54,570 --> 00:32:59,780
观看Xcode抱怨你的错误 等等

643
00:32:59,780 --> 00:33:03,520
然后你们将会使用PlayingCardDeck和PlayingCard

644
00:33:03,520 --> 00:33:06,220
PlayingCardDeck和Card是你们作业中

645
00:33:06,220 --> 00:33:08,400
主要要用到的两个类

646
00:33:09,390 --> 00:33:11,880
对此有问题吗

647
00:33:11,880 --> 00:33:14,220
幻灯片就到这里

648
00:33:14,220 --> 00:33:16,970
下面我将给出一个大而古老的demo

649
00:33:16,970 --> 00:33:21,290
这个demo将综合你们到目前为止看到过的一切

650
00:33:21,290 --> 00:33:23,680
尤其是我们谈过的MVC内容

651
00:33:23,680 --> 00:33:26,940
例如目标动作 设置目标 发射动作

652
00:33:26,940 --> 00:33:30,070
还有绿色箭头的outlet 指向相反方向

653
00:33:30,070 --> 00:33:34,220
我们会展示这些在Xcode中是怎样

654
00:33:34,220 --> 00:33:37,190
我问你们谁用过Xcode时

655
00:33:37,190 --> 00:33:39,240
几乎所有人都举手了

656
00:33:39,240 --> 00:33:42,160
所以我不打算讲解Xcode中的所有按钮

657
00:33:42,160 --> 00:33:44,680
我将很快略过这些

658
00:33:44,680 --> 00:33:49,750
没有用过Xcode的人 课程幻灯片中有详细介绍

659
00:33:49,750 --> 00:33:51,440
你们可以看看

660
00:33:51,440 --> 00:33:54,190
你可以跟随课程幻灯片一起看

661
00:33:54,190 --> 00:33:57,070
不过我的demo同幻灯片中不完全一样

662
00:33:57,070 --> 00:34:00,860
幻灯片要多于我这里40分钟可以讲的内容

663
00:34:00,860 --> 00:34:03,480
而且它也是参考材料

664
00:34:03,480 --> 00:34:07,330
如果我在demo中讲的东西让你觉得

665
00:34:07,330 --> 00:34:08,430
哦 他怎么做的

666
00:34:08,430 --> 00:34:10,700
你可以去查幻灯片 它会告诉你

667
00:34:10,700 --> 00:34:13,030
所以不要觉得 我要逐一记下

668
00:34:13,030 --> 00:34:15,630
他在这40分钟里面要讲的每一个细节

669
00:34:15,630 --> 00:34:16,680
不用这样

670
00:34:16,680 --> 00:34:19,240
你可以边看幻灯片边看demo

671
00:34:19,240 --> 00:34:23,500
也可以关掉笔记本 只看我讲 然后理解

672
00:34:23,520 --> 00:34:26,120
因为你们作业中需要再现

673
00:34:26,120 --> 00:34:28,400
我这40分钟所要讲的内容

674
00:34:28,400 --> 00:34:31,340
而幻灯片中会一步步告诉你怎么做

675
00:34:31,340 --> 00:34:35,300
现在你们什么都不需要做 只需要仔细听我讲

676
00:34:35,300 --> 00:34:37,690
感受一下发生了什么

677
00:34:37,690 --> 00:34:42,960
然后当你要坐下来做时 还有幻灯片可查

678
00:34:42,960 --> 00:34:46,220
下周 我将更详细讲到Objective-C

679
00:34:46,220 --> 00:34:47,790
详细回答NSNumber等同学们提出的一些问题

680
00:34:47,790 --> 00:34:50,410
详细回答NSNumber等同学们提出的一些问题

681
00:34:50,410 --> 00:34:54,900
而且我会讲到Objective-C中的一些特定内容

682
00:34:54,910 --> 00:34:57,740
例如动态绑定 协议

683
00:34:57,740 --> 00:35:00,030
这些东西一般在其它语言中是没有的

684
00:35:00,030 --> 00:35:02,840
这些东西一般在其它语言中是没有的

685
00:35:02,840 --> 00:35:04,060
我会讲给你们

686
00:35:04,060 --> 00:35:07,440
在下周末最后 等你们熟悉了Objective-C

687
00:35:07,440 --> 00:35:10,170
熟悉了Xcode

688
00:35:10,170 --> 00:35:13,770
之后我们就可以开始真正做点什么了

689
00:35:13,770 --> 00:35:17,260
进行强大的iOS7编程

690
00:35:18,080 --> 00:35:20,570
好 开始demo

691
00:35:23,140 --> 00:35:25,790
demo我将用Xcode来进行

692
00:35:25,790 --> 00:35:27,750
启动Xcode

693
00:35:27,750 --> 00:35:32,490
Xcode需要到Mac app商店

694
00:35:32,490 --> 00:35:34,930
也就是这个

695
00:35:34,930 --> 00:35:37,670
用Mac登陆app商店 然后搜索Xcode

696
00:35:37,670 --> 00:35:40,680
它是免费的 下载运行即可 很简单

697
00:35:40,700 --> 00:35:44,850
第一次使用时它的界面是这样的

698
00:35:44,850 --> 00:35:46,220
这是启动画面

699
00:35:46,240 --> 00:35:50,090
随着学期的进行 这里将充满你所做的各种项目

700
00:35:50,090 --> 00:35:52,250
用过Xcode的人应该会很习惯

701
00:35:52,250 --> 00:35:55,020
今天我们要创建一个新项目

702
00:35:55,020 --> 00:35:59,510
你可以到源控制中查看已有项目

703
00:35:59,510 --> 00:36:00,850
你也可以创建新的

704
00:36:00,870 --> 00:36:02,280
我们要创建新的

705
00:36:02,280 --> 00:36:06,830
创建新项目时 它会尝试给我们一点帮助

706
00:36:06,850 --> 00:36:10,480
它会给我们提供不同应用的模板

707
00:36:10,480 --> 00:36:12,810
比如openGL游戏

708
00:36:12,830 --> 00:36:16,490
它会为你创建某种框架

709
00:36:16,490 --> 00:36:18,220
Master-Detail应用

710
00:36:18,220 --> 00:36:19,740
这是我们这学期晚些时候要做的

711
00:36:19,740 --> 00:36:21,510
只是我们会自己写代码

712
00:36:21,510 --> 00:36:23,460
我们不会用这个模板

713
00:36:23,460 --> 00:36:29,250
这里的单视图应用就是一单个MVC

714
00:36:29,260 --> 00:36:32,550
课上我们的所有应用都将由此开始

715
00:36:32,550 --> 00:36:35,640
首先是单个MVC 之后再添加更多MVC

716
00:36:35,640 --> 00:36:39,480
这是基本的单MVC app

717
00:36:39,500 --> 00:36:41,200
点击这个

718
00:36:41,220 --> 00:36:43,600
这里它会要求一些相关信息

719
00:36:43,600 --> 00:36:45,810
例如 你想给该app起什么名

720
00:36:45,810 --> 00:36:49,860
这是一个扑克牌匹配游戏 我打算叫它Machismo

721
00:36:50,720 --> 00:36:53,680
这是我们app的名称 起个有趣的名字

722
00:36:53,680 --> 00:36:55,750
组织名可以任选

723
00:36:55,750 --> 00:36:59,990
它会显示在你创建的所有类的头文件之中

724
00:36:59,990 --> 00:37:01,740
我这里写斯坦福大学

725
00:37:01,740 --> 00:37:05,610
你们也可以写Bob's Game House 什么都行

726
00:37:05,610 --> 00:37:09,500
这个标识符对你需要是唯一的

727
00:37:09,500 --> 00:37:13,310
我的是edu.Stanford.cs193p.instructor

728
00:37:13,310 --> 00:37:16,790
你的可以是edu.Stanford.cs193p.你的SUNet ID

729
00:37:16,810 --> 00:37:19,280
这肯定是独一无二的

730
00:37:19,280 --> 00:37:23,330
这些反的DNS能给出很好的唯一名称

731
00:37:23,330 --> 00:37:26,030
它还会为这个app创建一个唯一名称

732
00:37:26,030 --> 00:37:28,310
通过将这个和名称结合

733
00:37:28,310 --> 00:37:31,450
如这里的包标识符

734
00:37:31,450 --> 00:37:32,980
然后这个类前缀

735
00:37:32,980 --> 00:37:38,400
这一模板将为我们创建一个视图和一个控制器

736
00:37:38,400 --> 00:37:42,170
这里说的是 你希望你的控制器类名为什么

737
00:37:42,170 --> 00:37:45,640
默认情况下 它会被叫作ViewController

738
00:37:45,640 --> 00:37:49,120
但如果这里你键入诸如CardGame

739
00:37:49,120 --> 00:37:51,440
它就会叫作CardGameViewController

740
00:37:51,440 --> 00:37:53,150
这个名字对我们更好

741
00:37:53,150 --> 00:37:55,500
它为你创建这个控制器时 会加上这个前缀

742
00:37:55,500 --> 00:37:57,330
它为你创建这个控制器时 会加上这个前缀

743
00:37:57,350 --> 00:38:00,180
最后这里我们可以让创建的app

744
00:38:00,180 --> 00:38:02,550
只适用于iPad 只适用于iPhone

745
00:38:02,550 --> 00:38:05,450
或能够运行在两个平台上的通用app

746
00:38:05,450 --> 00:38:10,180
创建通用app时 UI仍然需要单独设计

747
00:38:10,180 --> 00:38:13,460
因为屏幕规则更多时 你需要设计不同的UI

748
00:38:13,460 --> 00:38:15,550
iPad不只是一个大iPhone

749
00:38:15,550 --> 00:38:18,820
有更多屏幕空间时 你可以做更多事情

750
00:38:18,820 --> 00:38:23,060
但你仍然可以让很多MVC共享

751
00:38:23,060 --> 00:38:26,610
因为iPad中在MVC中可能有一些小的子区域

752
00:38:26,610 --> 00:38:29,520
同iPhone完全相同 或非常非常相似

753
00:38:29,520 --> 00:38:34,420
iOS7中完全支持让创建的app同时针对两大平台

754
00:38:34,420 --> 00:38:38,290
也有很棒的工具让你能单独创建两个UI

755
00:38:38,290 --> 00:38:40,470
并共享下面的所有MVC

756
00:38:40,470 --> 00:38:42,590
这里我们只针对iPhone编程

757
00:38:42,590 --> 00:38:46,510
因为这样屏幕更小 而我只有这么大的屏幕空间

758
00:38:46,510 --> 00:38:52,150
[学生提问 声音不清]

759
00:38:52,150 --> 00:38:54,390
Paul Hegarty：问题是 我在iPad上能否

760
00:38:54,390 --> 00:38:56,700
运行只针对iPhone的app 能

761
00:38:56,700 --> 00:39:00,880
这里可以说有一个仿真模式

762
00:39:00,880 --> 00:39:04,200
将一个大的iPhone状东西放到iPad屏幕上

763
00:39:04,200 --> 00:39:05,890
这里我选iPhone

764
00:39:05,890 --> 00:39:07,570
然后点下一步

765
00:39:07,570 --> 00:39:10,240
下一步它想知道 "你要把这个项目放在哪"

766
00:39:10,240 --> 00:39:13,660
我强烈推荐放在主目录中

767
00:39:13,660 --> 00:39:17,120
一个叫作developer(开发者)的目录内

768
00:39:17,120 --> 00:39:19,670
除非你要使用不同的类

769
00:39:19,670 --> 00:39:23,060
也许你有cs193p在主目录下 然后其它类

770
00:39:23,060 --> 00:39:25,340
总之 把它放到主目录中

771
00:39:25,350 --> 00:39:28,050
不要放到根或类似的地方

772
00:39:28,050 --> 00:39:31,350
这在原来导致过问题

773
00:39:31,350 --> 00:39:34,680
放在这里很好 这是我的主目录 这是cs193p

774
00:39:34,680 --> 00:39:37,030
主目录 developer

775
00:39:37,030 --> 00:39:39,510
我将把它放到这里 这里还没有任何项目

776
00:39:39,510 --> 00:39:43,050
这下面有一个小内容 叫源控制 我会讲到这个

777
00:39:43,050 --> 00:39:45,680
它很好地整合到了Xcode中

778
00:39:45,680 --> 00:39:47,070
不过今天我不打算讲

779
00:39:47,070 --> 00:39:49,420
这个不选

780
00:39:51,580 --> 00:39:53,780
这是我们的新项目

781
00:39:53,780 --> 00:39:55,810
它会显示这个屏幕

782
00:39:55,810 --> 00:39:58,630
可以通过点上面这个来得到

783
00:39:58,630 --> 00:40:00,470
这是我们的项目设置

784
00:40:00,470 --> 00:40:02,310
这里有很多设置

785
00:40:02,310 --> 00:40:04,590
这学期我会讲到所有这些

786
00:40:04,590 --> 00:40:08,530
但今天我不打算讲 因为我要将焦点集中在MVC上

787
00:40:08,530 --> 00:40:15,860
我们的MVC中 这里这个Main.storyboard是我们的视图

788
00:40:15,860 --> 00:40:18,140
这是MVC中的视图

789
00:40:18,160 --> 00:40:21,160
然后这里有CardGameViewController.m和.h

790
00:40:21,160 --> 00:40:23,010
这是我们的控制器

791
00:40:23,010 --> 00:40:24,440
这里没有模型

792
00:40:24,440 --> 00:40:27,040
模型将是那四个类

793
00:40:27,040 --> 00:40:29,420
Deck Card PlayingCard PlayingCardDeck

794
00:40:29,420 --> 00:40:31,120
这将是你的模型

795
00:40:31,120 --> 00:40:32,440
你需要输入这些

796
00:40:32,440 --> 00:40:35,100
最后我会展示如何做到

797
00:40:35,100 --> 00:40:38,770
这里的CardGameAppDelegate.h和.m

798
00:40:38,770 --> 00:40:44,460
这个我在讲多任务处理这些时会简要讲到

799
00:40:44,460 --> 00:40:46,860
这里我不想看到它们

800
00:40:46,860 --> 00:40:49,920
我通常把它们放到支持文件文件夹中

801
00:40:49,920 --> 00:40:53,050
顺便说下 文件可以直接拖动 拖到哪都行

802
00:40:53,050 --> 00:40:55,260
这是为了屏幕上更简洁

803
00:40:55,260 --> 00:41:00,780
这里于是就只显示有视图和控制器了

804
00:41:00,780 --> 00:41:04,770
我们直接到视图 看它是怎样的

805
00:41:04,770 --> 00:41:09,230
这是我的视图 一个空iPhone5大小的空间

806
00:41:09,230 --> 00:41:12,770
一个又高又窄的视图

807
00:41:12,770 --> 00:41:15,810
而且它是空的 什么都没有 空白一片

808
00:41:15,810 --> 00:41:19,360
顺便说下 这里用来点击文件的地方

809
00:41:19,360 --> 00:41:20,910
叫作导航栏

810
00:41:20,910 --> 00:41:23,030
你不仅可以浏览所有文件

811
00:41:23,030 --> 00:41:25,230
你还可以浏览断点

812
00:41:25,230 --> 00:41:28,200
创建问题 类层次结构

813
00:41:28,200 --> 00:41:29,150
这些都在这上面

814
00:41:29,150 --> 00:41:32,600
大多数人用过Xcode 应该都知道这些

815
00:41:32,600 --> 00:41:35,700
我们在这学期的过程中会不断演示

816
00:41:35,700 --> 00:41:38,950
而这块区域叫作"工具区"

817
00:41:38,950 --> 00:41:43,630
这里会显示中间这里的细节情况

818
00:41:43,630 --> 00:41:48,620
例如属性 尺寸 连接检查器

819
00:41:48,620 --> 00:41:50,250
这些都在这里

820
00:41:50,250 --> 00:41:53,430
而且这里还可以拖出这些东西

821
00:41:53,430 --> 00:41:56,070
用于构建你的用户界面

822
00:41:56,070 --> 00:41:59,610
因为我们将要完全图形化地创建视图

823
00:41:59,610 --> 00:42:02,770
我们大多数时候会写代码来创建视图

824
00:42:02,770 --> 00:42:06,430
随着学期进行 我们会更多地学到如何写代码来创建视图

825
00:42:06,440 --> 00:42:10,730
但最开始 我们将只使用图形化操作来创建视图

826
00:42:10,730 --> 00:42:12,390
将事物拖入 连起

827
00:42:12,390 --> 00:42:14,670
然后我们再在控制器中写代码

828
00:42:14,670 --> 00:42:21,150
这两个边栏可以通过这两个按钮来隐藏和显示

829
00:42:21,150 --> 00:42:24,650
看到了吗 你可以隐藏它们

830
00:42:25,160 --> 00:42:29,030
这个按钮也可以点 显示出的这个区域

831
00:42:29,030 --> 00:42:30,570
叫作"文档大纲"

832
00:42:30,570 --> 00:42:32,360
这也很有用

833
00:42:32,360 --> 00:42:33,920
但我今天不打算讲

834
00:42:33,920 --> 00:42:35,780
一次我只能讲那么多

835
00:42:35,780 --> 00:42:37,360
文档大纲

836
00:42:37,360 --> 00:42:42,440
它会将视图中所有对象实例以大纲形式展示出来

837
00:42:42,440 --> 00:42:45,700
这样你就能够很轻松地弄清它们之间的相互关系

838
00:42:45,700 --> 00:42:50,300
另外你还可以说 我不想要iPhone5的屏幕大小

839
00:42:50,300 --> 00:42:54,690
因为我的屏幕没有这么大 这里我是为了配合投影仪

840
00:42:54,690 --> 00:42:57,010
这时可以点这个按钮

841
00:42:57,010 --> 00:43:01,770
这可以将屏幕缩小到iPhone4或4S的大小

842
00:43:01,770 --> 00:43:03,660
而非又高又窄

843
00:43:03,660 --> 00:43:07,360
你可以点这个来回切换

844
00:43:07,360 --> 00:43:10,990
我这里只是想让它更好地匹配投影仪大小

845
00:43:10,990 --> 00:43:14,700
好 让我们开始真正构建视图

846
00:43:14,700 --> 00:43:21,300
今天我们的视图将是一张上面写有梅花A的纸牌

847
00:43:21,300 --> 00:43:23,220
就这些了

848
00:43:23,220 --> 00:43:25,140
而且我能点击纸牌

849
00:43:25,140 --> 00:43:27,320
它会翻过来 显示背面

850
00:43:27,320 --> 00:43:30,160
再点击 它会翻回来 显示正面的梅花A

851
00:43:30,160 --> 00:43:31,380
来回来回

852
00:43:31,380 --> 00:43:33,630
而你们的作业是

853
00:43:33,630 --> 00:43:36,260
当纸牌翻转时 显示的不是梅花A

854
00:43:36,260 --> 00:43:39,050
而是从牌堆中随机抽取的牌

855
00:43:39,060 --> 00:43:42,490
这是周一要交的作业的全部内容

856
00:43:42,490 --> 00:43:44,710
好 我们来做这个 很简单

857
00:43:44,710 --> 00:43:47,510
我们到这里 这个对象库

858
00:43:47,510 --> 00:43:50,290
也就是这里第三个按钮 显示对象库

859
00:43:50,290 --> 00:43:52,100
对象都在这里

860
00:43:52,100 --> 00:43:54,640
只看这里 你还看不到这些对象

861
00:43:54,640 --> 00:43:56,620
你要点击视图

862
00:43:56,620 --> 00:44:00,520
有时 Xcode想知道目的地在哪

863
00:44:00,520 --> 00:44:02,760
你要把东西拖放到哪

864
00:44:02,760 --> 00:44:04,790
点击之后 你会看到这些东西

865
00:44:04,790 --> 00:44:06,950
我们将抓取这里的一个按钮

866
00:44:06,950 --> 00:44:09,730
我选取这个按钮 并拖出

867
00:44:09,730 --> 00:44:11,410
注意到 当我拖出它时

868
00:44:11,410 --> 00:44:13,870
这些蓝色的参考线会显示出来

869
00:44:13,870 --> 00:44:16,780
这些参考线非常重要

870
00:44:16,780 --> 00:44:18,430
它们除了方便

871
00:44:18,430 --> 00:44:21,890
帮你将对象放到中间或右下角这些地方以外

872
00:44:21,890 --> 00:44:25,810
它们的重要性还体现在 帮你确保

873
00:44:25,810 --> 00:44:29,600
视图中的所有东西都相隔标准距离

874
00:44:29,600 --> 00:44:31,610
并在边缘处对齐

875
00:44:31,610 --> 00:44:34,300
当用户从一个app到另一个时

876
00:44:34,300 --> 00:44:38,610
事物将以可预测的距离分开 一切都会保持一致

877
00:44:38,610 --> 00:44:39,650
这很重要

878
00:44:39,650 --> 00:44:42,190
这里还有一个机制 可以看到这里有个开关

879
00:44:42,190 --> 00:44:45,210
使用自动布局 这是在iOS6中引入的

880
00:44:45,210 --> 00:44:48,460
在iOS7中 特别是Xcode中得到了大幅提升

881
00:44:48,460 --> 00:44:52,760
这使得 当你的用户界面改变大小时

882
00:44:52,760 --> 00:44:55,370
例如从iPhone4到iPhone5

883
00:44:55,370 --> 00:44:59,330
或者从竖直旋转为水平

884
00:44:59,330 --> 00:45:02,230
或是在iPad上 有更大空间

885
00:45:02,230 --> 00:45:06,460
这会让所有按钮等元件合理地移动到新位置

886
00:45:06,460 --> 00:45:08,120
至少大多数移到合理位置

887
00:45:08,120 --> 00:45:10,410
还有一些 你可能需要手工移动

888
00:45:10,410 --> 00:45:11,750
取决于具体情况

889
00:45:11,770 --> 00:45:14,000
但基本上是自动布局

890
00:45:14,000 --> 00:45:15,050
这很重要

891
00:45:15,050 --> 00:45:18,010
因为设备将不断变换大小

892
00:45:18,010 --> 00:45:20,670
每年都会有新设备出来

893
00:45:20,670 --> 00:45:23,120
所以 使用自动布局很重要

894
00:45:23,120 --> 00:45:26,560
而这些蓝色参考线对于自动布局是第一重要的东西

895
00:45:26,560 --> 00:45:29,820
我会详细讲解自动布局 它有很多内容

896
00:45:29,820 --> 00:45:33,330
下面所有这些按钮都与自动布局有关

897
00:45:33,330 --> 00:45:36,530
得到这些蓝色参考线 确保元件所放位置

898
00:45:36,530 --> 00:45:39,670
至少能够显示出一条蓝色参考线 非常重要

899
00:45:39,670 --> 00:45:43,790
这能让你的元件在UI自动布局时找到正确的位置

900
00:45:43,790 --> 00:45:45,690
这里有个按钮

901
00:45:45,690 --> 00:45:47,990
当然 我们可以到这里

902
00:45:47,990 --> 00:45:50,820
这里是属性检查器 点击它

903
00:45:50,820 --> 00:45:52,690
这里有各种属性

904
00:45:52,690 --> 00:45:56,400
我可以隐藏这个 这里有该按钮各式各样的属性

905
00:45:56,400 --> 00:45:58,130
不只是按钮本身

906
00:45:58,130 --> 00:46:00,890
它的父类也有属性

907
00:46:00,890 --> 00:46:02,230
Control是它的父类

908
00:46:02,230 --> 00:46:05,610
然后View是Control的父类 它也有属性

909
00:46:05,610 --> 00:46:08,400
这是一个面向对象的检查器

910
00:46:08,400 --> 00:46:14,000
它会显示出继承层次下的所有属性

911
00:46:14,000 --> 00:46:20,150
这里我们所做的 实际上是编辑一个按钮的实例

912
00:46:20,150 --> 00:46:21,570
我们不是… 我知道

913
00:46:21,570 --> 00:46:24,990
某些系统中 你布局按钮 设定大小 设定属性

914
00:46:24,990 --> 00:46:27,350
然后在幕后

915
00:46:27,350 --> 00:46:30,520
一堆代码会生成出来 创建按钮

916
00:46:30,520 --> 00:46:31,770
这里不是这样

917
00:46:31,770 --> 00:46:33,670
我们是在编辑活动对象

918
00:46:33,670 --> 00:46:35,670
它们就像是速冻咖啡粉末

919
00:46:35,690 --> 00:46:39,560
app运行就像加水 它们会被注入生命

920
00:46:39,560 --> 00:46:42,040
它们的属性会被设置 它们的大小和位置

921
00:46:42,040 --> 00:46:44,980
以及所有的自动布局信息都在对象中

922
00:46:44,980 --> 00:46:50,030
这有些不同于其它系统中你们所习惯的情况

923
00:46:50,030 --> 00:46:52,650
无论如何 在我们编辑这个按钮的属性前

924
00:46:52,650 --> 00:46:56,250
我们先来换个背景 因为这是一个扑克牌游戏

925
00:46:56,250 --> 00:46:59,450
而大多数扑克牌游戏都是绿色绒布 对吧

926
00:46:59,450 --> 00:47:01,650
让我们把背景换得更像绿色绒布

927
00:47:01,650 --> 00:47:03,580
我将点击背景

928
00:47:03,580 --> 00:47:06,810
也就是这个View 可以看到它的属性

929
00:47:06,810 --> 00:47:10,490
我将改变这个背景属性

930
00:47:10,490 --> 00:47:12,940
这里背景还是白色

931
00:47:12,940 --> 00:47:15,950
点击这里 这里有一些最近使用过的颜色

932
00:47:15,950 --> 00:47:18,150
我有所有这些黑白颜色

933
00:47:18,150 --> 00:47:19,490
这里还有其它颜色

934
00:47:19,490 --> 00:47:22,570
点其它会出现这些蜡笔

935
00:47:22,570 --> 00:47:26,140
还有其它选择颜色的方式 不过我喜欢蜡笔

936
00:47:26,140 --> 00:47:29,930
我的蜡笔呢

937
00:47:29,930 --> 00:47:30,770
这里

938
00:47:30,770 --> 00:47:34,450
我们来选一种绿色 青苔色是很好的绿色

939
00:47:34,450 --> 00:47:36,030
苜蓿色 我更喜欢青苔色

940
00:47:36,030 --> 00:47:39,130
这是纸牌游戏的背景

941
00:47:39,130 --> 00:47:42,970
这就行了 我们设置好了View的背景颜色

942
00:47:42,970 --> 00:47:45,340
所有的属性设置都和这类似

943
00:47:45,340 --> 00:47:48,140
设置好了就可以不用管了

944
00:47:48,140 --> 00:47:50,980
我们回到按钮和它的属性

945
00:47:50,980 --> 00:47:53,240
按钮我希望它像一张纸牌

946
00:47:53,240 --> 00:47:58,730
iOS7中的按钮比较像网页中的超链接

947
00:47:58,730 --> 00:48:02,140
就像这个按钮所做的 这个蓝色按钮

948
00:48:02,140 --> 00:48:04,490
这不是我们想要的

949
00:48:04,490 --> 00:48:08,270
我们希望它是一张牌 有圆角矩形边框和白色背景

950
00:48:08,270 --> 00:48:10,150
我希望纸牌背面都一样

951
00:48:10,150 --> 00:48:13,510
而且具有某种图样设计

952
00:48:13,510 --> 00:48:18,230
所以 我将为我的按钮设置一个背景图

953
00:48:18,230 --> 00:48:20,360
一个圆角矩形的背景图

954
00:48:20,360 --> 00:48:22,280
这里我们先简单讲一下

955
00:48:22,280 --> 00:48:25,480
如何将图像置入到app中

956
00:48:25,480 --> 00:48:28,940
app中经常会用到图像

957
00:48:28,940 --> 00:48:31,160
手机程序一般都是图形程序

958
00:48:31,160 --> 00:48:32,020
那如何做到呢

959
00:48:32,020 --> 00:48:35,810
答案是 你可以到下面这个地方 它叫作

960
00:48:35,810 --> 00:48:38,610
图像资源库 Images.xcassets

961
00:48:38,610 --> 00:48:40,060
xcassets也就是Xcode资源

962
00:48:40,060 --> 00:48:43,090
可以看到这里已经有一些图标槽位存在

963
00:48:43,090 --> 00:48:45,720
你可以在这里设置app图标

964
00:48:45,720 --> 00:48:48,090
你还可以设置一个启动画面

965
00:48:48,090 --> 00:48:51,590
程序启动后需要初始化 启动画面会立刻显示

966
00:48:51,600 --> 00:48:54,390
初始化后再才显示出实际的UI

967
00:48:54,390 --> 00:48:56,450
这是一个快速的启动画面

968
00:48:56,450 --> 00:48:58,170
周一我会讲到这个

969
00:48:58,170 --> 00:49:00,810
这里我们将为Machismo设置背景

970
00:49:00,810 --> 00:49:04,820
我将拖入其它图像

971
00:49:04,820 --> 00:49:06,780
这里我有一些图像

972
00:49:06,800 --> 00:49:11,760
例如 这里我有这个斯坦福的logo

973
00:49:11,760 --> 00:49:14,170
我将把这个斯坦福的logo拖入

974
00:49:14,170 --> 00:49:15,460
因为我要用它

975
00:49:15,460 --> 00:49:16,830
把它拖到这里就行了

976
00:49:16,830 --> 00:49:17,910
这是斯坦福logo

977
00:49:17,910 --> 00:49:21,490
但注意到 这里有很奇怪的1x和2x

978
00:49:21,490 --> 00:49:26,610
看到了吗 这是因为iOS中你们要用到的每张图像

979
00:49:26,630 --> 00:49:30,180
需要有一个普通分辨率版本

980
00:49:30,180 --> 00:49:33,720
用于iPhone4这样的非视网膜屏

981
00:49:33,720 --> 00:49:38,140
而2x是两倍高分辨率版本 用于视网膜屏

982
00:49:38,140 --> 00:49:41,510
系统会自动选择正确的图像 取决于运行于什么设备

983
00:49:41,510 --> 00:49:43,340
你不需要做任何事

984
00:49:43,340 --> 00:49:45,750
但你需要提供这些高清版本

985
00:49:45,750 --> 00:49:50,080
这些高清版本并不一定要是原来一样的图像

986
00:49:50,090 --> 00:49:53,210
只是分辨率更高一些

987
00:49:53,210 --> 00:49:54,350
它们可以不同

988
00:49:54,350 --> 00:49:57,320
例如这里 我有一个带树的斯坦福logo

989
00:49:57,320 --> 00:49:58,950
看到树了吗

990
00:49:58,950 --> 00:50:01,930
也许这里由于分辨率太低 树不是很好看

991
00:50:01,930 --> 00:50:05,120
但在高分辨率下我可以加个树 所以我加了

992
00:50:05,120 --> 00:50:07,880
两个图像不一样的情况并不常见

993
00:50:07,880 --> 00:50:09,530
但它们确实可以不同

994
00:50:09,530 --> 00:50:11,400
这肯定是允许的

995
00:50:11,400 --> 00:50:14,110
我也不想把这个叫斯坦福

996
00:50:14,110 --> 00:50:17,290
我将把这用作纸牌的背面

997
00:50:17,290 --> 00:50:19,610
纸牌背面我将不使用某种花纹

998
00:50:19,610 --> 00:50:21,890
而使用斯坦福的logo

999
00:50:21,890 --> 00:50:24,350
纸牌翻过来时 我会看到背面的斯坦福logo

1000
00:50:24,350 --> 00:50:26,990
所以我将给它取名为cardback

1001
00:50:26,990 --> 00:50:29,600
其实叫什么都行

1002
00:50:29,600 --> 00:50:32,060
正面我也有个图像

1003
00:50:32,060 --> 00:50:33,450
这个

1004
00:50:33,450 --> 00:50:35,930
这是带有圆角的空纸牌

1005
00:50:35,930 --> 00:50:36,480
这里

1006
00:50:36,480 --> 00:50:38,010
哦 你们看不到

1007
00:50:38,010 --> 00:50:40,100
因为这是白色纸牌 所以你们看不到

1008
00:50:40,100 --> 00:50:43,430
但我将使用它 取名为cardfront

1009
00:50:43,430 --> 00:50:48,810
我还将有一个高清版的

1010
00:50:48,810 --> 00:50:50,620
好 这很不错

1011
00:50:50,620 --> 00:50:53,510
它只能显示成这样

1012
00:50:53,510 --> 00:50:56,140
以上一些图像

1013
00:50:56,140 --> 00:50:58,720
下面我将把它们用到我的视图中

1014
00:50:58,740 --> 00:51:00,890
我将设置纸牌 来使用这个

1015
00:51:00,890 --> 00:51:05,820
程序运行时 我希望纸牌最开始是正面朝上

1016
00:51:05,820 --> 00:51:08,740
app运行时 纸牌最开始是正面朝上

1017
00:51:08,740 --> 00:51:12,590
在作业app中 你们需要让它正面朝下

1018
00:51:12,590 --> 00:51:15,800
原因在于 我的app只显示一张牌

1019
00:51:15,800 --> 00:51:16,880
梅花A

1020
00:51:16,880 --> 00:51:19,110
所以最开始梅花A朝上没有关系

1021
00:51:19,110 --> 00:51:22,140
但你们显然不希望一开始就是梅花A

1022
00:51:22,140 --> 00:51:25,360
而且代码上 你们也需要更多工作

1023
00:51:25,360 --> 00:51:27,860
才能初始化它 得到随机的牌

1024
00:51:27,860 --> 00:51:30,910
所以你们应该让它正面朝下 这会更容易一些

1025
00:51:30,910 --> 00:51:33,800
这如何设置呢

1026
00:51:33,800 --> 00:51:34,550
很简单

1027
00:51:34,550 --> 00:51:36,030
这里有已选定的按钮

1028
00:51:36,030 --> 00:51:37,280
这是它的属性

1029
00:51:37,280 --> 00:51:40,130
一个属性是它的背景图像

1030
00:51:40,130 --> 00:51:42,500
我要点击这里 可以看到

1031
00:51:42,500 --> 00:51:45,530
资源库中的所有图像都在这里

1032
00:51:45,530 --> 00:51:48,860
有很多的话 你可以键入字符 它会自行匹配

1033
00:51:48,860 --> 00:51:51,750
我将把它设为cardfront

1034
00:51:51,750 --> 00:51:55,390
这就设为了正面 但圆角矩形在哪

1035
00:51:55,390 --> 00:51:58,580
我看不到圆角矩形 这是因为它太小了

1036
00:51:58,580 --> 00:52:01,580
圆角看不大清楚

1037
00:52:01,580 --> 00:52:04,590
这里你可以将它拉大一些

1038
00:52:04,590 --> 00:52:06,870
我希望让它…

1039
00:52:06,870 --> 00:52:12,910
这里我希望比例是2:3 我将使用64x96

1040
00:52:12,910 --> 00:52:15,910
这是一个很好的尺寸 我调整了它的大小

1041
00:52:15,910 --> 00:52:18,150
这时就可以看到圆角了

1042
00:52:18,150 --> 00:52:20,800
看到了吗 这就是我刚才拖入的图像

1043
00:52:20,800 --> 00:52:22,280
上面写有Button

1044
00:52:22,280 --> 00:52:24,350
我还可以将它移动一下

1045
00:52:24,350 --> 00:52:27,500
放到蓝色参考线的中间

1046
00:52:27,500 --> 00:52:30,050
当然 我不希望纸牌上写有Button

1047
00:52:30,050 --> 00:52:33,170
我希望这里是梅花A 我可以双击它

1048
00:52:33,170 --> 00:52:34,860
我也可以在这上面编辑

1049
00:52:34,860 --> 00:52:36,140
看到了吗 这里写的是Button

1050
00:52:36,140 --> 00:52:36,860
点击这里

1051
00:52:36,860 --> 00:52:38,710
我将直接双击它

1052
00:52:38,710 --> 00:52:39,980
我将输入A

1053
00:52:39,980 --> 00:52:42,180
如何输入梅花 有人知道吗

1054
00:52:43,220 --> 00:52:45,420
Alt+什么 我喜欢这样做

1055
00:52:45,420 --> 00:52:49,810
到编辑菜单 选特殊字符 弹出这个窗口

1056
00:52:49,810 --> 00:52:51,320
看过这个吗 很酷吧

1057
00:52:51,320 --> 00:52:55,860
双击 找到梅花 然后双击

1058
00:52:55,860 --> 00:52:58,160
好 这就是我的梅花A了

1059
00:52:58,160 --> 00:53:00,610
不过这也不是很好

1060
00:53:00,610 --> 00:53:04,050
我不喜欢这个蓝A 我希望A是黑色的

1061
00:53:04,050 --> 00:53:06,750
而且它可以更大一些 这里还有更大空间

1062
00:53:06,750 --> 00:53:09,760
我可以到这里 来改变字体

1063
00:53:09,760 --> 00:53:12,660
我可以点这个 让它更大

1064
00:53:12,660 --> 00:53:16,760
我也可以点击这个T 设置它为哪一种字体

1065
00:53:16,760 --> 00:53:20,610
iOS7中很重要的一点是排版

1066
00:53:20,610 --> 00:53:25,630
选择正确的文本样式在iOS7中非常非常重要

1067
00:53:25,630 --> 00:53:27,200
这里我不打算细讲

1068
00:53:27,200 --> 00:53:28,810
我将使用系统字体

1069
00:53:28,810 --> 00:53:31,590
不过以后课上我会讲到

1070
00:53:31,590 --> 00:53:34,250
确保正确地方使用了正确字体

1071
00:53:34,250 --> 00:53:36,050
才能让UI看起来更漂亮

1072
00:53:36,050 --> 00:53:40,230
这里我可以改变字符大小 也许24点就差不多了

1073
00:53:40,230 --> 00:53:41,390
这就行了

1074
00:53:41,390 --> 00:53:44,290
然后我不要蓝色 点这里换字符颜色

1075
00:53:44,290 --> 00:53:46,280
我们要把这个换成黑色

1076
00:53:46,280 --> 00:53:49,000
好 这样牌就弄成了我想要的样子

1077
00:53:49,000 --> 00:53:49,890
这很好

1078
00:53:49,890 --> 00:53:52,770
顺便说下 我们设置的所有这些属性

1079
00:53:52,770 --> 00:53:55,570
Button下面可以看到这个状态配置

1080
00:53:55,570 --> 00:53:58,970
这是默认 我们可以设置所有不同状态

1081
00:53:58,970 --> 00:54:03,010
包括按钮的高亮状态 或选择状态 或禁用状态

1082
00:54:03,010 --> 00:54:05,310
不过这里我们设置的是默认

1083
00:54:05,310 --> 00:54:09,650
所有按钮都总会显示出默认状态

1084
00:54:09,650 --> 00:54:11,640
按钮非常强大

1085
00:54:11,640 --> 00:54:14,040
你可以让它们在高亮或别的状态中有所不同

1086
00:54:14,040 --> 00:54:16,010
但我们这里用到的将是

1087
00:54:16,010 --> 00:54:18,450
"正常"或"默认"状态下的按钮

1088
00:54:18,450 --> 00:54:20,390
看代码时你们会看到这个

1089
00:54:20,390 --> 00:54:22,180
我们现在就可以运行这个了

1090
00:54:22,180 --> 00:54:22,790
运行

1091
00:54:22,790 --> 00:54:24,670
你们大多数人用过Xcode

1092
00:54:24,670 --> 00:54:26,760
知道如何运行 也就是这个小的播放按钮

1093
00:54:26,760 --> 00:54:27,950
下拉列表里还有

1094
00:54:27,950 --> 00:54:30,870
测试和分析等其它这些东西

1095
00:54:30,870 --> 00:54:31,840
这里我们要运行

1096
00:54:31,840 --> 00:54:36,110
点运行 它会在模拟器中运行

1097
00:54:36,110 --> 00:54:38,520
这就是了

1098
00:54:38,520 --> 00:54:42,360
可以看到 模拟器很大 我的屏幕放不下

1099
00:54:42,360 --> 00:54:44,940
所以我需要滚动

1100
00:54:44,940 --> 00:54:48,030
点击它 它什么都做不了

1101
00:54:48,030 --> 00:54:49,700
这个不好

1102
00:54:49,700 --> 00:54:52,460
因为控制器中我还没有加入任何代码

1103
00:54:52,460 --> 00:54:54,840
来对点击作出响应

1104
00:54:54,840 --> 00:54:57,730
这将是我们下面的工作

1105
00:54:57,730 --> 00:55:00,130
回到这里来 停止

1106
00:55:03,790 --> 00:55:05,390
那么 怎么做到呢

1107
00:55:05,390 --> 00:55:07,680
这个做起来会非常有趣

1108
00:55:07,680 --> 00:55:09,950
我这里留一些空间出来

1109
00:55:09,950 --> 00:55:14,070
我们需要把它同控制器联系起来

1110
00:55:14,070 --> 00:55:19,690
做法是对照视图 并排加入控制器代码

1111
00:55:19,690 --> 00:55:21,830
我将点击这个小按钮

1112
00:55:21,830 --> 00:55:25,000
这个按钮图标 表示并排显示

1113
00:55:25,000 --> 00:55:27,820
默认情况下 如果视图在左边

1114
00:55:27,820 --> 00:55:30,740
控制器代码会显示在右边

1115
00:55:30,740 --> 00:55:34,150
我们可以移动这个 给代码腾出更大空间

1116
00:55:34,150 --> 00:55:37,760
这里还可以在处理公共内容的头文件

1117
00:55:37,770 --> 00:55:40,270
和实现之间来回切换

1118
00:55:41,760 --> 00:55:43,140
这很棒

1119
00:55:43,140 --> 00:55:46,240
这段代码是视图控制器生命周期的部分

1120
00:55:46,240 --> 00:55:48,390
我们会在两三周后谈到

1121
00:55:48,390 --> 00:55:53,110
不过今天我不打算讲它 让我把它删掉

1122
00:55:53,110 --> 00:55:57,420
今天我只想说

1123
00:55:57,420 --> 00:56:01,180
这个按钮被触碰到时 我们希望它翻个面

1124
00:56:01,180 --> 00:56:04,600
我们需要将视图和控制器连接起来

1125
00:56:04,600 --> 00:56:08,980
我们会将目标挂出去 然后将箭发射

1126
00:56:08,980 --> 00:56:10,380
这是目标 动作

1127
00:56:10,380 --> 00:56:11,890
这会有些怪异

1128
00:56:11,890 --> 00:56:14,480
看到这个时 你可能都不敢相信自己的眼睛

1129
00:56:14,480 --> 00:56:16,860
做法是按住Control键

1130
00:56:16,860 --> 00:56:21,910
我按住Control键 然后拖一条线

1131
00:56:21,910 --> 00:56:25,710
从视图直接拖到代码中

1132
00:56:27,070 --> 00:56:28,480
让后松手

1133
00:56:28,480 --> 00:56:33,240
然后它说 哦 你想在视图和控制器之间建立连接 对吧

1134
00:56:33,240 --> 00:56:34,680
这就是我需要知道的

1135
00:56:34,680 --> 00:56:37,330
它问我们 你希望给这个连接取名叫什么

1136
00:56:37,330 --> 00:56:38,670
这将是方法名

1137
00:56:38,670 --> 00:56:42,050
它会创建一个在按钮被触碰到时调用的方法

1138
00:56:42,050 --> 00:56:44,310
这里我给它取名叫touchCardButton(触摸纸牌按钮)

1139
00:56:44,310 --> 00:56:45,530
这个名字不错

1140
00:56:45,530 --> 00:56:48,200
这里它问的是 你希望参数类型是什么

1141
00:56:48,200 --> 00:56:49,130
以后我会讲到

1142
00:56:49,130 --> 00:56:51,750
不过这里 我们显然希望参数是

1143
00:56:51,750 --> 00:56:54,630
发送给我们这个动作的按钮

1144
00:56:54,630 --> 00:56:55,980
我们能够回头告诉它翻过来 这会很好

1145
00:56:55,980 --> 00:56:58,730
我们能够回头告诉它翻过来 这会很好

1146
00:56:58,730 --> 00:57:00,190
这里我们还可以设置

1147
00:57:00,190 --> 00:57:03,260
你想在哪一类事件下发送这个动作

1148
00:57:03,260 --> 00:57:05,760
你可以设置为无参数

1149
00:57:05,760 --> 00:57:08,530
它会发送touchCardButton 不带参数

1150
00:57:08,530 --> 00:57:11,010
但这里我们希望Sender这一参数

1151
00:57:11,010 --> 00:57:12,520
即发送这一消息的按钮

1152
00:57:12,520 --> 00:57:14,090
你还可以发送触摸事件

1153
00:57:14,090 --> 00:57:17,340
但我们几乎从不这样做 使用率小于0.1%

1154
00:57:17,340 --> 00:57:18,940
这里选Sender

1155
00:57:18,940 --> 00:57:21,760
我点击连接时 它会创建一个新方法

1156
00:57:21,760 --> 00:57:24,500
这一方法同这一按钮接通起来

1157
00:57:24,500 --> 00:57:26,500
看到这个圆圈了吗

1158
00:57:26,500 --> 00:57:31,520
鼠标放到上面 它就会告诉你 它连接到的是什么

1159
00:57:31,520 --> 00:57:35,470
这是一个非常普通的方法

1160
00:57:35,470 --> 00:57:40,130
返回类型IBAction 这实际上是typedef void

1161
00:57:40,130 --> 00:57:42,100
这个方法实际返回void

1162
00:57:42,100 --> 00:57:45,040
Xcode之所以加上IBAction

1163
00:57:45,040 --> 00:57:48,270
将IBAction类型定义到void 只是为了便于分辨

1164
00:57:48,270 --> 00:57:50,120
哪个方法是目标动作

1165
00:57:50,120 --> 00:57:52,890
于是它可以做这样的事情

1166
00:57:52,890 --> 00:57:54,290
鼠标悬停

1167
00:57:54,290 --> 00:57:55,560
但编译器会忽略它

1168
00:57:55,560 --> 00:57:58,380
编译器会把它看作void 因为它被类型定义为void

1169
00:57:58,380 --> 00:58:01,120
IBAction完全是为Xcode考虑

1170
00:58:01,120 --> 00:58:05,260
然后这个方法有一个参数 也就是sender

1171
00:58:05,260 --> 00:58:06,980
这是发送我们这一消息的按钮

1172
00:58:06,980 --> 00:58:11,770
每次按钮被触摸时 它都会发送这一消息

1173
00:58:11,770 --> 00:58:13,790
事件是触摸按钮

1174
00:58:13,790 --> 00:58:15,590
这时它会发送这一消息

1175
00:58:15,590 --> 00:58:17,030
这很完美 这就是我们要的

1176
00:58:17,030 --> 00:58:19,720
每次发生这个时 我们想要做什么

1177
00:58:19,720 --> 00:58:22,320
我们希望将纸牌翻过来

1178
00:58:22,320 --> 00:58:24,570
我们首先来考虑如何翻到反面

1179
00:58:24,570 --> 00:58:27,120
为此 我们将创建一个局部变量

1180
00:58:27,120 --> 00:58:29,180
叫cardImage(纸牌图像)

1181
00:58:29,180 --> 00:58:31,510
可以看到 它正为我提供键入帮助 这里会有很多帮助

1182
00:58:31,510 --> 00:58:34,510
可以看到 它正为我提供键入帮助 这里会有很多帮助

1183
00:58:34,510 --> 00:58:39,340
UIImage是iOS中的另一个类 就像UIButton一样

1184
00:58:39,340 --> 00:58:42,250
UIImage 顾名思义 是用来存储图像的

1185
00:58:42,250 --> 00:58:44,830
可以是JPEG图像 可以是GIF动画

1186
00:58:44,830 --> 00:58:47,050
可以是TIFF图像 这些都行

1187
00:58:47,050 --> 00:58:50,890
这是一种很强大的容纳图像的类

1188
00:58:50,890 --> 00:58:54,800
它有一个类方法 叫imageNamed(图像名叫)

1189
00:58:54,800 --> 00:59:00,460
你给它一个字符串 例如cardfront 或cardback

1190
00:59:00,460 --> 00:59:04,840
它会到资源库并给出一个分辨率正确的图像

1191
00:59:04,850 --> 00:59:06,590
实际上 它会给你两种分辨率的图像

1192
00:59:06,590 --> 00:59:08,700
实际上 它会给你两种分辨率的图像

1193
00:59:08,700 --> 00:59:11,220
然后取决于是否在视网膜屏上显示

1194
00:59:11,220 --> 00:59:13,860
它会为你选出正确分辨率的图像

1195
00:59:13,860 --> 00:59:15,380
这很酷 我们得到了图像

1196
00:59:15,380 --> 00:59:18,370
然后我们要告诉按钮把这个

1197
00:59:18,370 --> 00:59:20,120
设置为背景图像

1198
00:59:20,120 --> 00:59:21,990
替换现在它上面的图像

1199
00:59:21,990 --> 00:59:26,100
要同按钮通信 我们用[sender

1200
00:59:26,100 --> 00:59:30,650
sender也就是发送这一消息的按钮

1201
00:59:31,730 --> 00:59:36,130
设置背景 这里键入setBackground...

1202
00:59:36,130 --> 00:59:41,390
注意在我键入的过程中 Xcode会为我提供一些建议

1203
00:59:41,390 --> 00:59:43,640
它知道sender是一个UIButton

1204
00:59:43,640 --> 00:59:48,750
所以它这里只会给我推荐以setB开头的按钮方法

1205
00:59:48,750 --> 00:59:50,360
setBackgroundColor setBackgroundImage

1206
00:59:50,360 --> 00:59:51,550
和setBounds

1207
00:59:51,550 --> 00:59:54,600
注意下方还有一些帮助信息

1208
00:59:54,600 --> 00:59:55,400
很酷吧

1209
00:59:55,400 --> 00:59:57,050
有一两行的简短帮助

1210
00:59:57,050 --> 00:59:58,190
我还可以点这个链接

1211
00:59:58,190 --> 00:59:59,660
这会让我看到说明文档

1212
00:59:59,660 --> 01:00:01,940
由于时间原因 我这里就不点了

1213
01:00:01,940 --> 01:00:06,230
不过我可以选择一个 它会写出这一个

1214
01:00:06,230 --> 01:00:08,300
并立刻选择第一个参数

1215
01:00:08,300 --> 01:00:10,050
我可以填入这个

1216
01:00:10,050 --> 01:00:11,280
我要这样做

1217
01:00:11,280 --> 01:00:12,250
cardImage

1218
01:00:12,250 --> 01:00:15,950
注意到 当我键入ca时 这里给出了很多东西

1219
01:00:15,950 --> 01:00:18,280
所有ca开头的都在这里

1220
01:00:18,280 --> 01:00:20,000
但Xcode很聪明

1221
01:00:20,000 --> 01:00:23,820
它知道局部变量更可能是你要的

1222
01:00:23,830 --> 01:00:27,660
相比其它这些ca开头的函数

1223
01:00:27,660 --> 01:00:30,270
于是它自动给我选了这个

1224
01:00:30,270 --> 01:00:31,830
如果我按Tab键

1225
01:00:31,830 --> 01:00:35,250
它会自动给我补全 Tab用于补全

1226
01:00:35,270 --> 01:00:37,410
再点一下Tab 它会跳到这里

1227
01:00:37,410 --> 01:00:40,600
这里forState也就是我刚才讲过的内容

1228
01:00:40,600 --> 01:00:43,260
你可以设置为高亮状态

1229
01:00:43,260 --> 01:00:45,390
或选择状态 或禁用状态

1230
01:00:45,390 --> 01:00:49,280
我们将选择按钮的正常或默认状态

1231
01:00:49,280 --> 01:00:52,530
我们在设置这个按钮的背景图像

1232
01:00:52,530 --> 01:00:56,100
我们还需要设置标题 因为我们不希望

1233
01:00:56,100 --> 01:00:58,440
翻过来后还能看到梅花A

1234
01:00:58,440 --> 01:01:01,120
我将把它设为这个

1235
01:01:01,120 --> 01:01:04,160
这是空字符串 这里我也可以用nil

1236
01:01:04,160 --> 01:01:07,240
不过我这里要写空字符串 让你们看看是怎样的

1237
01:01:07,240 --> 01:01:09,450
我们可以运行这个

1238
01:01:12,840 --> 01:01:14,010
Command 3

1239
01:01:14,010 --> 01:01:14,930
好 我试试

1240
01:01:14,930 --> 01:01:16,420
哦 酷

1241
01:01:18,210 --> 01:01:19,490
好了

1242
01:01:19,490 --> 01:01:21,380
这是一个缩小的版本

1243
01:01:21,380 --> 01:01:22,940
这是我们的纸牌

1244
01:01:22,940 --> 01:01:25,050
如果我点它一下

1245
01:01:25,050 --> 01:01:26,730
哦耶 它翻过来了

1246
01:01:26,730 --> 01:01:29,180
很好 带树的斯坦福logo

1247
01:01:29,180 --> 01:01:33,030
但我再点它 它就不动了 永远是反面

1248
01:01:33,030 --> 01:01:35,530
这正是我们代码的效果

1249
01:01:35,530 --> 01:01:36,410
这很好

1250
01:01:36,410 --> 01:01:39,470
我们来调整一下代码 让它能两面翻动

1251
01:01:39,470 --> 01:01:43,320
我可以这样写 加上if

1252
01:01:43,320 --> 01:01:45,890
我还是先做另外一件事吧

1253
01:01:45,890 --> 01:01:47,700
让代码更简单一些

1254
01:01:47,700 --> 01:01:49,320
这里我可以不用这个局部变量

1255
01:01:49,320 --> 01:01:52,580
我可以直接把这些写到这里来

1256
01:01:52,580 --> 01:01:55,100
这是很常见的做法

1257
01:01:55,100 --> 01:01:58,870
如果要换行 太长的话它会自动换行

1258
01:01:58,870 --> 01:02:00,880
不过我也可以键入一个回车

1259
01:02:00,880 --> 01:02:02,970
这样做后 注意冒号的情况

1260
01:02:02,970 --> 01:02:05,600
看到冒号对齐起来了吗

1261
01:02:05,600 --> 01:02:06,900
它总会这样做

1262
01:02:06,900 --> 01:02:10,420
如果你在多参数的信息发送中间敲了回车

1263
01:02:10,420 --> 01:02:12,240
它会为所有参数对齐冒号

1264
01:02:12,240 --> 01:02:12,910
非常酷

1265
01:02:12,910 --> 01:02:16,550
这时所有参数都会像这样左右排列对齐

1266
01:02:16,550 --> 01:02:21,870
无论如何 我将检验当前标题

1267
01:02:21,870 --> 01:02:24,100
这是一个按钮方法

1268
01:02:24,100 --> 01:02:25,470
如果它是字符串

1269
01:02:25,470 --> 01:02:32,390
如果这个长度不为0

1270
01:02:32,390 --> 01:02:35,190
这是用于检验长度是否不为0

1271
01:02:35,190 --> 01:02:37,490
这样做很酷 因为这会在

1272
01:02:37,490 --> 01:02:41,380
按钮标题为nil或为空字符串时执行

1273
01:02:41,380 --> 01:02:43,200
因为按钮标题默认值是nil

1274
01:02:43,200 --> 01:02:45,000
不设置为任何东西 最开始就是nil

1275
01:02:45,000 --> 01:02:48,770
这里通过一行代码 我同时检验了两种可能的初始状态

1276
01:02:48,770 --> 01:02:50,950
这里不是如此 因为我们把标题设为了梅花A

1277
01:02:50,950 --> 01:02:53,100
不过你们的情况中 可能会是这样

1278
01:02:53,100 --> 01:02:57,040
然后我们让它执行一段代码 否则执行另一段

1279
01:02:57,040 --> 01:03:00,580
我们希望把这个设置到这里

1280
01:03:00,580 --> 01:03:03,410
如果按钮上有标题

1281
01:03:03,410 --> 01:03:07,280
换言之 它上面有梅花A 那我们就将翻到反面

1282
01:03:07,280 --> 01:03:13,340
如果按钮上没有标题 那么我们就将翻回正面

1283
01:03:13,340 --> 01:03:17,630
梅花A

1284
01:03:20,340 --> 01:03:27,160
之后我们如果运行 纸牌就能来回翻动了

1285
01:03:27,160 --> 01:03:32,430
将视图同控制器连接起来做你想做的事 其实很简单

1286
01:03:32,430 --> 01:03:37,430
下面我们再来看这个

1287
01:03:37,430 --> 01:03:40,330
这里我将快速展示一下

1288
01:03:40,330 --> 01:03:42,910
按住Option键 这个很重要的键

1289
01:03:42,910 --> 01:03:46,190
看到它让光标变成问号 并开始高亮显示一些东西吗

1290
01:03:46,210 --> 01:03:48,990
这让你能够转到说明文档

1291
01:03:48,990 --> 01:03:51,450
如果关于这个currentTitle我想知道更多

1292
01:03:51,450 --> 01:03:53,850
我可以Option点击它

1293
01:03:53,850 --> 01:03:55,410
这里可以得到一些帮助

1294
01:03:55,410 --> 01:03:58,060
它是一种属性 它是只读的 非原子的

1295
01:03:58,060 --> 01:04:02,030
记住 说明文档中凡是出现retain 都表示strong

1296
01:04:02,030 --> 01:04:04,630
retain其实说的也就是强

1297
01:04:04,630 --> 01:04:07,400
这里有些描述 然后还有超链接

1298
01:04:07,400 --> 01:04:10,110
如果我点击其中一个超链接 例如这个

1299
01:04:10,110 --> 01:04:11,520
我会进入说明文档

1300
01:04:11,520 --> 01:04:13,850
这是一个单独打开的窗口

1301
01:04:13,850 --> 01:04:16,900
你可以在这个说明文档中进行浏览

1302
01:04:16,900 --> 01:04:18,960
所有这些你们都需要熟悉

1303
01:04:18,960 --> 01:04:21,750
由于时间限制 我今天无法全部展示

1304
01:04:21,750 --> 01:04:26,310
不过你可以搜索 例如我可以搜索UIButton

1305
01:04:26,310 --> 01:04:27,620
这是UIButton

1306
01:04:27,620 --> 01:04:30,870
我可以往下滚动到 例如

1307
01:04:30,870 --> 01:04:35,360
我们刚看到过的setBackgroundImage:forState

1308
01:04:35,360 --> 01:04:37,520
我还可以点击进入UIImage

1309
01:04:37,520 --> 01:04:38,940
所有这些都在这里

1310
01:04:38,940 --> 01:04:40,910
一开始有对类的良好描述

1311
01:04:40,910 --> 01:04:43,100
然后所有方法 等等

1312
01:04:43,100 --> 01:04:46,560
你们必须掌握说明文档的使用方法

1313
01:04:46,560 --> 01:04:48,290
你还可以Option双击

1314
01:04:48,290 --> 01:04:49,730
这会直接进入说明文档

1315
01:04:49,730 --> 01:04:52,710
不会给出小帮助提示 而是直接跳到说明文档

1316
01:04:52,710 --> 01:04:57,000
Option是这里关键的键

1317
01:04:57,000 --> 01:04:58,850
然后再看

1318
01:04:58,850 --> 01:05:02,810
下面这里有一些空白区域

1319
01:05:02,810 --> 01:05:05,370
运行应用时 注意到了吗

1320
01:05:05,370 --> 01:05:10,340
左边这里是调试器 右边是控制台

1321
01:05:10,340 --> 01:05:15,680
课上你们肯定会用到调试器和控制台

1322
01:05:15,680 --> 01:05:19,370
我也许没有时间演示控制台的用法

1323
01:05:19,370 --> 01:05:22,010
无论如何 你可以通过拖动将它隐藏起来

1324
01:05:22,010 --> 01:05:23,400
或通过点击这个

1325
01:05:24,770 --> 01:05:27,710
好 下面我们将要

1326
01:05:27,710 --> 01:05:31,860
在UI上加上一个记录数翻牌次数的小标签

1327
01:05:31,860 --> 01:05:35,720
每次翻牌时 标签上的数字都会加一

1328
01:05:35,720 --> 01:05:43,950
要做这个 我们可以回到这里 抓取一个标签

1329
01:05:43,950 --> 01:05:47,780
标签是一段只读文本 不可编辑文本

1330
01:05:47,800 --> 01:05:50,740
我要把它拖放到左下角

1331
01:05:50,740 --> 01:05:54,090
双击它 改为Flip: 0

1332
01:05:54,090 --> 01:05:57,730
这是UI刚启动时我想要的效果

1333
01:05:57,730 --> 01:06:00,150
这个 我永远不会敲击它

1334
01:06:00,150 --> 01:06:04,080
进而导致按钮那样的消息发送 它是反过来的

1335
01:06:04,080 --> 01:06:08,170
我的控制器希望同它通信 在翻牌进行时告诉它

1336
01:06:08,170 --> 01:06:13,170
也许你会认为可以从代码拖到这个标签

1337
01:06:13,170 --> 01:06:15,220
很不幸的是 你不能这样

1338
01:06:15,220 --> 01:06:19,170
你还是按住Control 从这里开始拖动

1339
01:06:19,170 --> 01:06:22,020
但不是拖到实现区

1340
01:06:22,020 --> 01:06:23,860
而是拖到接口区

1341
01:06:23,860 --> 01:06:28,900
因为你要创建一个同该标签连接的属性

1342
01:06:28,900 --> 01:06:30,540
我们这样做后得到这个

1343
01:06:30,540 --> 01:06:32,080
问的问题略有不同

1344
01:06:32,080 --> 01:06:33,810
属性名是什么

1345
01:06:33,810 --> 01:06:36,230
我将称其为flipsLabel(翻牌标签)

1346
01:06:36,230 --> 01:06:38,980
注意到 该属性是弱的

1347
01:06:38,980 --> 01:06:43,200
我点击连接时 它会创建一个弱属性

1348
01:06:43,200 --> 01:06:46,530
这是我们首次用弱代替强

1349
01:06:46,530 --> 01:06:48,750
选弱的原因在于

1350
01:06:48,760 --> 01:06:53,370
该标签由视图本身很强地保持着

1351
01:06:53,370 --> 01:06:56,840
所以我们不需要用强指针指着它 来保证它在堆中

1352
01:06:56,840 --> 01:06:57,740
视图会做这个

1353
01:06:57,740 --> 01:07:02,010
如果该标签离开视图 它就会被清除出堆

1354
01:07:02,010 --> 01:07:04,600
而这个属性 这个指着它的指针

1355
01:07:04,600 --> 01:07:06,840
就会被设为nil 这正是我们想要的

1356
01:07:06,840 --> 01:07:09,190
因为当flipsLabel不在视图中时

1357
01:07:09,190 --> 01:07:11,630
我们就不想再更新和发消息给它了

1358
01:07:11,630 --> 01:07:15,630
所以说 这里对弱的使用很精妙

1359
01:07:15,630 --> 01:07:19,600
这里是你们很熟悉的通常属性 也许除了IBOutlet

1360
01:07:19,600 --> 01:07:21,610
这同IBAction类似

1361
01:07:21,610 --> 01:07:26,490
这是无意义的 编译器会忽略 Xcode使用它

1362
01:07:26,490 --> 01:07:28,500
这是用来做这个的

1363
01:07:28,500 --> 01:07:31,400
在鼠标悬停时显示连接到什么

1364
01:07:31,400 --> 01:07:36,270
你还可以通过右键点击来看所有连接

1365
01:07:36,270 --> 01:07:40,640
这里我右键点击了按钮 你可以看到它的连接

1366
01:07:40,640 --> 01:07:42,240
如果你想重命名

1367
01:07:42,240 --> 01:07:45,450
例如我不喜欢touchCardButton 我想重命名

1368
01:07:45,450 --> 01:07:47,670
很不幸 你不能重命名

1369
01:07:47,670 --> 01:07:52,990
你需要到这里 右键 使用这个小东西来断开连接

1370
01:07:52,990 --> 01:07:55,550
然后重新Control拖动

1371
01:07:55,550 --> 01:07:57,520
大家都明白了吗

1372
01:07:57,520 --> 01:07:58,210
很不幸

1373
01:07:58,210 --> 01:08:00,910
如果Xcode能跟踪这个就好了 可惜它不能

1374
01:08:00,910 --> 01:08:03,310
所以 如果你想重命名什么东西

1375
01:08:03,310 --> 01:08:06,240
你需要通过右键点击来断开连接

1376
01:08:06,240 --> 01:08:10,630
然后Control拖动一个新的 这样来设置名称

1377
01:08:10,630 --> 01:08:13,590
你还可以右键点击这个

1378
01:08:13,590 --> 01:08:16,770
这会显示出控制器的所有连接

1379
01:08:16,770 --> 01:08:17,790
展开这个窗口

1380
01:08:17,790 --> 01:08:19,450
我可以看到标签

1381
01:08:19,470 --> 01:08:21,520
鼠标现在在按钮上

1382
01:08:21,520 --> 01:08:22,240
标签

1383
01:08:22,240 --> 01:08:25,820
这里还有一个属性 你们没有见过这个

1384
01:08:25,820 --> 01:08:29,490
这是从控制器指向整个视图的属性

1385
01:08:29,490 --> 01:08:31,190
这是到控制器的连接

1386
01:08:31,190 --> 01:08:33,750
看到了吗 这里显示有纸牌游戏视图控制器

1387
01:08:33,750 --> 01:08:35,230
这是右键点击

1388
01:08:35,230 --> 01:08:38,210
我右键点击了这里

1389
01:08:38,210 --> 01:08:40,620
我们怎么让这个flipsLabel工作呢

1390
01:08:40,620 --> 01:08:45,320
我们先把它放一放

1391
01:08:45,320 --> 01:08:46,590
先不想它

1392
01:08:46,590 --> 01:08:49,680
先来看另一个属性

1393
01:08:50,690 --> 01:08:53,480
属性 它是非原子的

1394
01:08:53,480 --> 01:08:55,300
它只是一个int型整数

1395
01:08:55,300 --> 01:08:57,850
命名为flipCount(翻牌计数)

1396
01:08:57,850 --> 01:09:02,040
flipCount是一个整数 用于记录翻牌次数

1397
01:09:02,040 --> 01:09:05,270
再看这个

1398
01:09:05,270 --> 01:09:07,410
这里需要更多空间

1399
01:09:07,430 --> 01:09:09,170
过来一些

1400
01:09:09,170 --> 01:09:14,180
这里我只需要写self.flipCount++

1401
01:09:14,180 --> 01:09:20,330
这调用的是flipCount的setter还是getter

1402
01:09:20,330 --> 01:09:21,780
两者都 对

1403
01:09:21,780 --> 01:09:23,490
这同时调用了setter和getter

1404
01:09:23,490 --> 01:09:25,610
调用getter来获得flipCount

1405
01:09:25,610 --> 01:09:27,400
然后对它进行++

1406
01:09:27,400 --> 01:09:29,700
然后调用setter来设置值

1407
01:09:29,700 --> 01:09:32,050
这是一种很别致的代码写法

1408
01:09:32,050 --> 01:09:34,980
等价于self.flipCount=self.flipCount+1

1409
01:09:34,980 --> 01:09:36,910
它会调用getter和setter

1410
01:09:36,910 --> 01:09:39,030
好 现在我们有了这个很好的flipCount

1411
01:09:39,030 --> 01:09:43,630
它记录计数值 如何将它同这个联系起来呢

1412
01:09:43,630 --> 01:09:45,920
这个我要弄大一些

1413
01:09:45,920 --> 01:09:48,910
如何同这个联系起来 让它改写为Flips: 1

1414
01:09:48,910 --> 01:09:50,600
Flips: 2及Flips: 3这些

1415
01:09:50,600 --> 01:09:57,230
我们将使用flipCount的setter来做到这个

1416
01:09:57,230 --> 01:10:00,650
普通情况下 flipCount的setter是这样的

1417
01:10:00,650 --> 01:10:05,200
这是setter和getter的另一妙用

1418
01:10:05,200 --> 01:10:08,360
也就是让UI同属性保持同步

1419
01:10:08,360 --> 01:10:16,940
这里我要写 self.flipsLabel.text =…

1420
01:10:16,950 --> 01:10:20,660
哦 抱歉 站着打字很不方便

1421
01:10:20,660 --> 01:10:23,550
= NSString stringWithFormat…

1422
01:10:23,550 --> 01:10:27,940
这个你们见过 Flips: %d

1423
01:10:27,950 --> 01:10:30,890
self.flipCount

1424
01:10:30,890 --> 01:10:35,130
这样 每次flipCount变动时 我们都会更新UI

1425
01:10:36,460 --> 01:10:39,860
能明白吗 这里有任何问题吗

1426
01:10:39,860 --> 01:10:41,980
好 我们来运行

1427
01:10:44,630 --> 01:10:45,890
好的 程序运行

1428
01:10:45,890 --> 01:10:49,230
点击 翻面 翻牌计数更新了

1429
01:10:49,230 --> 01:10:50,500
翻 翻 翻 翻

1430
01:10:50,500 --> 01:10:53,320
来回都行 而flipCount正确记录着

1431
01:10:53,320 --> 01:10:54,550
翻了多少次

1432
01:10:54,550 --> 01:10:58,680
可以看到 这些很容易连接起来

1433
01:10:58,680 --> 01:11:02,640
在你开始创建更复杂的应用时

1434
01:11:02,640 --> 01:11:04,760
因为你总是在使用相同的目标动作和outlet机制

1435
01:11:04,760 --> 01:11:06,470
因为你总是在使用相同的目标动作和outlet机制

1436
01:11:06,470 --> 01:11:08,930
而且你将使用setter和getter来保持事物同步

1437
01:11:08,930 --> 01:11:11,190
这会让人们更容易理解你的代码如何工作

1438
01:11:11,190 --> 01:11:14,390
他们知道在哪去看的UI更新发生

1439
01:11:14,390 --> 01:11:17,310
等等 这里我还要做一件事

1440
01:11:17,310 --> 01:11:19,660
花点时间展示NSLog

1441
01:11:19,660 --> 01:11:22,700
我说过 你可以在控制台中记录日志

1442
01:11:22,700 --> 01:11:25,800
这里每次有变化时 让我们都用NSLog进行记录

1443
01:11:25,800 --> 01:11:27,370
这只是一个C函数

1444
01:11:27,390 --> 01:11:29,960
像printf一样给它一个格式字符串

1445
01:11:29,960 --> 01:11:34,090
这里我用flipCount = %d

1446
01:11:34,090 --> 01:11:35,980
self.flipCount

1447
01:11:35,980 --> 01:11:38,470
这就加入了这个NSLog

1448
01:11:38,470 --> 01:11:42,010
于是运行时 你就会在控制台看到它

1449
01:11:42,010 --> 01:11:45,750
我点击时 它会出现在这里 显示发生了什么

1450
01:11:45,750 --> 01:11:48,870
当然 我也可以把它拉宽一些

1451
01:11:48,870 --> 01:11:53,570
回到模拟器 看

1452
01:11:53,570 --> 01:11:57,000
NSLog是一种很棒的调试方式

1453
01:11:57,000 --> 01:11:59,880
有时比设置断点要容易很多

1454
01:11:59,880 --> 01:12:01,850
这里会给你打印出来

1455
01:12:01,850 --> 01:12:03,580
你可以随时观察

1456
01:12:03,580 --> 01:12:07,940
特别是在UI中 有时会是动画 它们随时间发生

1457
01:12:07,940 --> 01:12:09,510
在动画中间设置断点会很困难

1458
01:12:09,510 --> 01:12:10,990
在动画中间设置断点会很困难

1459
01:12:10,990 --> 01:12:14,540
但使用NSLog 你就能看到程序是怎么在运行了

1460
01:12:14,540 --> 01:12:20,100
我要展示的最后一点内容是 如何为app添加一个新类

1461
01:12:20,100 --> 01:12:22,910
因为你们到时要在这个基础上自行添加四个类

1462
01:12:22,910 --> 01:12:24,890
你们将从这个开始

1463
01:12:24,890 --> 01:12:27,730
然后添加四个类

1464
01:12:27,730 --> 01:12:29,550
Card Deck等等

1465
01:12:29,550 --> 01:12:33,200
添加一个类的做法如下

1466
01:12:33,200 --> 01:12:37,690
实际上 往项目中添加任何文件的方式都是这样

1467
01:12:37,690 --> 01:12:41,210
也就是到文件菜单 点选新 文件

1468
01:12:41,210 --> 01:12:44,330
这里你可以添加各种东西

1469
01:12:44,330 --> 01:12:46,490
数据库文件 架构文件等等

1470
01:12:46,490 --> 01:12:51,020
不过你所需要的是左上角这个Objective-C类

1471
01:12:51,020 --> 01:12:53,830
这里你要键入类名

1472
01:12:53,830 --> 01:12:58,280
例如 这里我要添加的是Card 然后是父类名

1473
01:12:58,280 --> 01:13:01,220
如果是PlayingCard 这里可以键入Card

1474
01:13:01,220 --> 01:13:05,240
并不一定要从这个列表中选择iOS默认的

1475
01:13:05,240 --> 01:13:07,990
这里我要创建的是Card

1476
01:13:07,990 --> 01:13:09,490
我可以把Card放到这里

1477
01:13:09,490 --> 01:13:10,780
它问我在哪存储这个

1478
01:13:10,780 --> 01:13:15,190
我可以放到同纸牌游戏控制器相同的位置

1479
01:13:15,190 --> 01:13:17,380
但我不大推崇

1480
01:13:17,380 --> 01:13:20,380
将模型放到它自身的目录下

1481
01:13:20,380 --> 01:13:23,440
我希望你们使用新文件夹

1482
01:13:23,440 --> 01:13:25,550
例如可以创建一个Model目录

1483
01:13:25,550 --> 01:13:28,520
于是这里有了一个Model目录

1484
01:13:28,520 --> 01:13:31,090
这是控制器 这是模型目录

1485
01:13:31,090 --> 01:13:32,460
创建

1486
01:13:32,460 --> 01:13:35,350
这会创建Card.h和.m

1487
01:13:35,350 --> 01:13:39,050
这是Card.h和.m 目前还是空白

1488
01:13:39,050 --> 01:13:41,200
你可以在它们之间来回切换

1489
01:13:41,200 --> 01:13:44,930
注意到 如果我改变左边 右边会随之变化

1490
01:13:44,930 --> 01:13:47,500
看到了吗 改变这个 这个随之变化

1491
01:13:47,500 --> 01:13:49,670
这是因为这里我选了counterparts(对应)

1492
01:13:49,670 --> 01:13:52,560
如果使用manual 手动设置这个

1493
01:13:52,560 --> 01:13:54,180
这时它就不会这样做了

1494
01:13:54,180 --> 01:13:57,690
不过你总是可以选回counterparts 这会保持同步

1495
01:13:57,690 --> 01:14:00,850
有些人喜欢让头文件在左

1496
01:14:00,850 --> 01:14:02,730
有些人则喜欢在右

1497
01:14:02,730 --> 01:14:04,550
还要注意到这里

1498
01:14:04,550 --> 01:14:07,570
这些在导航栏中能够组起来 这很棒

1499
01:14:07,570 --> 01:14:12,130
我只需要选择它们 右键点击 新组

1500
01:14:12,130 --> 01:14:13,540
命名为Model

1501
01:14:13,540 --> 01:14:17,660
这样我就将我的模型放到了这个小地方

1502
01:14:17,660 --> 01:14:20,290
我可以将它移动到下面这里 诸如此类

1503
01:14:20,290 --> 01:14:22,860
我可以把所有四个类都放到这里

1504
01:14:22,860 --> 01:14:27,730
还可以将这个组同文件系统连起来

1505
01:14:27,730 --> 01:14:31,850
实际上 你可以点击文件 在这里打开检查器

1506
01:14:31,870 --> 01:14:33,690
可以看到有这些可供选择

1507
01:14:33,690 --> 01:14:36,330
你可以指定是绝对路径

1508
01:14:36,330 --> 01:14:38,800
还是相对于它所在的组 等等

1509
01:14:38,800 --> 01:14:41,000
这是可以控制的

1510
01:14:41,000 --> 01:14:42,840
就这些了

1511
01:14:42,840 --> 01:14:44,580
知道这些就能开始做作业了

1512
01:14:44,580 --> 01:14:48,290
你们需要键入Card的所有代码 并加入另三个类

1513
01:14:48,290 --> 01:14:49,520
键入所有代码

1514
01:14:49,530 --> 01:14:52,830
你们要让纸牌不是总显示梅花A

1515
01:14:52,830 --> 01:14:55,640
你需要在牌堆中抽取

1516
01:14:55,640 --> 01:14:58,590
我发布有详细的作业指南

1517
01:14:58,610 --> 01:15:02,650
其中有各种提示和帮助 告诉你需要做哪些任务

1518
01:15:02,650 --> 01:15:04,930
还有评定标准 等等所有这些

1519
01:15:04,930 --> 01:15:07,140
所以请务必仔细阅读

1520
01:15:07,140 --> 01:15:09,940
不要跳过 不要直接做作业

1521
01:15:09,960 --> 01:15:13,570
有问题的 现在可以来提 下课

1522
01:15:13,570 --> 01:15:17,570
更多内容 请访问我校官网stanford.edu

