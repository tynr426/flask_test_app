1
00:00:00,000 --> 00:00:04,830
欢迎收看斯坦福大学公开课

2
00:00:04,830 --> 00:00:07,400
本字幕由志愿者义务贡献

3
00:00:11,270 --> 00:00:15,940
欢迎参加斯坦福大学2015年冬季学期的 CS193P 课程

4
00:00:15,940 --> 00:00:18,740
CS193P 课程

5
00:00:18,750 --> 00:00:21,280
在今天以前 我们一直都在写 demo

6
00:00:21,280 --> 00:00:24,550
而今天 我们将会全部通过幻灯片学习

7
00:00:24,550 --> 00:00:28,720
我将会讲到很多东西

8
00:00:28,720 --> 00:00:31,140
大部分 但不是全部

9
00:00:31,140 --> 00:00:33,560
都在你的阅读任务中

10
00:00:33,560 --> 00:00:35,490
在这里我会尽量把

11
00:00:35,490 --> 00:00:37,430
重点强调一些重要的部分

12
00:00:37,430 --> 00:00:39,060
并且也会给你看一些

13
00:00:39,060 --> 00:00:41,800
并不包含在阅读任务中 但你仍然需要知道的东西

14
00:00:41,800 --> 00:00:43,330
但这绝对不能代替阅读

15
00:00:43,330 --> 00:00:46,470
你仍然需要通过阅读

16
00:00:46,470 --> 00:00:49,870
来掌握这些的细节部分

17
00:00:49,870 --> 00:00:54,610
希望这节课可以让你注意在

18
00:00:54,610 --> 00:00:58,060
关键的东西上

19
00:00:58,060 --> 00:01:01,510
好的 那么我将讲讲

20
00:01:01,520 --> 00:01:05,580
Optional 和 enum 你已经知道 enum 是什么了

21
00:01:05,590 --> 00:01:08,420
那么我可以告诉你 Optional 到底是什么了

22
00:01:08,420 --> 00:01:10,990
Optional 就是 enum

23
00:01:10,990 --> 00:01:15,090
就是一个非常简单的 enum 它是泛型的 类似于 Array

24
00:01:15,100 --> 00:01:15,990
比如一个 Array

25
00:01:16,000 --> 00:01:17,660
你指定了其中的类型

26
00:01:17,660 --> 00:01:19,300
Optional 跟它完全一样

27
00:01:19,300 --> 00:01:20,330
就是泛型

28
00:01:20,330 --> 00:01:22,630
你指定了 Optional 的类型是什么

29
00:01:22,630 --> 00:01:26,170
而此类型 在这个 enum 中的 T

30
00:01:26,170 --> 00:01:29,370
就是关联值的类型

31
00:01:29,370 --> 00:01:31,570
enums 可以关联各种值

32
00:01:31,580 --> 00:01:35,880
如果 Optional 不是 nil 这就是它的类型

33
00:01:35,880 --> 00:01:38,750
你就可以获取到它。这就是 enum

34
00:01:38,750 --> 00:01:42,050
举个例子

35
00:01:42,050 --> 00:01:45,720
使用一个 enum 实现一个 Optional 看起来会像是这样

36
00:01:45,720 --> 00:01:49,560
你可以看到 x 可以是一个 enum 或者是一个 Optional String

37
00:01:49,560 --> 00:01:52,130
如果是 nil 可以这样表示：

38
00:01:52,130 --> 00:01:53,490
x = Optional.None

39
00:01:54,800 --> 00:01:56,200
ok？

40
00:01:56,200 --> 00:01:57,600
或者你可以将其赋值

41
00:01:57,600 --> 00:02:00,400
x = Optional.Some()

42
00:02:00,400 --> 00:02:02,700
关联值 也就是 "Hello".

43
00:02:04,400 --> 00:02:05,600
很合理吧？

44
00:02:05,600 --> 00:02:07,700
Optional 其实就是这么简单

45
00:02:07,710 --> 00:02:10,470
由问号及感叹号组成

46
00:02:10,480 --> 00:02:13,180
我知道这看起来

47
00:02:13,180 --> 00:02:17,450
非常复杂 但实际上非常简单

48
00:02:17,450 --> 00:02:20,780
这只是语法上的甜头 为了实现 Optional

49
00:02:20,780 --> 00:02:25,120
现在到解包 真的这看起来

50
00:02:25,120 --> 00:02:28,890
就只是 switch 与 case 在 "Some" 的情况下你可以得到其值

51
00:02:28,890 --> 00:02:32,230
在 "None" 的情况下 就会抛出异常

52
00:02:32,230 --> 00:02:36,030
就这么简单

53
00:02:36,030 --> 00:02:41,400
这也是为什么当你解包一个 nil 的时候会崩溃

54
00:02:41,400 --> 00:02:45,240
这就是一个 Optional 。对于 Array

55
00:02:45,240 --> 00:02:47,740
我们已经概括了一次 所以我会快点进行这部分

56
00:02:47,740 --> 00:02:50,480
Array  这里的语法是相同的 对吧？

57
00:02:50,480 --> 00:02:51,780
这里的方括号

58
00:02:51,780 --> 00:02:54,050
这就意味着他们是相同的

59
00:02:54,050 --> 00:02:59,050
并且你不能通过任何方式增加或修改

60
00:02:59,050 --> 00:03:02,250
一个声明为 let 的 Array  因为这是常量 Array

61
00:03:02,250 --> 00:03:04,990
我在这里重申一下 通过 let 将一个

62
00:03:04,990 --> 00:03:07,320
Array 声明为常量

63
00:03:07,330 --> 00:03:09,220
与声明一个 Array 为 var

64
00:03:09,230 --> 00:03:12,830
声明为 let 意味着它是不可变的 所以你不能增加或插入

65
00:03:12,830 --> 00:03:15,460
或任何你想要改变这个 Array 的操作

66
00:03:15,470 --> 00:03:17,330
当然

67
00:03:17,330 --> 00:03:19,200
如果你通过方括号访问一个 Array

68
00:03:19,200 --> 00:03:21,540
然后尝试着获取一个超出了 Array 范围东西

69
00:03:21,540 --> 00:03:23,800
一个 Array 只有四种动物在里面

70
00:03:23,810 --> 00:03:27,140
我想要获取第五种 那么就会崩溃

71
00:03:27,140 --> 00:03:28,270
Array 访问越界

72
00:03:28,280 --> 00:03:30,980
你以前使用过的语言也会是这样

73
00:03:32,550 --> 00:03:33,850
如何枚举一个 Array 呢

74
00:03:33,850 --> 00:03:35,880
如果你想要获取在 Array 中的每一个对象

75
00:03:35,880 --> 00:03:39,650
你可以使用 for in

76
00:03:39,650 --> 00:03:43,520
就比如 for 一个你需要的变量

77
00:03:43,520 --> 00:03:46,060
in Array 然后在这里面

78
00:03:46,060 --> 00:03:49,130
就是你想要的值了

79
00:03:49,130 --> 00:03:51,430
我放在这里主要是为了与

80
00:03:51,430 --> 00:03:54,900
接下来的 Dictionary 进行对比

81
00:03:54,900 --> 00:03:56,470
这里的括号也是起着同样的作用

82
00:03:56,470 --> 00:03:59,400
有一个 Dictionary

83
00:03:59,400 --> 00:04:02,570
我创建了一个 Dictionay

84
00:04:02,570 --> 00:04:04,170
使用了方括号标记

85
00:04:04,170 --> 00:04:07,140
[key:value], [key:value]

86
00:04:07,140 --> 00:04:08,910
你懂的

87
00:04:08,910 --> 00:04:12,080
如果我通过方括号访问一个 Dictionay

88
00:04:12,080 --> 00:04:14,510
它会返回一个 Optional

89
00:04:14,520 --> 00:04:17,720
举个例子 我要在 pac10teamRankings 中寻找 Ohio State

90
00:04:17,720 --> 00:04:21,190
明显就没有

91
00:04:21,190 --> 00:04:23,960
这里只包含了十个队伍 而它不在这个 Dictionay 里

92
00:04:23,960 --> 00:04:25,920
那么就应该返回 nil 对吧？

93
00:04:25,930 --> 00:04:27,930
这就是为什么你访问一个 Dictionay

94
00:04:27,930 --> 00:04:29,290
它会返回一个 Optional

95
00:04:30,760 --> 00:04:32,860
枚举 Dictionay 你需要使用 tuple

96
00:04:33,870 --> 00:04:36,170
for tuple

97
00:04:36,170 --> 00:04:39,200
(key, value) in  Dictionay

98
00:04:39,200 --> 00:04:41,370
然后在里面 key 与 value 都会被设置好

99
00:04:41,370 --> 00:04:46,940
这是非常简单的枚举 Dictionay 的方法

100
00:04:48,080 --> 00:04:53,680
那接下来我会教你们一个之前没见过的

101
00:04:53,680 --> 00:04:59,350
新的结构体 Range Range 是一个包含一种合理类型的两个点

102
00:04:59,360 --> 00:05:01,890
一个是起始点 另一个是终止点

103
00:05:01,890 --> 00:05:03,520
正如你们所想的范围那样

104
00:05:03,530 --> 00:05:07,090
之所以称为合理类型

105
00:05:07,100 --> 00:05:10,560
取决于你怎么看

106
00:05:10,570 --> 00:05:12,400
对于 Array 来说 这个合理的类型可以是 Int

107
00:05:12,400 --> 00:05:14,800
但是对于别的比如 String 来说 它就不是了

108
00:05:14,800 --> 00:05:16,100
我们稍后将会讲解这些知识

109
00:05:17,400 --> 00:05:21,840
Range 跟 Array 或者 Optional enum 一样

110
00:05:21,840 --> 00:05:24,410
是泛型的

111
00:05:24,410 --> 00:05:28,780
所以它包含了一个类型

112
00:05:28,780 --> 00:05:32,520
在 Array 中指定一个范围的方法是 Range

113
00:05:32,520 --> 00:05:35,380
因为 Array 是通过 Int 索引的

114
00:05:35,390 --> 00:05:36,850
所以 如果你想要在数组中声明 Range

115
00:05:36,850 --> 00:05:38,750
它就需要是 Int 类型的

116
00:05:38,760 --> 00:05:40,690
我在这里讲的大概差不多了

117
00:05:40,690 --> 00:05:44,660
但不完全是 但是就目前你们了解的知识来看

118
00:05:44,660 --> 00:05:47,960
这是我能想到的最好的描述方式

119
00:05:47,960 --> 00:05:51,060
它仅仅是一个包含了 startIndex 和 endIndex 的结构体

120
00:05:51,070 --> 00:05:53,270
它也是一种能让你获取

121
00:05:53,270 --> 00:05:55,940
和设置值的结构体

122
00:05:55,940 --> 00:06:01,140
所以 Array 的 Range 是 Int 的一个取值区间 至于 String

123
00:06:01,140 --> 00:06:04,040
你们可能会想 对于 String 也是这样的

124
00:06:04,040 --> 00:06:07,010
可以看到 String 的子串可以通过 Int 去指定

125
00:06:07,010 --> 00:06:08,450
但也不一定

126
00:06:08,450 --> 00:06:11,420
这里有一种特殊的类型叫做 String.index

127
00:06:11,420 --> 00:06:12,650
它是一种对 String 的索引

128
00:06:12,650 --> 00:06:16,220
我将会在后面的幻灯片中讲到

129
00:06:16,220 --> 00:06:18,960
所以 Range 就像 Array 和

130
00:06:18,960 --> 00:06:22,530
Dictionay 一样 但我们一般不会用 Range = XXX

131
00:06:22,530 --> 00:06:26,860
我们使用这种特殊的语法

132
00:06:26,860 --> 00:06:29,560
这个特殊的语法是 ...  或者

133
00:06:29,570 --> 00:06:32,730
..<

134
00:06:32,740 --> 00:06:37,000
... 意味着

135
00:06:37,010 --> 00:06:39,770
从点的左边到点的右边

136
00:06:39,780 --> 00:06:41,480
也就是 startIndex 和

137
00:06:41,480 --> 00:06:44,010
endIndex 它包含这两个值

138
00:06:44,010 --> 00:06:47,210
包含开头和结尾

139
00:06:47,220 --> 00:06:49,920
..< 意味着它只包含了开头 但是

140
00:06:49,920 --> 00:06:51,350
没有包含结尾

141
00:06:51,350 --> 00:06:54,590
所以它是一个有左闭右开的区间

142
00:06:54,590 --> 00:06:56,090
这些都是常用的 Range 的种类

143
00:06:57,020 --> 00:07:00,460
也是你们在 99% 的时候定义一个 Range 的方法

144
00:07:00,460 --> 00:07:03,290
我们不使用 Range 的结构来定义

145
00:07:03,300 --> 00:07:05,830
尽管可以创建一个 Range 的结构体

146
00:07:05,830 --> 00:07:08,900
而且你们可以将它作为参数传递给任何接受 Range 的地方

147
00:07:08,900 --> 00:07:12,040
你们可以使用真正的 Range 结构

148
00:07:12,040 --> 00:07:13,940
他们是同样的

149
00:07:13,940 --> 00:07:16,120
... 对你们而言只是一种

150
00:07:16,120 --> 00:07:18,310
创建 Range 的语法

151
00:07:18,310 --> 00:07:20,780
在 ... 的两侧

152
00:07:20,780 --> 00:07:21,790
它取决于

153
00:07:21,800 --> 00:07:22,810
你要创建哪种类型的 Range

154
00:07:22,810 --> 00:07:24,150
如果你要创建一个 Int 类型的 Range

155
00:07:24,150 --> 00:07:27,480
那么 Range 然后 Range 就是 Int 类型的了

156
00:07:27,480 --> 00:07:28,850
但是如果你们正在处理 String

157
00:07:28,850 --> 00:07:30,180
那就必须使用 String.index 类型了

158
00:07:30,190 --> 00:07:33,590
而且创建这种类型的 Range 有一点点难度 因为 String.index 类型

159
00:07:33,590 --> 00:07:36,290
不能通过数字去创建

160
00:07:36,290 --> 00:07:38,360
你必须需要一点编程技巧去创建 所以

161
00:07:38,360 --> 00:07:39,960
我们将会在大概十张幻灯片后

162
00:07:39,960 --> 00:07:45,600
来讨论这个

163
00:07:45,600 --> 00:07:48,430
你们可以 通过 for-in 来遍历一个 Range 就像我们

164
00:07:48,440 --> 00:07:50,900
使用 Dictionay 一样

165
00:07:50,900 --> 00:07:54,610
好了

166
00:07:54,610 --> 00:07:58,310
除了 Array, Dictionay, Range 接下来讨论其他的类 比如 NSObject

167
00:07:58,310 --> 00:08:00,980
NSObject 在 Objective-C 中

168
00:08:00,980 --> 00:08:02,810
是所有类的基类

169
00:08:02,810 --> 00:08:05,110
在 Swift 中 我们并没有

170
00:08:05,120 --> 00:08:07,150
这样一个基类

171
00:08:07,150 --> 00:08:10,750
然而 它有一些在 iOS 中的

172
00:08:10,750 --> 00:08:13,720
高级特性

173
00:08:13,720 --> 00:08:18,160
你的 Swift 类也可以继承自 NSObject

174
00:08:18,160 --> 00:08:19,590
我现在还不能跟你们讨论这些

175
00:08:19,590 --> 00:08:21,030
因为还有些别的你们必须得知道的东西

176
00:08:21,030 --> 00:08:23,400
我得去解释

177
00:08:23,400 --> 00:08:25,530
学下去你们就知道了

178
00:08:25,530 --> 00:08:27,800
让你们的 Swift 类继承自 NSObject 没什么麻烦的

179
00:08:27,800 --> 00:08:29,400
所以我们可以让

180
00:08:29,400 --> 00:08:31,800
CalculatorBrain 类继承自 NSObject

181
00:08:31,810 --> 00:08:33,100
没有任何影响 而且

182
00:08:33,110 --> 00:08:35,840
在将来 一旦我们学到这些进阶的东西

183
00:08:35,840 --> 00:08:38,940
我们将可以使用一些高级的特性来编写

184
00:08:38,950 --> 00:08:41,610
CalculatorBrain

185
00:08:41,610 --> 00:08:42,850
唔 我也不知道该怎么说

186
00:08:42,850 --> 00:08:45,220
就是 在 iOS 中 最好让你们所有的 Swift 类

187
00:08:45,220 --> 00:08:49,090
都继承自 NSObject. 在 iOS 中 所有的类

188
00:08:49,090 --> 00:08:50,970
比如 UIViewController 还有其他

189
00:08:50,970 --> 00:08:52,850
其实最后都是继承自 NSObject

190
00:08:52,860 --> 00:08:55,460
它是所有类的基类

191
00:08:55,460 --> 00:08:59,590
关于 NSObject 没有其他需要讲的了

192
00:08:59,600 --> 00:09:03,000
但是 就像我说的 有一些高级特性

193
00:09:03,000 --> 00:09:04,630
接下来是 NSNumber

194
00:09:04,630 --> 00:09:06,270
你们之前其实已经见过 NSNumber

195
00:09:06,270 --> 00:09:09,900
它只是一个装数字的类

196
00:09:09,910 --> 00:09:12,670
它里面有很多方法

197
00:09:12,670 --> 00:09:15,010
但是我不打算去讲 你们可以自己去看文档

198
00:09:15,010 --> 00:09:17,110
但是 这些方法 比如 doubleValue

199
00:09:17,110 --> 00:09:20,310
intValue  会将他们自身的值

200
00:09:20,310 --> 00:09:21,810
以 Int, Double 等类型返回给我们

201
00:09:23,120 --> 00:09:26,320
在 Swift 中 我们不会用太多这些东西

202
00:09:26,320 --> 00:09:28,320
因为 Swift 是强类型

203
00:09:28,320 --> 00:09:31,520
我们直接用像 Int 、 Double 这样的类型

204
00:09:31,520 --> 00:09:35,990
但在 Objective-C 的 API 中 没有遍地的 NSNumbers 类型

205
00:09:35,990 --> 00:09:39,700
这一点是你们要了解的

206
00:09:39,700 --> 00:09:42,060
接下来我会多讲一点强类型的内容

207
00:09:42,070 --> 00:09:44,770
所有这些 Swift 类型都通过巧妙桥接到 NSNumber 类型

208
00:09:44,770 --> 00:09:48,070
比如 Int, Double 等

209
00:09:48,070 --> 00:09:50,070
所以你甚至不必担心 NSNumber

210
00:09:50,070 --> 00:09:53,880
除非你要用作业中提到的 NSNumberFormatter

211
00:09:53,880 --> 00:09:58,110
因为它会返回一个 NSNumber 类型的值

212
00:09:58,110 --> 00:10:00,650
>>（学生提问）

213
00:10:00,650 --> 00:10:02,720
（学生提问）

214
00:10:02,720 --> 00:10:04,770
（学生提问）

215
00:10:04,770 --> 00:10:06,820
嗯 他的问题是 如果没有 NSObject （那么该怎么处理 NSObject 相关的东西呢）

216
00:10:06,820 --> 00:10:09,060
其实没有 NSObject 并不是造成困扰的所在

217
00:10:09,060 --> 00:10:11,060
真正的问题在于没了 NSObject 之后

218
00:10:11,060 --> 00:10:13,060
我能不能创建一个包含任意对象的数组呢

219
00:10:13,060 --> 00:10:15,930
我们下面会讲这个东西

220
00:10:15,930 --> 00:10:18,460
另一个类  NSDate 顾名思义

221
00:10:18,470 --> 00:10:21,270
可以存储日期 也可以让你获取当前日期和时间

222
00:10:22,300 --> 00:10:24,130
显然 NSDate 有非常非常多的方法

223
00:10:24,140 --> 00:10:25,870
会涉及到这些东西

224
00:10:25,870 --> 00:10:28,140
它还因为下面即将提到的另外三个类

225
00:10:28,140 --> 00:10:29,570
还会有更多相关的方法

226
00:10:29,570 --> 00:10:32,480
Calendar, DateFormatter, 和 DateComponents.

227
00:10:32,480 --> 00:10:34,280
如果你正要做日期相关的事情

228
00:10:34,280 --> 00:10:37,780
在你的应用的某个地方放置一个日期

229
00:10:37,780 --> 00:10:39,750
你就需要查看所有

230
00:10:39,750 --> 00:10:41,950
提到日期的类和文档

231
00:10:41,950 --> 00:10:43,420
因为全世界的日期

232
00:10:43,420 --> 00:10:45,220
显示方式各不相同

233
00:10:45,220 --> 00:10:48,160
不同的日历 就我们所熟知的差异

234
00:10:48,160 --> 00:10:50,890
在语言方面 年月日的顺序方面都不同

235
00:10:50,890 --> 00:10:53,030
甚至你正在用的 Gregirian 类型的标准日历也有不同的地方

236
00:10:53,030 --> 00:10:56,600
所以如果你要做在全世界都能正确显示的日历

237
00:10:56,600 --> 00:10:59,130
是需要一些技巧的

238
00:10:59,130 --> 00:11:00,870
所以我只是提醒你

239
00:11:00,870 --> 00:11:03,500
如果你要做一个应用需要用到日期时间

240
00:11:03,500 --> 00:11:06,540
你需要理解和 NSData 相关的东西

241
00:11:06,540 --> 00:11:07,970
还有 NSData

242
00:11:07,970 --> 00:11:11,280
非常简单的类 它就是一个比特包

243
00:11:11,280 --> 00:11:13,840
可以是巨大的比特包 也可以是一个小小的比特包

244
00:11:13,850 --> 00:11:18,580
不管怎样 它里面只是无类型的数据

245
00:11:18,580 --> 00:11:21,050
你可以把它看成是一个点或者一段内存

246
00:11:21,050 --> 00:11:22,250
并且你不知道它那里有什么东西

247
00:11:23,290 --> 00:11:26,690
这就是 iOS 可以四处传递无类型数据、原始数据的原因

248
00:11:26,690 --> 00:11:31,260
它就是通过这个类来传递的

249
00:11:31,260 --> 00:11:33,630
所以我们用这个类的目的是显而易见的

250
00:11:33,630 --> 00:11:36,130
你不会用太多 NSData 的东西

251
00:11:36,130 --> 00:11:38,970
因为我们不会去处理那么多原始数据

252
00:11:38,970 --> 00:11:41,430
好的 其实

253
00:11:41,440 --> 00:11:43,970
我只是想稍微提一下这其中的一些类

254
00:11:43,970 --> 00:11:47,140
它们都在文档中 你可以通过文档

255
00:11:47,140 --> 00:11:48,940
找到它们并查看更详细的内容

256
00:11:48,940 --> 00:11:50,910
下面我会再稍微提到其中的一些类 比如 Array

257
00:11:50,910 --> 00:11:54,280
Dictionary 还有 String 因为它们实在太重要了

258
00:11:54,280 --> 00:11:56,550
所以我会着重介绍它们的一部分方法

259
00:11:56,550 --> 00:11:58,550
通常 我会先谈谈 Swift 中的一些数据结构

260
00:11:58,550 --> 00:12:00,580
没问题吧

261
00:12:01,490 --> 00:12:03,120
在这些数据结构中

262
00:12:03,120 --> 00:12:04,690
有三个基础块

263
00:12:04,690 --> 00:12:06,920
而且你之前已经见过了

264
00:12:06,920 --> 00:12:08,790
其中的两个的具体内容

265
00:12:08,790 --> 00:12:10,590
它们就是类、结构体

266
00:12:10,590 --> 00:12:13,330
和枚举 它们就是那三个基础的块

267
00:12:14,460 --> 00:12:17,930
它们在声明的语法上看起来很像

268
00:12:17,930 --> 00:12:19,130
非常非常像 对吧

269
00:12:19,130 --> 00:12:21,100
唯一的差别就在声明的关键字是 class

270
00:12:21,100 --> 00:12:23,340
struct 还是 enum 除此之外看起来就是一模一样

271
00:12:23,340 --> 00:12:25,000
它们还有个非常相像的地方 它们都能拥有

272
00:12:25,010 --> 00:12:27,870
属性和方法

273
00:12:27,880 --> 00:12:31,440
Enum 本身是不能存储任何值

274
00:12:31,450 --> 00:12:34,050
你可以将值存储在枚举的关联信息中

275
00:12:34,050 --> 00:12:38,450
枚举是可以有计算型属性

276
00:12:38,450 --> 00:12:42,450
这三种数据结构都可以有函数 明白吗

277
00:12:42,460 --> 00:12:44,290
理解这点非常的重要

278
00:12:44,290 --> 00:12:45,920
它们在那方面看起来非常的相似

279
00:12:47,190 --> 00:12:49,390
结构体和类更甚

280
00:12:49,390 --> 00:12:51,090
它们甚至都可以有初始化的构造器

281
00:12:51,100 --> 00:12:53,800
我们后面的幻灯片中会详细地

282
00:12:53,800 --> 00:12:55,460
谈到这个构造器

283
00:12:55,470 --> 00:12:56,700
它们在许多方面都非常相似

284
00:12:56,700 --> 00:12:58,930
但仍然有几个不同的地方

285
00:12:58,940 --> 00:13:00,030
对吧

286
00:13:00,040 --> 00:13:01,130
类是三者中唯一拥有

287
00:13:01,140 --> 00:13:04,000
继承的性质

288
00:13:04,010 --> 00:13:05,240
显而易见

289
00:13:05,240 --> 00:13:07,470
这是一种确定类是什么东西的主要定义

290
00:13:07,480 --> 00:13:08,040
就是它有继承性质

291
00:13:09,710 --> 00:13:12,080
我也会讲

292
00:13:12,080 --> 00:13:13,750
内省和转型

293
00:13:13,750 --> 00:13:16,650
都是属于类的性质

294
00:13:16,650 --> 00:13:19,550
所以我所说所有关于转换的内容 你不能应用到结构体上

295
00:13:21,150 --> 00:13:23,220
而我们要明白的三种结构最重要的区别

296
00:13:23,220 --> 00:13:24,620
在我们接下来的 demo 中会遇见的

297
00:13:24,620 --> 00:13:27,560
就是 value type （值类型）与 reference type （引用类型）

298
00:13:27,560 --> 00:13:29,660
结构体和枚举的传递和

299
00:13:29,660 --> 00:13:32,490
存储是通过拷贝过的变量

300
00:13:32,500 --> 00:13:34,110
对吗？

301
00:13:34,110 --> 00:13:35,730
类属于引用类型

302
00:13:35,730 --> 00:13:37,630
换句话说 我们传递的是这些对象的指针

303
00:13:37,630 --> 00:13:39,170
而这些对象本身存储在堆内存中

304
00:13:39,170 --> 00:13:41,400
需要记住的是 堆内存中的对象

305
00:13:41,400 --> 00:13:43,800
系统会自动为我们管理（ARC）

306
00:13:43,810 --> 00:13:45,440
这样一来

307
00:13:45,440 --> 00:13:47,070
我们就没有必要去开辟和释放内存了

308
00:13:47,080 --> 00:13:48,210
我们创建想要的对象后

309
00:13:48,210 --> 00:13:49,710
一旦没有任何指针指向这些对象

310
00:13:49,710 --> 00:13:52,310
这些对象就会被马上清理掉 注意 这不是垃圾回收机制 明白吗？

311
00:13:52,310 --> 00:13:53,850
这是引用计数 自动引用计数 （ARC）

312
00:13:53,850 --> 00:13:56,250
我还想多讲一下

313
00:13:56,250 --> 00:13:58,220
值类型和引用类型的区别 因为分清它们

314
00:13:58,220 --> 00:13:59,780
真的很重要

315
00:13:59,790 --> 00:14:01,890
因为人们在写代码的时候并不是很清楚

316
00:14:01,890 --> 00:14:04,720
他们背后的区别和原理

317
00:14:04,720 --> 00:14:08,320
对于值类型 比如结构体 它表示

318
00:14:08,330 --> 00:14:11,590
当你将它传递给方法的时候 方法使用的是它的拷贝

319
00:14:11,600 --> 00:14:14,230
当你将它赋值给另外一个变量的时候也是如此

320
00:14:14,230 --> 00:14:15,430
理解这个是很重要的

321
00:14:15,430 --> 00:14:16,630
比如

322
00:14:16,630 --> 00:14:20,540
let x = Array<> 然后 let y = x

323
00:14:20,540 --> 00:14:22,500
这实际上是将 x 的值拷贝一份给了 y

324
00:14:22,510 --> 00:14:25,610
或许这背后是以惰性的方式拷贝的 总之

325
00:14:25,610 --> 00:14:28,270
你只需要知道这是一份拷贝 明白吗？

326
00:14:29,440 --> 00:14:31,010
如果你希望赋值后可以修改它

327
00:14:31,010 --> 00:14:33,180
你只需要将这个常量赋值给一个变量（var y = x）

328
00:14:33,180 --> 00:14:34,710
之后 你就可以修改它了

329
00:14:34,720 --> 00:14:36,480
当你修改你得到的值的时候

330
00:14:36,480 --> 00:14:38,980
你修改的是你拷贝来的值 而不是修改

331
00:14:38,990 --> 00:14:42,490
之前被拷贝的那个值（修改 y 不会影响 x ） 明白吗？

332
00:14:42,490 --> 00:14:47,720
因为上诉原理 当你定义一个 struct 或者一个 enum

333
00:14:47,730 --> 00:14:51,860
并且为它添加方法来修改它的状态时

334
00:14:51,860 --> 00:14:56,230
你必须在方法前面加上 mutating 关键字。

335
00:14:56,230 --> 00:14:59,300
这样当其他人

336
00:14:59,300 --> 00:15:02,040
需要使用你的 enum 或 struct 的时候

337
00:15:02,040 --> 00:15:05,170
他们就必须在一个变量上来调用这些 mutating 函数

338
00:15:05,180 --> 00:15:07,610
而不是在一个常量上

339
00:15:07,610 --> 00:15:13,550
引用类型存储在堆中

340
00:15:13,550 --> 00:15:19,520
即使是一个常量指针 也会导致引用计数增加

341
00:15:19,520 --> 00:15:21,520
对于指向一个对象的常量指针

342
00:15:21,520 --> 00:15:24,260
你同样可以向这个常量指针发送消息 来修改所指对象里面的属性

343
00:15:24,260 --> 00:15:26,190
因为这个对象存储在堆里面

344
00:15:26,190 --> 00:15:28,130
而你可以用一个指针来引用它

345
00:15:28,130 --> 00:15:29,930
当你把这个这个对象传递个一个方法的时候

346
00:15:29,930 --> 00:15:31,260
你传递的是指向这个对象的指针 所以

347
00:15:31,260 --> 00:15:32,960
如果这个方法修改了这个对象

348
00:15:32,970 --> 00:15:35,570
那它修改的就是存储在堆内存中的那个对象了

349
00:15:35,570 --> 00:15:37,400
明白吗？

350
00:15:37,400 --> 00:15:41,800
那么如何正确选择这两种数据类型呢？

351
00:15:41,810 --> 00:15:42,890
事实上

352
00:15:42,890 --> 00:15:43,970
百分之九十的情况下我们都会使用类

353
00:15:43,980 --> 00:15:45,740
因为这是面向对象的编程语言

354
00:15:45,740 --> 00:15:48,340
当你使用类时 你就可以使用诸如继承

355
00:15:48,350 --> 00:15:49,910
重写之类的特性了

356
00:15:49,910 --> 00:15:53,780
而结构体更适合基础数据类型

357
00:15:53,780 --> 00:15:57,450
比如 Double, Int, Array, Dictionaries, String。

358
00:15:57,450 --> 00:16:00,820
你知道 这些东西都非常基础 而且

359
00:16:00,820 --> 00:16:03,120
当我们涉及到绘图的时候 我们会更多地使用 points

360
00:16:03,130 --> 00:16:07,130
sizes rectangles 它们都是都是结构体

361
00:16:07,130 --> 00:16:09,160
但是 我们的大多数操作都是

362
00:16:09,160 --> 00:16:12,030
与类打交道

363
00:16:12,030 --> 00:16:13,800
而且系统会为你管理内存

364
00:16:13,800 --> 00:16:18,770
所以现在使用类是一件非常轻松的事情了

365
00:16:19,940 --> 00:16:22,220
好的 接下来

366
00:16:22,220 --> 00:16:24,510
我想讨论一下方法

367
00:16:24,510 --> 00:16:26,180
很明显

368
00:16:27,450 --> 00:16:29,410
当你重写父类的方法的时候

369
00:16:29,410 --> 00:16:33,280
你必须在该方法前面加上 override 关键字 记住了吗？

370
00:16:34,490 --> 00:16:37,050
你也可以把一个方法标记为 final

371
00:16:37,050 --> 00:16:39,550
final 表示这个方法不能被重写

372
00:16:39,560 --> 00:16:41,690
如果有人继承了你的类

373
00:16:41,690 --> 00:16:43,320
他们不能重写那些被标记为 final 的方法

374
00:16:43,330 --> 00:16:46,130
你还可以把整个类都标记为 final  这表示

375
00:16:46,130 --> 00:16:47,560
谁都不能更改这个类

376
00:16:47,560 --> 00:16:49,630
甚至不能继承这个类。

377
00:16:49,630 --> 00:16:51,400
明白了吗？

378
00:16:51,400 --> 00:16:58,500
类和实例都有自己的方法和属性

379
00:16:58,510 --> 00:17:00,570
比如  Array 就是一个类

380
00:17:00,570 --> 00:17:04,040
而具体的一个 Array 就是一个实例

381
00:17:04,040 --> 00:17:04,940
实例封装有自己数据

382
00:17:04,940 --> 00:17:07,240
明白吗？

383
00:17:07,250 --> 00:17:09,550
我们来看看下面这段代码

384
00:17:09,550 --> 00:17:11,620
我定义里一个 Double 类型的变量 d

385
00:17:11,620 --> 00:17:13,920
这个是一个 Double 变量

386
00:17:13,920 --> 00:17:17,620
然后向 d 发送 isSignMinus 消息 来判断它

387
00:17:17,620 --> 00:17:19,720
是否是负数

388
00:17:19,720 --> 00:17:21,960
然后我把 d 设置为

389
00:17:21,960 --> 00:17:23,860
它自己的绝对值

390
00:17:23,860 --> 00:17:28,500
所以  isSignMius 是实例 d 的变量

391
00:17:28,500 --> 00:17:30,030
或者说是实例 d 的一个属性

392
00:17:30,030 --> 00:17:32,800
你通过对一个具体的 Double 类型的实例 d 发送 isSignMius 消息

393
00:17:32,800 --> 00:17:34,670
来判实例 d 是否是负数

394
00:17:34,670 --> 00:17:39,210
然而  abs 是 Double 这个类的方法（所有对象共享）

395
00:17:39,210 --> 00:17:42,370
你向这个方法中传入你需要操作的 Double 类型的实例

396
00:17:42,380 --> 00:17:44,380
它返回你想要的结果

397
00:17:44,380 --> 00:17:46,380
这里 你并没有向一个特定的 Double 实例发送消息

398
00:17:46,380 --> 00:17:48,380
而是向 Double 这个类在发送消息

399
00:17:48,380 --> 00:17:49,950
在这个例子中的结构体、类型

400
00:17:49,950 --> 00:17:51,720
明白我的意思吗？

401
00:17:51,720 --> 00:17:54,720
你把一些方法发送给实例

402
00:17:54,720 --> 00:17:57,590
一些特殊的方法 你可以发送给类型

403
00:17:57,590 --> 00:18:00,620
所以是两种不一样的方法

404
00:18:00,630 --> 00:18:02,590
但他们的规则是一样的

405
00:18:02,590 --> 00:18:04,730
区别就是你叫谁去完成任务

406
00:18:05,660 --> 00:18:08,100
你声明一个类方法或者或者一个 property

407
00:18:08,100 --> 00:18:11,030
之前必须使用静态变量

408
00:18:11,030 --> 00:18:14,470
就像绝对值 就是

409
00:18:14,470 --> 00:18:16,840
static func abs(d: Double) -> Double

410
00:18:16,840 --> 00:18:19,340
这就规定了你要向 Double 类发消息

411
00:18:19,340 --> 00:18:21,880
而不是某个特定的 Double 实例

412
00:18:21,880 --> 00:18:24,740
在一个类中你使用关键字 class 而不是 static

413
00:18:24,750 --> 00:18:26,610
因为它被称为类方法

414
00:18:27,780 --> 00:18:28,810
明白吗？

415
00:18:28,820 --> 00:18:31,050
我不想让你们感到困惑

416
00:18:31,050 --> 00:18:33,290
当你看见一个类似于abs的方法

417
00:18:33,290 --> 00:18:35,100
被发送给 Double 类时

418
00:18:35,100 --> 00:18:36,920
那看起来有一点奇怪 但是很正常

419
00:18:36,920 --> 00:18:38,220
明白吗？

420
00:18:38,220 --> 00:18:39,520
那么……

421
00:18:39,530 --> 00:18:42,230
类方法和实例方法该如何选择呢？

422
00:18:42,230 --> 00:18:44,800
如果你正在进行通用性工作

423
00:18:44,800 --> 00:18:46,210
你不需要针对

424
00:18:46,210 --> 00:18:47,630
特定的 Double 实例做修改

425
00:18:47,630 --> 00:18:50,700
只是通用的一些步骤 那么你可以使用两种方式

426
00:18:50,700 --> 00:18:53,900
有时候你会用类方法

427
00:18:53,910 --> 00:18:56,310
来创建对象并供外部使用

428
00:18:56,310 --> 00:18:59,010
比如共享对象 如果你有一个

429
00:18:59,010 --> 00:19:00,540
只有一个实例的对象

430
00:19:00,540 --> 00:19:03,380
也许你会要求那个类型

431
00:19:03,380 --> 00:19:07,120
给我那个共享的实例 明白了吗？

432
00:19:07,120 --> 00:19:08,580
这是通用步骤和

433
00:19:08,580 --> 00:19:10,880
创建对象之前的东西

434
00:19:10,890 --> 00:19:12,990
类方法 我不想说很少见

435
00:19:12,990 --> 00:19:15,960
类方法并不是非常常见 你们在 iOS 里面会看到

436
00:19:15,960 --> 00:19:18,490
偶尔还会使用

437
00:19:18,490 --> 00:19:21,560
你可能会使用类方法而非全局方法

438
00:19:21,560 --> 00:19:23,800
你可以没有全局方法

439
00:19:23,800 --> 00:19:25,930
当然是在 Swift 中

440
00:19:25,930 --> 00:19:28,270
但是你可能真的喜欢创建类方法

441
00:19:28,270 --> 00:19:31,670
以便那个方法关联到

442
00:19:31,670 --> 00:19:33,540
类型和其他东西 除非它真的是

443
00:19:33,540 --> 00:19:35,840
一个世界通用的全局方法

444
00:19:35,840 --> 00:19:39,340
它跟一个特殊的类无关

445
00:19:39,350 --> 00:19:41,710
通常情况下你将会把它们当做一个类使用

446
00:19:41,710 --> 00:19:44,480
一个类方法

447
00:19:44,480 --> 00:19:46,450
对吧？

448
00:19:46,450 --> 00:19:49,390
现在让我们来谈谈

449
00:19:49,390 --> 00:19:50,900
方法的参数名

450
00:19:50,900 --> 00:19:52,420
这会是速成课

451
00:19:52,420 --> 00:19:54,360
你们已经阅读了我希望你们知道的 在文档中所有的相关内容

452
00:19:54,360 --> 00:19:57,690
但是 方法中的所有参数都有

453
00:19:57,690 --> 00:19:58,730
一个内部的名字和一个外部的名字

454
00:19:58,730 --> 00:20:00,430
所以 让我们来讨论一下这些参数

455
00:20:00,430 --> 00:20:00,990
明白了么？

456
00:20:01,000 --> 00:20:03,060
所以 在下面

457
00:20:03,060 --> 00:20:05,130
foo , 参数 foo 在这里

458
00:20:05,130 --> 00:20:07,070
明白了么 它有一个内部命名和一个外部命名

459
00:20:07,070 --> 00:20:09,870
所以 内部的名字 和冒号有一点接近

460
00:20:09,870 --> 00:20:12,640
是在方法中拥有一个本地变量的名字

461
00:20:12,640 --> 00:20:15,470
在这个内部名称中

462
00:20:15,480 --> 00:20:18,610
外部命名是一个名字

463
00:20:18,610 --> 00:20:22,250
调用者准备使用的 放在冒号之前

464
00:20:22,250 --> 00:20:23,280
明白了么？

465
00:20:23,280 --> 00:20:24,310
当他们调用东西的时候

466
00:20:24,320 --> 00:20:26,820
所以在这里 我要调用一个东西

467
00:20:26,820 --> 00:20:30,000
在 foo 方法中我定义了他们

468
00:20:30,000 --> 00:20:33,190
所以 在这里你可以看到 我通过 foo(external:123) 来调用 foo

469
00:20:33,190 --> 00:20:37,590
尽管 foo 的内部 那东西叫做 internal

470
00:20:38,800 --> 00:20:39,930
明白了吗？

471
00:20:39,930 --> 00:20:41,400
所以 你可以同时拥有外部的

472
00:20:41,400 --> 00:20:42,360
以及内部的名字 他们是不同的

473
00:20:43,600 --> 00:20:45,030
你可以添加一个下划线

474
00:20:45,030 --> 00:20:48,470
记住 在 Swift 中下划线是会被忽略的

475
00:20:48,470 --> 00:20:50,800
如果你不想有调用者

476
00:20:50,810 --> 00:20:52,000
使用一个外部命名

477
00:20:52,010 --> 00:20:53,410
现在来看 bar 方法

478
00:20:53,410 --> 00:20:55,340
它调用了 foo 方法

479
00:20:55,340 --> 00:20:57,270
可是却没有写 internal: 或者 external:

480
00:20:57,280 --> 00:20:59,280
它只是把参数留在了那儿

481
00:20:59,280 --> 00:21:00,550
所以 下划线说：

482
00:21:00,550 --> 00:21:03,280
“我不想拥有一个外部命名”

483
00:21:03,280 --> 00:21:07,420
其实 函数的第一个参数的

484
00:21:07,420 --> 00:21:09,950
默认外部命名就是下划线

485
00:21:10,990 --> 00:21:12,390
所以 foo 方法只有一个参数

486
00:21:12,390 --> 00:21:14,690
所以 它是第一个参数也是唯一的一个参数

487
00:21:14,690 --> 00:21:17,730
你可以看到它当你从 bar 处调用它

488
00:21:17,730 --> 00:21:19,330
你不会写 “internal:”

489
00:21:19,330 --> 00:21:22,430
因为下划线是默认的

490
00:21:23,370 --> 00:21:25,330
现在 如果你不想让它作为默认的值

491
00:21:25,330 --> 00:21:28,500
你可以强制第一个参数是必要的

492
00:21:28,500 --> 00:21:31,600
通过添加一个 “#” 井号标志 一个小标签 明白？

493
00:21:31,610 --> 00:21:34,340
这使得你不得不通过 internal: 来调用函数

494
00:21:34,340 --> 00:21:36,810
明白吗？

495
00:21:37,950 --> 00:21:42,310
对于另外的参数 不是第一个参数

496
00:21:42,320 --> 00:21:43,880
是其他的参数

497
00:21:43,880 --> 00:21:46,550
他们的名称 内部命名或外部命名

498
00:21:46,550 --> 00:21:49,390
是必须要写的 明白？

499
00:21:49,390 --> 00:21:52,460
除非 你设置或者改变了它的名称

500
00:21:52,460 --> 00:21:55,430
这个因人而异 你可以将外部命名区别于其他的参数

501
00:21:55,430 --> 00:21:58,160
这个不仅限于第一个参数

502
00:21:58,160 --> 00:22:01,000
还有 你可以在这里添加一个下划线

503
00:22:01,000 --> 00:22:03,070
来让第二个变量没有参数名

504
00:22:03,070 --> 00:22:06,940
我不建议这样做 因为这不是标准的做法

505
00:22:06,940 --> 00:22:10,610
要想让这样一个接受两个参数的方法的第二个参数

506
00:22:10,610 --> 00:22:13,940
不需要名称

507
00:22:13,940 --> 00:22:16,380
因为在 Swift 中 你一般会认为方法的名字

508
00:22:16,380 --> 00:22:20,010
即描述了它的第一个参数是什么

509
00:22:20,020 --> 00:22:22,480
你的方法的第一个参数 始终需要

510
00:22:22,480 --> 00:22:24,420
基于此方法的名字

511
00:22:24,420 --> 00:22:25,620
因为方法完成了某些功能

512
00:22:25,620 --> 00:22:27,420
它在某个变量之上进行操作

513
00:22:27,420 --> 00:22:29,300
那个变量就应该是第一个参数

514
00:22:29,310 --> 00:22:31,190
这就是我们不需要第一个参数名的原因

515
00:22:31,190 --> 00:22:32,460
至于其余的参数

516
00:22:32,460 --> 00:22:33,660
如果你理解了它们在干什么之后

517
00:22:33,660 --> 00:22:35,390
你想要给它们命名

518
00:22:35,400 --> 00:22:37,130
说明这个参数是用来干什么的

519
00:22:37,130 --> 00:22:40,030
在其他的语言中 你经常会遇到

520
00:22:40,030 --> 00:22:42,930
非常非常长的方法命名告诉你某个方法

521
00:22:42,930 --> 00:22:44,400
干什么、使用了那些变量

522
00:22:44,400 --> 00:22:47,400
然后你就能够在圆括号中将这四个参数

523
00:22:47,410 --> 00:22:49,810
一一对应起来

524
00:22:49,810 --> 00:22:51,940
而在 Swift 中 方法名是根据

525
00:22:51,940 --> 00:22:53,580
它的参数来命名的

526
00:22:53,580 --> 00:22:55,010
比较方便去阅读

527
00:22:55,010 --> 00:22:57,510
也比较方便去理解 我们讨论这些有什么意义呢？

528
00:22:57,510 --> 00:22:59,710
显然 我并不推荐这么做

529
00:22:59,720 --> 00:23:03,650
我不推荐在参数之前加上下划线

530
00:23:03,650 --> 00:23:05,080
虽然有一些是特例 但是

531
00:23:05,090 --> 00:23:08,690
一般来说我不推荐这么做

532
00:23:08,690 --> 00:23:09,860
明白了吗？

533
00:23:09,860 --> 00:23:10,990
接来下是 properties

534
00:23:10,990 --> 00:23:13,060
让我们一起来看看什么是 properties

535
00:23:13,060 --> 00:23:15,330
显然  property observers 是非常关键的

536
00:23:15,330 --> 00:23:17,330
而且我们会大量使用它

537
00:23:17,330 --> 00:23:19,450
它们使用起来很简单

538
00:23:19,450 --> 00:23:21,570
在这里你有一个 someStoredProperty

539
00:23:21,570 --> 00:23:23,230
它是 Int 类型的 值为42

540
00:23:23,240 --> 00:23:26,940
其实我并不需要在这里写这些 我只是把它放在这里

541
00:23:26,940 --> 00:23:29,210
这些一直贯穿在我的 Slides 中

542
00:23:29,210 --> 00:23:32,880
绿色 我将这部分标注为绿色 因为

543
00:23:32,880 --> 00:23:35,780
我想让你们注意到的是 这部分是代码

544
00:23:35,780 --> 00:23:37,680
明白了吗？这是被标注为绿色的部分的意义

545
00:23:37,680 --> 00:23:40,350
黄色部分通常表示

546
00:23:40,350 --> 00:23:42,220
这是我正在跟你们讲的东西

547
00:23:42,220 --> 00:23:43,420
这是你们需要关心的部分

548
00:23:43,420 --> 00:23:44,590
所以 你可以把黄色部分

549
00:23:44,590 --> 00:23:45,750
认为是一种高亮

550
00:23:45,750 --> 00:23:47,300
明白了吗？

551
00:23:47,310 --> 00:23:48,860
回到我们之前讲的 这里我拥有一个 someStoredProperty

552
00:23:48,860 --> 00:23:51,190
它存储了 Int 类型的42

553
00:23:51,190 --> 00:23:54,390
需要注意的是 这是一个

554
00:23:54,400 --> 00:23:56,100
直接存储、不需要计算过程的 property

555
00:23:56,100 --> 00:23:58,430
我仍旧在它之后放置了一对花括号

556
00:23:58,430 --> 00:24:00,100
花括号的意思并不是说

557
00:24:00,100 --> 00:24:02,470
这个 property 是通过计算得到的

558
00:24:02,470 --> 00:24:05,670
而是 willSet 和 didSet 来得到的 明白了吗？

559
00:24:05,670 --> 00:24:09,270
所以在 willSet 和 didSet 之后的

560
00:24:09,270 --> 00:24:11,390
小段的代码

561
00:24:11,390 --> 00:24:13,510
会在设置或获取 property 的值时被调用

562
00:24:13,510 --> 00:24:16,880
这就是它为什么叫 property observer 的原因

563
00:24:16,880 --> 00:24:20,020
因为这段代码 observe 这个 property 的设置或获取方法

564
00:24:20,020 --> 00:24:21,980
willSet 这个方法会在设置 property 值之前被调用

565
00:24:21,990 --> 00:24:25,590
同理 didSet 这个方法会在设置 property 值之后被调用

566
00:24:25,590 --> 00:24:27,240
在 willSet 方法中

567
00:24:27,240 --> 00:24:28,890
你会有一个特殊的 newValue 变量

568
00:24:28,890 --> 00:24:31,230
这是 property 将要被设置的新的值

569
00:24:31,230 --> 00:24:34,230
同样 在 didSet 方法中 你会有一个特殊的 oldValue 变量

570
00:24:34,230 --> 00:24:36,530
这是 property 要被设置之前的值

571
00:24:36,530 --> 00:24:39,370
明白了吗？

572
00:24:39,370 --> 00:24:42,200
现在 你可以在这两种情况下使用它们

573
00:24:42,200 --> 00:24:44,600
一种情况是你在自己的类中拥有

574
00:24:44,610 --> 00:24:46,660
stored property

575
00:24:46,660 --> 00:24:48,710
当其他方法的设置它的值时 你想要获得一个 notice

576
00:24:48,710 --> 00:24:50,010
然后你可以根据这个 notice 做一些事情

577
00:24:50,010 --> 00:24:54,380
另一种情况是你继承了某些类

578
00:24:54,380 --> 00:24:57,310
你并不需要对这些类中的 property 做什么修改

579
00:24:57,320 --> 00:24:59,720
但它们被改变时你想知道

580
00:24:59,720 --> 00:25:00,750
明白了吗？

581
00:25:00,750 --> 00:25:01,950
所以 你可以在某些

582
00:25:01,950 --> 00:25:04,720
继承的类之上

583
00:25:04,720 --> 00:25:05,520
重写继承自父类的 willSet 和 didSet

584
00:25:06,520 --> 00:25:07,860
明白了吗？

585
00:25:07,860 --> 00:25:10,690
在这里 我们能够做些什么？

586
00:25:10,690 --> 00:25:13,530
在 iOS 开发中非常常见的做法是

587
00:25:13,630 --> 00:25:15,010
更新用户界面（UI）

588
00:25:16,020 --> 00:25:18,400
举例 你有一个 view controller

589
00:25:18,400 --> 00:25:21,440
或者你有一个 view  你改变了其中的某些 property

590
00:25:21,440 --> 00:25:25,040
改变其中某些 property 意味着

591
00:25:25,040 --> 00:25:28,140
在 didSet 中 你将对用户界面进行更新

592
00:25:28,140 --> 00:25:30,280
这样说能理解一点了吗？

593
00:25:30,280 --> 00:25:32,080
好

594
00:25:32,080 --> 00:25:33,880
所以  property observers 是非常酷的

595
00:25:33,880 --> 00:25:35,850
同时也是追踪哪些 property 被设置或获取的

596
00:25:35,850 --> 00:25:36,850
一种好方法

597
00:25:38,320 --> 00:25:42,620
接下来 我们谈谈惰性实例化

598
00:25:42,620 --> 00:25:45,490
如果你在 property 声明前加了 lazy  这意味着

599
00:25:45,490 --> 00:25:49,230
它只会在被用到的时候才会初始化

600
00:25:50,330 --> 00:25:53,460
比如它以被赋值的操作执行初始化

601
00:25:53,460 --> 00:25:55,760
那么这个赋值的动作会在这个 property 实际被用到的时候

602
00:25:55,770 --> 00:25:59,300
才会执行

603
00:25:59,300 --> 00:26:03,870
你也可以在初始化的时候在后面放一个圆括号

604
00:26:03,870 --> 00:26:06,710
也就是通过执行这个闭包

605
00:26:06,710 --> 00:26:10,040
来初始化这个属性

606
00:26:10,050 --> 00:26:15,180
但是这个闭包只有在 property 被用到的时候才会执行

607
00:26:15,180 --> 00:26:19,020
在 lazy property 中

608
00:26:19,020 --> 00:26:23,590
你甚至可以调用一个方法来初始化

609
00:26:23,590 --> 00:26:27,290
如果你不把 property 标记为 lazy 这样做是不允许的

610
00:26:27,290 --> 00:26:29,410
因为在类初始化之前

611
00:26:29,410 --> 00:26:31,530
类里的方法都是不可以调用的

612
00:26:31,530 --> 00:26:33,530
这好像是个不可以违背的规定

613
00:26:33,530 --> 00:26:34,730
但是在这种情况

614
00:26:34,730 --> 00:26:37,230
在属性全部初始化以前确实不可以调用方法

615
00:26:37,240 --> 00:26:39,970
直到有人试图 get 这个 property

616
00:26:39,970 --> 00:26:41,400
它就会被初始化了

617
00:26:41,410 --> 00:26:43,340
所以方法就可以调用了

618
00:26:43,340 --> 00:26:45,770
到这你能看出用 lazy 的优势了吗？

619
00:26:45,780 --> 00:26:47,790
好

620
00:26:47,790 --> 00:26:49,810
这个 lazy 特性依然满足“所有属性必须

621
00:26:49,810 --> 00:26:53,280
初始化”的规则

622
00:26:53,280 --> 00:26:56,680
即使它在被用到以前并没有被初始化

623
00:26:56,690 --> 00:26:58,490
它依然遵循这个规则

624
00:27:00,290 --> 00:27:04,520
但是 只有 var 才可以用 lazy 初始化这个特性

625
00:27:04,530 --> 00:27:06,340
因为 let 也就是类里的常量

626
00:27:06,340 --> 00:27:11,130
都必须在类的初始化方法里初始化

627
00:27:11,130 --> 00:27:14,100
只有 var 可以用 lazy let 不可以

628
00:27:14,100 --> 00:27:19,100
这个特性一般会用来处理一些错综复杂的初始化依赖

629
00:27:19,110 --> 00:27:20,900
正是因为在类的内部的规则：在做任何事之前

630
00:27:20,910 --> 00:27:22,570
所有的 property 都必须被初始化

631
00:27:22,570 --> 00:27:24,470
有时类会和它的父类有一些交集

632
00:27:24,480 --> 00:27:27,110
举个例子

633
00:27:27,110 --> 00:27:29,880
当有些 property 将要被初始化时 需要你或者你的父类做一些事情

634
00:27:29,880 --> 00:27:32,250
但是你在做这些事情之前还需要先解决一些事情

635
00:27:32,250 --> 00:27:35,280
这时候你就会有点卡住

636
00:27:35,290 --> 00:27:37,290
这时候你就可以让

637
00:27:37,290 --> 00:27:40,250
某些 property 依赖于它们的 lazy 初始化

638
00:27:40,260 --> 00:27:45,190
这样的话 当有东西需要这个 property 的时候 它才会被初始化

639
00:27:47,000 --> 00:27:48,590
明白了吗？关于 lazy 大家有问题吗？

640
00:27:48,600 --> 00:27:53,330
非常好的特性

641
00:27:53,330 --> 00:27:55,330
准确的来说 就跟这个特性的名字一样 就是懒懒地等着别人

642
00:27:55,340 --> 00:27:58,340
需要这个属性的时候 这个属性才开始初始化

643
00:27:58,340 --> 00:27:59,740
明白？

644
00:27:59,740 --> 00:28:02,540
下边咱们来聊聊初始化

645
00:28:02,540 --> 00:28:06,140
在说这个话题之前我得喝点水 因为初始化很复杂

646
00:28:08,710 --> 00:28:10,650
希望我没事儿

647
00:28:10,650 --> 00:28:11,810
就是怕我嗓子坏了

648
00:28:11,820 --> 00:28:15,680
好了 init

649
00:28:15,690 --> 00:28:18,390
什么时候需要一个 init 方法？

650
00:28:18,390 --> 00:28:20,340
事实上你知道吗？

651
00:28:20,340 --> 00:28:22,290
大多数时候并不需要 init 方法

652
00:28:22,290 --> 00:28:26,330
我们之前演示过 CalculatorBrain 类的 init 方法

653
00:28:26,330 --> 00:28:27,760
在那 init 确实是有用而且必要的

654
00:28:28,900 --> 00:28:29,860
但是实际上大多数时候不太需要 init

655
00:28:29,870 --> 00:28:34,000
因为类或者结构体里边大部分的常量和变量都会

656
00:28:34,000 --> 00:28:37,800
通过赋值被初始化

657
00:28:37,810 --> 00:28:40,110
或者有些属性是 Optional 的

658
00:28:40,110 --> 00:28:41,510
这样即使他们是 nil 也没问题

659
00:28:41,510 --> 00:28:46,110
也可以在之后在给他们赋值 就像 StoryBoard 里的 outlet 一样

660
00:28:46,110 --> 00:28:50,750
又或者可以用闭包来初始化

661
00:28:50,750 --> 00:28:52,280
理解这个吗？就像我之前演示的

662
00:28:52,280 --> 00:28:54,750
lazy 那个特性一样 你一样可以用闭包来初始化一个

663
00:28:54,750 --> 00:28:57,550
非 lazy 的属性

664
00:28:57,560 --> 00:28:59,220
不同的是这个闭包会立即执行并且

665
00:28:59,220 --> 00:29:01,320
闭包里没有任何与其他实例变量有关系的东西

666
00:29:01,330 --> 00:29:03,830
因为这个闭包会在初始化全部完成

667
00:29:03,830 --> 00:29:06,660
以前就执行了

668
00:29:06,660 --> 00:29:09,860
但是你仍然可以通过闭包

669
00:29:09,870 --> 00:29:11,930
做一些计算来赋值

670
00:29:13,170 --> 00:29:16,840
你也可以使用 lazy 机制 从而避免使用 init 方法

671
00:29:16,840 --> 00:29:18,770
所以有很多方法来避免使用 init

672
00:29:19,970 --> 00:29:24,010
但如果你确实需要一个 init 方法的时候

673
00:29:24,010 --> 00:29:26,510
该怎么做呢？

674
00:29:26,510 --> 00:29:28,380
因为 init 方法会有一些很有趣

675
00:29:28,380 --> 00:29:31,220
的互相依赖关系

676
00:29:31,220 --> 00:29:34,950
它并不像你可能想象的那么简单

677
00:29:34,950 --> 00:29:37,650
在一些情况下 init 方法会自动生成

678
00:29:37,660 --> 00:29:39,590
也就是说 init 已经给你准备好了

679
00:29:45,230 --> 00:29:47,600
基类就是指没有父类的类

680
00:29:47,600 --> 00:29:48,660
比如 CalculatorBrain

681
00:29:48,670 --> 00:29:50,460
如果它的所有的 property 都有默认值

682
00:29:50,470 --> 00:29:53,930
那么你就会自动得到一个没有参数的 init 方法

683
00:29:53,940 --> 00:29:56,500
所以尽管我们没有为 CalculatorBrains 类写 init 方法

684
00:29:56,510 --> 00:29:58,100
我们依然可以写

685
00:29:58,110 --> 00:30:00,370
brain = CalculatorBrain()

686
00:30:00,380 --> 00:30:03,280
这是因为我们有一个默认的 init

687
00:30:03,280 --> 00:30:06,280
我们默认使用等于某值初始化

688
00:30:06,280 --> 00:30:07,460
所以

689
00:30:07,460 --> 00:30:08,650
这是一种得到 init 的方法

690
00:30:08,650 --> 00:30:11,420
结构体 不是类 但是结构体

691
00:30:11,420 --> 00:30:15,320
它将默认得到一个将所有 property 作为参数的初始化方法

692
00:30:15,320 --> 00:30:18,620
仅当没有初始化函数时

693
00:30:18,620 --> 00:30:21,890
因此 如果你有一个结构体并且没有初始化方法

694
00:30:21,890 --> 00:30:24,890
你会得到一个默认的初始化方法

695
00:30:24,900 --> 00:30:27,930
并且所有的参数和变量匹配 如果有的话

696
00:30:27,930 --> 00:30:29,970
所有的 var 和 let 明白吧？

697
00:30:29,970 --> 00:30:35,100
一个结构体 它有两个 property  x 和 y

698
00:30:35,110 --> 00:30:38,940
你可以看到我这里有一个 init 方法 x 是 Int类型

699
00:30:38,940 --> 00:30:41,510
y 是 String 类型

700
00:30:41,510 --> 00:30:44,180
我不要实现它

701
00:30:44,180 --> 00:30:45,680
它就可以被调用

702
00:30:45,680 --> 00:30:48,180
可以通过圆括号 提供 x 和 y 的值来

703
00:30:48,180 --> 00:30:51,320
初始化 MyStruct

704
00:30:51,320 --> 00:30:52,850
明白？

705
00:30:52,850 --> 00:30:54,050
好的

706
00:30:54,060 --> 00:30:56,720
你可以在 init 里面做什么？

707
00:30:56,720 --> 00:30:57,890
好 我们看到

708
00:30:57,890 --> 00:30:59,060
我们在 CalculatorBrain 里做了什么

709
00:30:59,060 --> 00:31:00,760
我们初始化了些 property

710
00:31:00,760 --> 00:31:02,490
你可以做什么？

711
00:31:02,490 --> 00:31:04,230
你可以在里面设置任何 property 的值

712
00:31:04,230 --> 00:31:05,300
你甚至可以

713
00:31:05,300 --> 00:31:07,230
给 property 设置默认值

714
00:31:07,230 --> 00:31:09,770
即使你把它设置为等于12

715
00:31:09,770 --> 00:31:12,540
在你的 init 里 你可以把一些东西重置为别的什么

716
00:31:12,540 --> 00:31:15,100
如果你想的话

717
00:31:15,110 --> 00:31:16,010
ok?

718
00:31:16,010 --> 00:31:16,910
你可以这样做

719
00:31:16,910 --> 00:31:20,910
你也可以给常量 property 赋值

720
00:31:20,910 --> 00:31:24,810
如果你有一个结构体或者类

721
00:31:24,810 --> 00:31:31,180
它有一个 property: let x: String

722
00:31:31,190 --> 00:31:34,190
即使是 let 它也可以在 init 里

723
00:31:34,190 --> 00:31:35,320
被你赋值

724
00:31:35,320 --> 00:31:37,090
也可以是等于其他什么

725
00:31:37,090 --> 00:31:38,490
你可以在 init 里这么做

726
00:31:38,490 --> 00:31:40,230
ok?

727
00:31:40,230 --> 00:31:41,960
人们有时不理解

728
00:31:41,960 --> 00:31:44,560
他们肯定在想 哦 在我的 class 里可以有 let？

729
00:31:44,560 --> 00:31:46,600
可有一样 你知道的

730
00:31:46,600 --> 00:31:49,030
类里的常量在初始化和创建实例

731
00:31:49,040 --> 00:31:51,300
的生命周期里是保持不变的

732
00:31:51,300 --> 00:31:54,240
你绝对可以在 init 里初始化它们

733
00:31:54,240 --> 00:31:55,440
好的

734
00:31:55,440 --> 00:31:56,640
这实际上是很好的做法

735
00:31:56,640 --> 00:32:00,210
如果你需要定义常量属性

736
00:32:00,210 --> 00:32:04,380
在你的类或者结构体里你可以调用其他的 init 方法

737
00:32:04,380 --> 00:32:06,680
使用 self.init

738
00:32:06,680 --> 00:32:08,420
明白？

739
00:32:08,420 --> 00:32:10,150
self.init 你可以调用有不同参数的

740
00:32:10,150 --> 00:32:11,520
其他 init 方法

741
00:32:11,520 --> 00:32:13,020
ok？

742
00:32:13,020 --> 00:32:14,520
所以听起来很不错

743
00:32:14,520 --> 00:32:18,290
当然 在类里你也可以调用 super.init

744
00:32:18,290 --> 00:32:20,130
调用你父类的初始化方法

745
00:32:20,130 --> 00:32:22,260
参数无论是什么 如果有的话

746
00:32:22,260 --> 00:32:26,230
然而很重要的是

747
00:32:26,230 --> 00:32:28,200
调用其他的 init 时有很多规则

748
00:32:28,200 --> 00:32:31,840
尤其是在类里

749
00:32:31,840 --> 00:32:34,070
在结构体里 这并不是一个大问题

750
00:32:34,070 --> 00:32:36,310
但在类里 有很多规则 我们将拿两个幻灯片

751
00:32:36,310 --> 00:32:39,180
对这些规则做简单介绍

752
00:32:39,180 --> 00:32:39,840
好的

753
00:32:39,850 --> 00:32:41,110
所以作为这些规则的一部分

754
00:32:41,110 --> 00:32:43,110
你需要在 init 里做些什么？

755
00:32:43,120 --> 00:32:45,180
什么是你必须要做的？

756
00:32:45,180 --> 00:32:48,150
好 正如你所知道的 在你的类里

757
00:32:48,150 --> 00:32:50,320
所有的 property 都必须初始化

758
00:32:50,320 --> 00:32:52,650
他们都必须有值

759
00:32:52,660 --> 00:32:56,160
记住 对于 Optionals nil 也是值

760
00:32:56,160 --> 00:32:58,490
所以 如果你有一个 Optional 是 nil 这也算它有值

761
00:32:58,500 --> 00:32:59,760
一切都好了

762
00:32:59,760 --> 00:33:03,200
在类里 Swift 提供两种类型

763
00:33:03,200 --> 00:33:05,500
的构造器来初始化

764
00:33:05,500 --> 00:33:06,800
不是在结构体里 在类里

765
00:33:06,800 --> 00:33:09,000
一种是 Convenience Init

766
00:33:09,000 --> 00:33:11,240
其它的都是另一种类型

767
00:33:11,240 --> 00:33:13,370
叫 Designated Initializers

768
00:33:13,370 --> 00:33:15,010
默认的 initializer

769
00:33:15,010 --> 00:33:17,640
是 designated initializer 但是另外还有些

770
00:33:17,640 --> 00:33:20,110
叫 convenience initializers

771
00:33:20,110 --> 00:33:21,380
我们得做出区分

772
00:33:21,380 --> 00:33:23,880
因为它们的规则有一点点的不同

773
00:33:23,880 --> 00:33:25,220
我们来看看吧

774
00:33:25,220 --> 00:33:28,050
Designated initializer 不能有

775
00:33:28,050 --> 00:33:29,850
convenience 在它的前面

776
00:33:29,860 --> 00:33:31,320
它只能

777
00:33:31,320 --> 00:33:37,560
调用其父类的 designated initializer

778
00:33:37,560 --> 00:33:38,890
这是一个非常重要的规则

779
00:33:38,900 --> 00:33:42,300
如果有一个 designated initializer

780
00:33:42,300 --> 00:33:43,930
它前面没有 convenience 这个单词在

781
00:33:43,930 --> 00:33:45,830
在你的类里不能调用其他的 init 方法

782
00:33:45,840 --> 00:33:47,700
必须在 init 里调用父类的 init

783
00:33:47,700 --> 00:33:49,800
而且它必须是一个 designated initializer

784
00:33:49,810 --> 00:33:52,240
而不是 convenience initializer

785
00:33:52,240 --> 00:33:53,870
明白？

786
00:33:53,880 --> 00:33:56,280
理解第一条规则了吗？

787
00:33:56,280 --> 00:33:57,310
这就是你们的预设初始化（designated initial）

788
00:33:57,310 --> 00:33:59,180
这就是全部了

789
00:33:59,180 --> 00:34:01,050
顺便说一下 在文档中有详细的描述

790
00:34:01,050 --> 00:34:02,480
有图表之类的说明

791
00:34:02,480 --> 00:34:04,020
我这里只是大概提一下

792
00:34:04,020 --> 00:34:05,480
希望

793
00:34:05,480 --> 00:34:06,950
你们已经读了文档 这是复习

794
00:34:06,950 --> 00:34:09,450
如果没有 希望你们能理解一点

795
00:34:09,460 --> 00:34:11,090
我所说的

796
00:34:11,090 --> 00:34:12,720
今晚 当你们阅读文档时 就会明白了

797
00:34:12,730 --> 00:34:14,260
这就是

798
00:34:14,260 --> 00:34:15,890
designating initializer 的规则

799
00:34:15,890 --> 00:34:19,230
你必须在调用父类的初始化函数前

800
00:34:19,230 --> 00:34:24,830
先初始化你自己的所有的 property

801
00:34:24,840 --> 00:34:25,570
只有 designated initializers

802
00:34:25,570 --> 00:34:26,930
需要这样

803
00:34:26,940 --> 00:34:29,340
因为他们调用 supervisors initializers

804
00:34:29,340 --> 00:34:32,470
所以你必须在调用父类的 property 前

805
00:34:32,480 --> 00:34:34,040
先处理你自己（类）的 property

806
00:34:34,040 --> 00:34:36,340
这经常让你有些麻烦

807
00:34:36,350 --> 00:34:39,350
你要先调用

808
00:34:39,350 --> 00:34:43,420
父类的初始化函数 然后才能给继承自父类的

809
00:34:43,420 --> 00:34:47,550
property 赋值

810
00:34:47,550 --> 00:34:49,120
也就是说

811
00:34:49,120 --> 00:34:50,690
你必须先让你的父类初始化它的 property

812
00:34:50,690 --> 00:34:53,260
然后你才能给它们赋值

813
00:34:53,260 --> 00:34:54,960
你们现在明白这三条规则了吗？

814
00:34:54,960 --> 00:34:56,830
好的

815
00:34:56,830 --> 00:34:58,700
这和你们的父类有关 因为它必须处理

816
00:34:58,700 --> 00:35:01,300
designated intitializers 并调用它的父类（的初始化函数）

817
00:35:01,300 --> 00:35:04,530
convenience initializer 有不同的规则

818
00:35:04,540 --> 00:35:06,070
首先

819
00:35:06,070 --> 00:35:09,240
convenience initializer 必须

820
00:35:09,240 --> 00:35:14,580
而且只能调用本类的 designated initializer

821
00:35:14,580 --> 00:35:16,240
Convenience initializer

822
00:35:16,250 --> 00:35:19,110
这类初始化函数不能调用任何父类的初始化函数

823
00:35:19,120 --> 00:35:21,650
它必须调用

824
00:35:21,650 --> 00:35:23,380
designated initializer

825
00:35:23,390 --> 00:35:26,350
它能通过调用其他的 convenience initializer

826
00:35:26,360 --> 00:35:29,860
间接调用 designated initializer

827
00:35:29,860 --> 00:35:31,310
好的

828
00:35:31,310 --> 00:35:32,760
因此 convenience initializer 能调用本类其他

829
00:35:32,760 --> 00:35:35,860
调用 designated initializer 的 convenience initializer

830
00:35:35,860 --> 00:35:39,260
但最后 有个 designated initializer 必须被调用

831
00:35:39,270 --> 00:35:40,870
明白？

832
00:35:40,870 --> 00:35:43,900
一个 convenience initializer 必须先直接或

833
00:35:43,900 --> 00:35:46,770
间接调用 designated initializer

834
00:35:46,770 --> 00:35:50,940
然后才能访问其他的值

835
00:35:50,940 --> 00:35:52,260
ok?

836
00:35:52,260 --> 00:35:53,580
你必须让主要的

837
00:35:53,580 --> 00:35:56,480
你的对象首先被初始化 然后你才能

838
00:35:56,480 --> 00:36:00,250
让 convenience initializer 开始访问 property

839
00:36:00,250 --> 00:36:03,350
其他初始化函数的调用 不管是你的 convenience initializer

840
00:36:03,350 --> 00:36:06,120
调用你的 designator initializer 还是你的 designator initializer

841
00:36:06,120 --> 00:36:08,960
调用你父类的 designator initializer

842
00:36:08,960 --> 00:36:12,190
所有这些都必须在你开始访问 property 和方法之前完成

843
00:36:12,190 --> 00:36:15,400
也就是说 这个类必须被初始化 然后

844
00:36:15,400 --> 00:36:17,860
你才能开始调用方法和 property

845
00:36:17,870 --> 00:36:19,830
明白？

846
00:36:19,830 --> 00:36:21,800
这就是为什么我们必须使用 lazy 的方式

847
00:36:21,800 --> 00:36:24,270
如果想让 property 在被调用方法的时候被赋值

848
00:36:24,270 --> 00:36:25,940
因为我们不能使用 non-lazily 的方式

849
00:36:25,940 --> 00:36:28,240
因为那时我们还没被初始化

850
00:36:28,240 --> 00:36:30,110
我们还在初始化过程中

851
00:36:30,110 --> 00:36:31,980
这如同初始化的两个阶段

852
00:36:31,980 --> 00:36:36,650
完全初始化之后 你就能那样做了

853
00:36:36,650 --> 00:36:38,120
这就是（初始化的）规则了

854
00:36:38,120 --> 00:36:40,130
有问题吗？

855
00:36:40,140 --> 00:36:42,150
（学生提问）

856
00:36:42,150 --> 00:36:43,690
（学生提问）

857
00:36:43,690 --> 00:36:44,940
问题是

858
00:36:44,940 --> 00:36:46,190
有没有一种方式 可以调用方法或者类似的途径

859
00:36:46,190 --> 00:36:47,020
给常量赋值

860
00:36:47,020 --> 00:36:47,820
答案是不能

861
00:36:47,830 --> 00:36:49,020
好的

862
00:36:49,030 --> 00:36:52,090
你只能给常量赋予等于的某个值

863
00:36:52,100 --> 00:36:54,030
或者在你的初始化函数中

864
00:36:54,030 --> 00:36:57,960
不幸的是 之后我们不能做这些了

865
00:36:57,970 --> 00:36:59,100
好

866
00:36:59,100 --> 00:37:01,230
让我们聊聊继承式初始化

867
00:37:01,240 --> 00:37:02,500
ok？

868
00:37:02,500 --> 00:37:03,770
这也很复杂

869
00:37:03,770 --> 00:37:05,870
这就是继承式初始化的规则了

870
00:37:05,870 --> 00:37:10,410
如果你没有在你的类中实现任何 designated initializers

871
00:37:10,410 --> 00:37:14,250
那么 你将继承你父类中的

872
00:37:14,250 --> 00:37:18,320
所有 designated initializers

873
00:37:18,320 --> 00:37:20,880
否则 你将不继承任何你的父类中的

874
00:37:20,890 --> 00:37:23,350
designated initializers

875
00:37:23,360 --> 00:37:25,050
明白？

876
00:37:25,060 --> 00:37:28,390
要么就是继承全部的 designated initializers 要么就是一个都不继承

877
00:37:28,390 --> 00:37:33,930
如果你覆盖了你父类中的所有 designated initializers

878
00:37:33,930 --> 00:37:34,660
ok？

879
00:37:34,670 --> 00:37:36,530
比如 你的父类中有

880
00:37:36,530 --> 00:37:38,400
三种不同参数的 designated initializers

881
00:37:38,400 --> 00:37:41,600
如果你重写了所有这些方法 那么你就继承了父类中所有的

882
00:37:41,600 --> 00:37:44,440
convenient initializers

883
00:37:44,440 --> 00:37:46,770
同样 如果你没有实现它们中的任一个方法

884
00:37:46,780 --> 00:37:48,940
在这种情况下 你将继承

885
00:37:48,940 --> 00:37:51,810
所有 designated 和 convenience initializer

886
00:37:51,810 --> 00:37:53,880
明白？

887
00:37:53,880 --> 00:37:55,410
这就是继承的规则

888
00:37:55,420 --> 00:37:56,520
这让人有点搞不懂

889
00:37:56,520 --> 00:37:57,580
他们说 哦耶

890
00:37:57,580 --> 00:37:59,250
我实现了一个初始化

891
00:37:59,250 --> 00:38:01,190
但是其他的初始化为什么没用？

892
00:38:01,190 --> 00:38:02,620
好吧 因为一旦你初始化

893
00:38:02,620 --> 00:38:04,320
执行一个 designated initializer

894
00:38:04,320 --> 00:38:05,820
你就不必继承其他的

895
00:38:05,820 --> 00:38:08,120
ok？

896
00:38:08,130 --> 00:38:10,430
所以对于 designated initializers 不是全有就是全无

897
00:38:10,430 --> 00:38:13,060
而对于 convenience 也一样如此

898
00:38:13,060 --> 00:38:15,930
因为为了执行 convenience 你必须全实现或者

899
00:38:15,930 --> 00:38:18,930
全不实现 designated initializers

900
00:38:18,940 --> 00:38:23,870
任何 init 如果是按照我刚才说的规则继承而来的话

901
00:38:23,870 --> 00:38:27,880
包括之前幻灯片提到的所有规则

902
00:38:27,880 --> 00:38:30,840
在这里 我就不回顾之前幻灯片的内容了

903
00:38:30,850 --> 00:38:33,850
不过 其实就这样继承 initializer 就可以满足

904
00:38:33,850 --> 00:38:36,980
很多之前的幻灯片里讲的规则了

905
00:38:36,990 --> 00:38:38,280
明白？

906
00:38:38,290 --> 00:38:39,750
但是你

907
00:38:39,750 --> 00:38:41,220
只能通过这种受限制的方法去继承它们

908
00:38:41,220 --> 00:38:42,420
不过只要你这么做了

909
00:38:42,420 --> 00:38:46,060
之前的所有规则就都可以满足了

910
00:38:46,060 --> 00:38:48,990
可能有人问什么是 required init

911
00:38:49,000 --> 00:38:51,030
就是在前面写上 required

912
00:38:51,030 --> 00:38:52,260
如果你写上 required

913
00:38:52,270 --> 00:38:54,530
那么它的子类就必须实现这个方法

914
00:38:54,530 --> 00:38:56,720
这就是 required

915
00:38:56,720 --> 00:38:58,900
现在通过遵守上面的规则 你可以继承它了

916
00:38:58,900 --> 00:39:00,240
换句话说 如果没有实现

917
00:39:00,240 --> 00:39:02,040
任何 designated initializers

918
00:39:02,040 --> 00:39:04,570
它们将会继承 required 的初始化 这非常棒

919
00:39:04,580 --> 00:39:07,940
但是如果你实现了任何一个 designated initializers

920
00:39:07,950 --> 00:39:10,210
你就必须实现 required 的那些

921
00:39:10,210 --> 00:39:11,880
ok？

922
00:39:11,880 --> 00:39:15,550
最后 再说说 failable initializers

923
00:39:15,550 --> 00:39:18,350
ok？

924
00:39:18,350 --> 00:39:21,150
有一些 initializer 允许失败并且返回 nil

925
00:39:21,160 --> 00:39:22,870
ok？

926
00:39:22,870 --> 00:39:24,590
你在初始化完成后 可以加个注释

927
00:39:24,590 --> 00:39:26,930
就像我这里一样

928
00:39:26,930 --> 00:39:28,310
明白？

929
00:39:28,310 --> 00:39:29,700
现在 这是很少见的

930
00:39:29,700 --> 00:39:31,700
明白吗？你们不经常见这些

931
00:39:31,700 --> 00:39:33,700
我上次查文档的时候

932
00:39:33,700 --> 00:39:35,730
它也没描述的特别仔细

933
00:39:35,740 --> 00:39:37,570
它没有把问号写在那儿

934
00:39:37,570 --> 00:39:38,540
我觉得是

935
00:39:38,540 --> 00:39:41,010
生成文档的时候出现的问题

936
00:39:41,010 --> 00:39:43,710
它会在初始化的时候提示

937
00:39:43,710 --> 00:39:46,910
这个可能会返回 nil  如果失败的话

938
00:39:46,910 --> 00:39:48,080
但是它没有写

939
00:39:48,080 --> 00:39:49,250
应该是把问号写在那儿

940
00:39:49,250 --> 00:39:51,410
但是没关系 因为当你用它的时候

941
00:39:51,420 --> 00:39:53,080
你就会调用它

942
00:39:53,080 --> 00:39:54,980
回调了之后你尝试

943
00:39:54,990 --> 00:39:55,720
给它发送一个消息

944
00:39:55,720 --> 00:39:57,520
它会提示

945
00:39:57,520 --> 00:39:59,320
这个方法不是 Optional 的 没有对应的方法

946
00:39:59,320 --> 00:40:00,150
你会惊讶 我擦！

947
00:40:00,160 --> 00:40:01,290
它不是 Optional？

948
00:40:01,290 --> 00:40:02,420
然后你就会瞬间反应过来

949
00:40:02,420 --> 00:40:03,560
哦 这是个 failable initializer

950
00:40:03,560 --> 00:40:05,690
来 我们来看这个例子

951
00:40:05,700 --> 00:40:07,060
关于 UIImage

952
00:40:07,060 --> 00:40:09,750
ok？

953
00:40:09,750 --> 00:40:12,430
它是 UIKit 中的一个类

954
00:40:12,430 --> 00:40:14,770
然后 它返回一个图片

955
00:40:14,770 --> 00:40:17,100
你可以通过它的名称来获取图片

956
00:40:17,100 --> 00:40:19,970
当然 如果你的项目中如果不存在图片的话

957
00:40:19,970 --> 00:40:23,340
它就会返回 nil

958
00:40:23,340 --> 00:40:24,810
那么在这里

959
00:40:24,810 --> 00:40:27,310
名为 "foo" 的图片赋值给 image

960
00:40:27,310 --> 00:40:29,280
image 是一个 Optional UIImage

961
00:40:29,280 --> 00:40:32,320
即使我调用了 initializer

962
00:40:32,320 --> 00:40:34,220
UIImages 的 initializer

963
00:40:34,220 --> 00:40:35,920
image 可以是 Optional

964
00:40:35,920 --> 00:40:38,090
这种情况下我们会用 if let

965
00:40:38,090 --> 00:40:41,060
如果 image = UIImage(name: "foo") 成立

966
00:40:41,060 --> 00:40:42,860
那么我们就处理相关的事件

967
00:40:42,860 --> 00:40:44,460
不成立 不能创建图片

968
00:40:44,460 --> 00:40:46,230
这种情况下我们做点什么

969
00:40:46,230 --> 00:40:47,500
是吗？

970
00:40:47,500 --> 00:40:48,730
所以 多注意这些细节

971
00:40:48,730 --> 00:40:51,670
这种情况非常少 最多不过十几种

972
00:40:51,670 --> 00:40:52,930
说你的问题

973
00:40:52,930 --> 00:40:55,200
-（学生提问）

974
00:40:55,200 --> 00:40:58,640
-问题是：这是 try-catch 的一个取代吗？

975
00:40:58,640 --> 00:41:00,610
我们不打算谈论 try-catch

976
00:41:00,610 --> 00:41:01,970
在这门课

977
00:41:01,980 --> 00:41:03,340
好吗？ try-catch 非常少见

978
00:41:03,340 --> 00:41:06,810
甚至在 Swift 中也很少用到它

979
00:41:06,810 --> 00:41:10,350
Optional 让

980
00:41:10,350 --> 00:41:11,650
try-catch 变得不是必须的

981
00:41:11,650 --> 00:41:13,420
对于那些不知道什么是 try-catch 的同学

982
00:41:13,420 --> 00:41:15,180
try-catch 是你的程序引发异常时

983
00:41:15,190 --> 00:41:17,920
它们会遍历调用堆栈并且

984
00:41:17,920 --> 00:41:20,160
查找处理此类异常的 catch 语句

985
00:41:20,160 --> 00:41:22,010
明白了吗？

986
00:41:22,010 --> 00:41:23,860
这种编程方法并不是

987
00:41:23,860 --> 00:41:27,500
iOS 开发中常用的一种方法

988
00:41:27,500 --> 00:41:28,630
明白了吗？在 Objective-C 中

989
00:41:28,630 --> 00:41:30,530
这种方法可能只会用了一点点

990
00:41:30,530 --> 00:41:32,170
对此我不是很确定但是

991
00:41:32,170 --> 00:41:34,670
在 Swift 中 我们肯定不会使用它

992
00:41:34,670 --> 00:41:36,440
在本课程的范围内 我甚至不会演示给你们怎么使用它

993
00:41:36,440 --> 00:41:40,670
不需要了解

994
00:41:40,680 --> 00:41:41,970
好的

995
00:41:41,980 --> 00:41:44,780
让我们来讲一下如何创建对象

996
00:41:44,780 --> 00:41:47,710
创建一个对象的语法是 你在想要创建的类型之后

997
00:41:47,720 --> 00:41:52,020
加上一对括号 括号内是初始化方法的参数

998
00:41:52,020 --> 00:41:53,450
好

999
00:41:53,450 --> 00:41:54,890
这里写的很清楚

1000
00:41:54,890 --> 00:41:58,560
你可能会发现你并不是一直通过这种方式来创建对象

1001
00:41:58,560 --> 00:42:01,190
有时候你会使用一个类方法或者

1002
00:42:01,190 --> 00:42:02,930
类型方法去创建一个对象

1003
00:42:02,930 --> 00:42:04,630
这里就是一个例子 .buttonWithType

1004
00:42:04,630 --> 00:42:07,800
你看到这个消息被发送给了 UIButton 一种类型

1005
00:42:07,800 --> 00:42:09,230
消息并没有发送给一个

1006
00:42:09,230 --> 00:42:11,230
UIButton 的对象 而是一个类型

1007
00:42:11,240 --> 00:42:12,630
我记得我们之前讲过

1008
00:42:12,640 --> 00:42:14,040
还有一种情况

1009
00:42:14,040 --> 00:42:16,970
这种情况比较少见 需要你用另外一种方式创建对象

1010
00:42:16,970 --> 00:42:20,540
甚至连 Apple 都已经将它们从 Model 中移除

1011
00:42:20,540 --> 00:42:24,040
而转向于使用初始化方法

1012
00:42:24,050 --> 00:42:28,210
但是仍有部分的情况会使用到这种创建对象的方法

1013
00:42:28,220 --> 00:42:31,320
还记得上一页中的 UIImage 吗？

1014
00:42:31,320 --> 00:42:34,020
那个不是像 UIImage.image 这样命名的

1015
00:42:34,020 --> 00:42:37,090
以前 Apple 就用那种创建对象的方法 但是现在用

1016
00:42:37,090 --> 00:42:39,990
UIImage().xxx 这个叫做 constructor

1017
00:42:39,990 --> 00:42:43,730
有些时候其他对象会为你

1018
00:42:43,730 --> 00:42:45,030
创建一些对象

1019
00:42:45,030 --> 00:42:49,130
例如在 String 中有一个非常酷的方法叫 join

1020
00:42:49,130 --> 00:42:51,850
ok？

1021
00:42:51,850 --> 00:42:54,570
Join 接受一个由字符串组成的数组并

1022
00:42:54,570 --> 00:42:57,540
用接收 join 消息的字符串把这个数组分离开

1023
00:42:57,540 --> 00:43:00,440
所以 ",".join(myArray) 会返回给你一个

1024
00:43:00,440 --> 00:43:03,310
由逗号分隔的字符串 就是说这个字符串

1025
00:43:03,310 --> 00:43:05,680
中间有一个逗号把前后分为两段

1026
00:43:05,680 --> 00:43:08,380
这明显是创建了一个新数组

1027
00:43:08,390 --> 00:43:10,480
这确实很明显

1028
00:43:10,490 --> 00:43:13,320
是的 一些方法会返回

1029
00:43:13,320 --> 00:43:14,590
创建出来的对象给你

1030
00:43:14,590 --> 00:43:16,470
好

1031
00:43:16,470 --> 00:43:18,360
让我们讲一下 AnyObject

1032
00:43:18,360 --> 00:43:20,830
这个在之前涉及过

1033
00:43:20,830 --> 00:43:24,200
AnyObject 是某种

1034
00:43:24,200 --> 00:43:26,100
为了方便理解

1035
00:43:26,100 --> 00:43:28,000
你可以认为它是一种类型

1036
00:43:28,000 --> 00:43:30,270
明白了吗？但是事实上 这并不是一种类型

1037
00:43:30,270 --> 00:43:33,470
但是你可以认为它是一种类型 就像 Double

1038
00:43:33,470 --> 00:43:35,270
或者 Array 等等

1039
00:43:35,270 --> 00:43:37,070
AnyObject 主要用于

1040
00:43:37,080 --> 00:43:40,740
兼容现有 Objective-C API 和 iOS 代码

1041
00:43:40,750 --> 00:43:42,580
你并不会经常使用

1042
00:43:42,580 --> 00:43:45,820
AnyObject 来构建你自己的数据结构

1043
00:43:45,820 --> 00:43:47,680
你可以这样做

1044
00:43:47,690 --> 00:43:49,550
但是 这有一点点 不像 Swift 风格的做法

1045
00:43:49,550 --> 00:43:54,160
Swift 是强类型语言 并有类型推断的特性

1046
00:43:54,160 --> 00:43:55,920
的那种语言

1047
00:43:55,930 --> 00:43:57,690
当然你可以这么做 但是我只会在兼容性的问题上

1048
00:43:57,690 --> 00:44:00,560
讲到 AnyObject 的问题

1049
00:44:00,560 --> 00:44:01,160
明白了吗？

1050
00:44:01,160 --> 00:44:04,830
什么是 AnyObject？

1051
00:44:04,830 --> 00:44:06,670
还有 我们会在哪里用到它？

1052
00:44:06,670 --> 00:44:10,740
AnyObject 的意思是 指向一个对象的指针

1053
00:44:10,740 --> 00:44:12,470
也就是说 一个类的实例

1054
00:44:12,470 --> 00:44:13,310
明白吗？

1055
00:44:13,310 --> 00:44:14,970
只是你不知道它的类是什么

1056
00:44:14,980 --> 00:44:18,840
所以它是指向一个未知类的指针

1057
00:44:18,850 --> 00:44:20,010
有问题吗？这可能听上去

1058
00:44:20,010 --> 00:44:21,610
有些奇怪 确实它有些奇怪

1059
00:44:21,610 --> 00:44:24,780
你们会考虑 我们到底会在什么情况下使用到它

1060
00:44:24,780 --> 00:44:26,920
但这里我想告诉你们的是 它是什么

1061
00:44:26,920 --> 00:44:29,520
在 iOS 开发中 哪里能看到它呢？

1062
00:44:29,520 --> 00:44:32,360
有些时候你会看到某些属性的类型是 AnyObject 的

1063
00:44:32,360 --> 00:44:36,430
例如我们下周会讲到的

1064
00:44:36,430 --> 00:44:38,930
在 Storyboard Segues 的一个属性

1065
00:44:38,930 --> 00:44:41,400
这个属性叫 destinationViewController

1066
00:44:41,400 --> 00:44:44,400
它不是以 UIViewController 作为它的类型

1067
00:44:44,400 --> 00:44:45,600
而是 AnyObject

1068
00:44:45,600 --> 00:44:47,570
这是某些历史遗留问题造成的

1069
00:44:47,570 --> 00:44:50,840
类似的 在 UIViewController 中

1070
00:44:50,840 --> 00:44:53,970
有一个叫 toolbarItems 的属性

1071
00:44:53,980 --> 00:44:57,140
它会返回一个由 AnyObject 组成的数组

1072
00:44:57,150 --> 00:44:59,080
明白？

1073
00:44:59,080 --> 00:45:01,010
基本上 这些属性返回给你一些

1074
00:45:01,020 --> 00:45:02,550
你都不知道是什么类型的东西

1075
00:45:03,980 --> 00:45:05,420
ok？

1076
00:45:05,420 --> 00:45:07,620
还有 你会在函数的参数中见到 AnyObject

1077
00:45:07,620 --> 00:45:09,620
类似在这里一样

1078
00:45:09,620 --> 00:45:11,620
一个 UIViewController 的方法 prepareForSegue

1079
00:45:11,620 --> 00:45:13,460
它接受一个普通的参数 segue 但是它还接受一个

1080
00:45:13,460 --> 00:45:16,360
sender 参数 这个参数的类型是 AnyObject 的

1081
00:45:17,830 --> 00:45:19,360
在这个情况下 AnyObject 的说法更有道理

1082
00:45:19,360 --> 00:45:21,060
因为 Sender 确实可以是任意对象

1083
00:45:21,070 --> 00:45:23,700
因为无论什么导致 UI 中 Segue 发生的东西

1084
00:45:23,700 --> 00:45:27,000
都可以是任意对象 所以这么就说通了

1085
00:45:27,000 --> 00:45:30,270
但这里是 addConstraints

1086
00:45:30,270 --> 00:45:32,310
也是一种跟 UIViewController 类似的东西

1087
00:45:32,310 --> 00:45:34,740
如果你加了 constraints 你可以认为

1088
00:45:34,740 --> 00:45:36,710
那是一个 constraints 的 Array 不管 constraints 是什么类型

1089
00:45:36,710 --> 00:45:38,480
我还没有教你们这些

1090
00:45:38,480 --> 00:45:41,280
这些 constraints 都是用来控制 UI 的移位

1091
00:45:41,280 --> 00:45:44,450
但是 由于历史遗留问题

1092
00:45:44,450 --> 00:45:47,290
这是一个任意对象的 Array  甚至是计算器里的 appendDigit

1093
00:45:47,290 --> 00:45:51,290
记住 当我按住 control

1094
00:45:51,290 --> 00:45:54,430
拖动按钮去生成一个 appendDigit 的 我们其实是在说

1095
00:45:54,430 --> 00:45:57,430
把那个任意对象变成一个 UI Button

1096
00:45:57,430 --> 00:46:01,070
如果你还没改变这个 你最后可能会得到

1097
00:46:01,070 --> 00:46:03,300
一个 appendDigit(sender: AnyObject)

1098
00:46:03,300 --> 00:46:03,870
明白？

1099
00:46:05,440 --> 00:46:08,140
这甚至可以作为函数返回对象

1100
00:46:08,140 --> 00:46:10,570
就像是前几张幻灯片中我说过的那个 buttonWithType 函数

1101
00:46:10,570 --> 00:46:12,110
它其实返回 AnyObject

1102
00:46:12,110 --> 00:46:14,940
这不会返回一个 UI Button 你可能想这会返回这样一个类型

1103
00:46:14,950 --> 00:46:16,910
但其实不会 他会返回 AnyObject

1104
00:46:16,910 --> 00:46:18,680
就是这样

1105
00:46:18,680 --> 00:46:20,510
你可能会想这是怎么了

1106
00:46:20,520 --> 00:46:22,680
为什么你要传递这些

1107
00:46:22,690 --> 00:46:24,980
甚至你不知道这些是什么的指针呢？

1108
00:46:24,990 --> 00:46:28,420
我们稍后会讨论一下为什么这么做

1109
00:46:28,420 --> 00:46:32,160
但先来说说我们怎么用这个 因为这是一个指向未知对象的指针

1110
00:46:32,160 --> 00:46:35,760
所有我不能发送任何信息给它

1111
00:46:35,760 --> 00:46:40,130
因为我甚至不知道这是什么

1112
00:46:40,130 --> 00:46:45,470
为了使用它 我们把它转换成一种我们知道的类型

1113
00:46:45,470 --> 00:46:49,040
我们唯一的使用 AnyObject 的方式

1114
00:46:49,040 --> 00:46:52,540
就是把它转换成我们知道的类

1115
00:46:52,540 --> 00:46:55,280
我们通过

1116
00:46:56,310 --> 00:46:59,780
建立一个新的变量来做这件事。比如 我们有一些 AnyObject

1117
00:46:59,780 --> 00:47:01,980
是一个方法的参数

1118
00:47:01,990 --> 00:47:03,550
或者是一个本地变量

1119
00:47:03,550 --> 00:47:05,950
诸如此类 我们想把它转换掉

1120
00:47:05,960 --> 00:47:08,660
所以我们可以建立一个新的变量

1121
00:47:08,660 --> 00:47:11,160
新变量的类型就是我们想要转换到的类型

1122
00:47:11,160 --> 00:47:13,830
然后我们要把这个变量声明成

1123
00:47:13,830 --> 00:47:17,260
“变量 = AnyObject 转换后的东西”

1124
00:47:17,270 --> 00:47:18,700
接着

1125
00:47:18,700 --> 00:47:20,130
我们需要转换成一个合适的类型

1126
00:47:20,140 --> 00:47:21,530
实际上 它也

1127
00:47:21,540 --> 00:47:22,930
必须是那种类型

1128
00:47:22,940 --> 00:47:26,340
所以如果我们从 buttonWithType 中取回了 UIButton

1129
00:47:26,340 --> 00:47:27,710
其实返回了 AnyObject

1130
00:47:27,710 --> 00:47:30,880
你可以把它转换成 UIButton 因为他真的是个 UIButton

1131
00:47:30,880 --> 00:47:32,660
明白？

1132
00:47:32,660 --> 00:47:34,450
但是不能转换成 UILabel 因为他不是个 UILabel

1133
00:47:34,450 --> 00:47:36,950
这会让你的程序崩溃

1134
00:47:36,950 --> 00:47:39,050
那我们怎么去做这个转换呢？

1135
00:47:40,520 --> 00:47:42,750
看到没 这会让我们的程序崩溃

1136
00:47:42,760 --> 00:47:44,390
如何安全地去做这个转型

1137
00:47:44,390 --> 00:47:46,390
才不会让我们的程序一直崩溃呢？

1138
00:47:46,390 --> 00:47:50,530
这里有两种方式 我们叫它转换

1139
00:47:50,530 --> 00:47:53,060
你知道类型转换是什么 我们

1140
00:47:53,060 --> 00:47:55,060
本质上是把一个类型从任意类型转换成其他的

1141
00:47:56,000 --> 00:48:00,430
我们还可以用 as 关键词强行转换

1142
00:48:00,440 --> 00:48:01,840
用 as

1143
00:48:01,840 --> 00:48:04,340
通常 Swift 是非常简洁的

1144
00:48:04,340 --> 00:48:06,810
下面我要用 destinationViewController

1145
00:48:06,810 --> 00:48:08,810
来做个例子

1146
00:48:08,810 --> 00:48:12,280
我得到了这个 destinationViewController 作为属性

1147
00:48:12,280 --> 00:48:14,050
这是个 AnyObject

1148
00:48:14,050 --> 00:48:16,620
我知道这是个 ViewController

1149
00:48:16,620 --> 00:48:20,220
我想这应该是个 CalculatorViewController

1150
00:48:20,220 --> 00:48:21,490
我要在我的

1151
00:48:21,490 --> 00:48:23,550
CalculatorViewController 里面用

1152
00:48:23,560 --> 00:48:25,760
先想象一下我们调用 CalculatorViewController

1153
00:48:25,760 --> 00:48:28,860
是 CalculatorViewController 而不是 ViewController

1154
00:48:28,860 --> 00:48:30,430
我因为这个才用在我的例子里

1155
00:48:30,430 --> 00:48:32,000
这样能让你们更好理解

1156
00:48:32,000 --> 00:48:35,260
所以我想说说这个 destinationViewController

1157
00:48:35,270 --> 00:48:37,030
这是个 AnyObject

1158
00:48:37,030 --> 00:48:39,470
同时我又知道这是个 CalculatorViewController

1159
00:48:39,470 --> 00:48:41,470
如果这个不是个 CalculatorViewController

1160
00:48:41,470 --> 00:48:43,200
这个程序就应该会崩溃

1161
00:48:43,210 --> 00:48:45,170
因为在使用它的情景下

1162
00:48:45,170 --> 00:48:46,670
我需要它是 CalculatorViewController

1163
00:48:46,680 --> 00:48:48,390
明白？

1164
00:48:48,390 --> 00:48:50,110
所以可以写 let calcVC ＝

1165
00:48:50,110 --> 00:48:52,480
destinationViewController as CalculatorViewController

1166
00:48:52,480 --> 00:48:56,820
现在 calcVC 这个常量的类型

1167
00:48:56,820 --> 00:48:59,990
不是 AnyObject 而是 CalculatorViewController

1168
00:48:59,990 --> 00:49:02,150
所以现在我可以这种方法处理好了 AnyObject

1169
00:49:02,160 --> 00:49:03,620
之后就可以针对它做事情了

1170
00:49:03,620 --> 00:49:04,760
也可以发送消息

1171
00:49:04,760 --> 00:49:07,690
CalculatorViewControl 消息给 calcVC.

1172
00:49:08,990 --> 00:49:10,890
现在如果你想防止崩溃

1173
00:49:10,900 --> 00:49:13,800
但你不确定 destinationViewController 是不是

1174
00:49:13,800 --> 00:49:16,770
一个 CalculatorViewController 但你希望是

1175
00:49:16,770 --> 00:49:18,270
ok？

1176
00:49:18,270 --> 00:49:19,770
你可以用 as 加问号

1177
00:49:19,770 --> 00:49:22,900
as? 会返回一个可选的

1178
00:49:22,910 --> 00:49:26,870
跟 as 一样 as 返回 AnyObject 转换成

1179
00:49:26,880 --> 00:49:28,410
其他类之后的对象

1180
00:49:28,410 --> 00:49:30,980
问号做了同样的事 但是返回的是 Optional 版本

1181
00:49:30,980 --> 00:49:33,580
如果类型为 AnyObject 的 destinationViewController

1182
00:49:33,580 --> 00:49:35,380
不能转换成 CalculatorViewController

1183
00:49:35,380 --> 00:49:37,380
那就返回 nil

1184
00:49:37,390 --> 00:49:39,750
因为它不是 CalculatorViewController 而是其他的

1185
00:49:39,750 --> 00:49:41,990
ViewController 或者其他的（类）

1186
00:49:41,990 --> 00:49:42,720
明白？

1187
00:49:42,720 --> 00:49:44,740
所以 你可以说

1188
00:49:44,740 --> 00:49:46,760
if let calcVC = destinationViewController as

1189
00:49:46,760 --> 00:49:48,130
CalculatorViewController  然后

1190
00:49:48,130 --> 00:49:51,060
在那里面 你就给 calcVC 赋值了

1191
00:49:51,060 --> 00:49:53,500
你知道它是一个 CalculatorViewController

1192
00:49:53,500 --> 00:49:57,200
AnyObject 也就成了过去式了

1193
00:49:58,970 --> 00:50:00,170
理解吗？好了 我们学了 as 和

1194
00:50:00,170 --> 00:50:01,670
as?

1195
00:50:01,670 --> 00:50:05,510
如果你愿意 你也可以事先检查下 这是不是一个

1196
00:50:05,510 --> 00:50:08,740
CalculatorViewController

1197
00:50:08,750 --> 00:50:10,750
你可以写

1198
00:50:10,750 --> 00:50:13,250
if destinationViewController is CalculatorViewController

1199
00:50:13,250 --> 00:50:16,420
那么我就继续 然后我就可以进行 as（转换）

1200
00:50:16,420 --> 00:50:20,350
但通常地 我们使用 as?

1201
00:50:20,360 --> 00:50:23,190
做检查并且转换 一次搞定

1202
00:50:23,190 --> 00:50:25,010
ok？

1203
00:50:25,010 --> 00:50:26,830
这就是我们怎么使用 AnyObject

1204
00:50:26,830 --> 00:50:30,430
我们必须将它转化成其他东西

1205
00:50:30,430 --> 00:50:32,930
有问题吗？

1206
00:50:32,930 --> 00:50:35,430
（学生提问）

1207
00:50:35,440 --> 00:50:37,470
（学生提问）

1208
00:50:37,470 --> 00:50:39,040
所以 问题是

1209
00:50:39,040 --> 00:50:41,970
有没有这样一种方式 可以先检察这个类是什么类型

1210
00:50:41,970 --> 00:50:44,070
然后通过某种方式得到结果

1211
00:50:44,080 --> 00:50:47,440
答案是 就你所提的这个问题 不能

1212
00:50:47,450 --> 00:50:48,880
你不能那样做

1213
00:50:48,880 --> 00:50:50,310
你想要知道

1214
00:50:50,310 --> 00:50:52,910
它是否是一个确定的东西

1215
00:50:52,920 --> 00:50:54,580
你不能问 你是什么？

1216
00:50:54,580 --> 00:50:55,980
然后试图知道它是什么

1217
00:50:55,990 --> 00:50:57,580
因此 我们不能使用那样的模式

1218
00:50:59,820 --> 00:51:00,790
明白？

1219
00:51:00,790 --> 00:51:03,720
让我们说说包含 AnyObject 的 Array

1220
00:51:03,730 --> 00:51:05,990
有时你会得到一个 AnyObject 的 Array

1221
00:51:05,990 --> 00:51:08,760
就像我刚刚提到的 constraints

1222
00:51:08,760 --> 00:51:10,960
它可能是一个 AnyObject 类型 constraints 的 Array (译注：[AnyObject])

1223
00:51:10,960 --> 00:51:13,530
但我知道它们在这个

1224
00:51:13,530 --> 00:51:16,530
布局约束中 但它们是一个 Array

1225
00:51:16,540 --> 00:51:18,490
所以 你可以在转换它们

1226
00:51:18,490 --> 00:51:20,440
时做些有趣的事情

1227
00:51:20,440 --> 00:51:23,040
让我们以 toolbarItems 为例

1228
00:51:23,040 --> 00:51:26,040
toolbarItems 是 UIViewController 的

1229
00:51:26,050 --> 00:51:29,180
一个属性 它返回一个 UIBarButtonItem 的

1230
00:51:29,180 --> 00:51:31,510
Array

1231
00:51:31,520 --> 00:51:35,120
但 由于历史原因 它返回

1232
00:51:35,120 --> 00:51:36,550
[AnyObject]

1233
00:51:36,550 --> 00:51:37,950
所以 我可以说

1234
00:51:37,950 --> 00:51:41,990
在 toolbarItems 中 item 会是 AnyObject

1235
00:51:41,990 --> 00:51:44,690
所以 我遍历这些 AnyObject

1236
00:51:44,690 --> 00:51:47,490
这些变量也确实是 AnyObject

1237
00:51:47,500 --> 00:51:48,960
但在里面 我判断

1238
00:51:48,960 --> 00:51:51,730
如果我能 let toolbarItem =

1239
00:51:51,730 --> 00:51:55,170
UIBarButtonItem 我就可以继续了

1240
00:51:55,170 --> 00:51:57,900
我是这样遍历这个

1241
00:51:57,910 --> 00:51:58,840
AnyObject 的 Array

1242
00:51:58,840 --> 00:52:00,610
然后这些 object

1243
00:52:00,610 --> 00:52:02,370
在里面我使用 as?

1244
00:52:02,380 --> 00:52:04,110
但我也可以使用其他方式

1245
00:52:04,110 --> 00:52:05,810
我可以使用 for

1246
00:52:05,810 --> 00:52:09,880
toolbarItem in toolbarItems as [UIBarButtonItem]

1247
00:52:09,880 --> 00:52:12,450
换句话说 我可以转换整个 Array

1248
00:52:12,450 --> 00:52:14,280
如果我确认这整个的 AnyObject 的 Array 是个

1249
00:52:14,290 --> 00:52:17,820
UIBarButtonItem 的 Array  我就能转化它

1250
00:52:17,820 --> 00:52:20,560
现在这个 你不能使用问号 因为

1251
00:52:20,560 --> 00:52:24,190
for toolbarItem in nil 是没有意义的

1252
00:52:24,190 --> 00:52:25,730
没有意义

1253
00:52:25,730 --> 00:52:28,010
你不能在这里

1254
00:52:28,010 --> 00:52:30,300
你最好确认那个 Array 是你想要的

1255
00:52:30,300 --> 00:52:32,830
但这里面 toolbarItem 是一个

1256
00:52:32,840 --> 00:52:36,000
UIBarButtonItem 因为我已经转换了整个 Array  从 [AnyObject]

1257
00:52:36,010 --> 00:52:38,810
转换到 [UIBarButtonItem]

1258
00:52:38,810 --> 00:52:42,380
你们明白这两个的不同吗？

1259
00:52:42,380 --> 00:52:46,350
另一个出现

1260
00:52:46,350 --> 00:52:48,080
AnyObject 的例子

1261
00:52:48,080 --> 00:52:51,050
当我们 control 拖建一个

1262
00:52:51,050 --> 00:52:54,120
appendDigit 如果我们保留 AnyObject 会怎样？

1263
00:52:55,250 --> 00:52:56,770
所以我们有一个

1264
00:52:56,770 --> 00:52:58,290
appendDigit(sender: AnyObject)

1265
00:52:58,290 --> 00:52:59,790
我们怎么处理这个呢？

1266
00:52:59,790 --> 00:53:01,990
好吧 我们刚才说的

1267
00:53:01,990 --> 00:53:05,160
如果我们能够 let sendingButton = sender as UIButton

1268
00:53:05,160 --> 00:53:08,500
那么 做我们该做的 let digit ＝

1269
00:53:08,500 --> 00:53:12,070
sendingButton.currenTitle!

1270
00:53:12,070 --> 00:53:14,500
等等

1271
00:53:14,500 --> 00:53:15,770
有道理吧？

1272
00:53:15,770 --> 00:53:17,040
但是我们不想使用这个额外的 if let

1273
00:53:17,040 --> 00:53:18,840
我还没有跟你们讲 as

1274
00:53:18,840 --> 00:53:22,010
这是为什么我说要确保这个东西是 UIButton

1275
00:53:22,010 --> 00:53:22,580
明白？

1276
00:53:24,450 --> 00:53:27,480
现在你们可能会问 为什么会有 AnyObject？

1277
00:53:27,480 --> 00:53:30,450
当我们 control 拖拽时  为什么不只提供给我们 UIButton？

1278
00:53:30,450 --> 00:53:32,450
为什么它甚至提供了 AnyObject？

1279
00:53:32,450 --> 00:53:35,520
因为你们可能有一个 action 这个 action 是

1280
00:53:35,520 --> 00:53:38,690
两个不同的 UI 元素发起的

1281
00:53:38,690 --> 00:53:41,460
它可能是由 Button 和 Slider 发起的

1282
00:53:41,460 --> 00:53:43,090
我不知道它会是什么

1283
00:53:43,100 --> 00:53:44,900
我甚至举不出例子

1284
00:53:44,900 --> 00:53:47,800
但是你可以这么做 理论上是可以的

1285
00:53:47,800 --> 00:53:49,670
在这种情况下 sender 就应该是 AnyObject

1286
00:53:49,670 --> 00:53:51,570
这样你就可以这么写

1287
00:53:51,570 --> 00:53:53,470
if sender 是一个 Slider 的时候 做某些事情 else if

1288
00:53:53,470 --> 00:53:56,110
sender 是一个 Button 的时候 做别的事

1289
00:53:56,110 --> 00:53:57,540
可以用 as 来实现

1290
00:53:58,540 --> 00:53:59,110
ok？

1291
00:54:00,180 --> 00:54:02,980
这就是为什么我觉得默认不应该是 AnyObject

1292
00:54:02,980 --> 00:54:05,550
的原因 毕竟两个不同的 UI 元素发送同样 action 是

1293
00:54:05,550 --> 00:54:07,980
比较罕见的例子

1294
00:54:07,980 --> 00:54:11,220
所以我不太明白为什么要适应罕见的情况 如果是为了适用

1295
00:54:11,220 --> 00:54:13,920
于一些非常常见的例子的话 我会同意的

1296
00:54:13,920 --> 00:54:17,590
对我来说 这个非常容易犯错 但是无所谓了

1297
00:54:17,590 --> 00:54:20,590
上面就是 AnyObject 的另一个例子

1298
00:54:20,590 --> 00:54:22,760
这还有一个例子

1299
00:54:22,760 --> 00:54:24,660
再来看看这个 button

1300
00:54:24,670 --> 00:54:29,500
我说过 buttonWithType 返回一个 AnyObject

1301
00:54:29,500 --> 00:54:33,100
那么如果我有一个按钮 我需要知道它

1302
00:54:33,110 --> 00:54:36,010
的标题或者其他东西 我就需要做类型转换

1303
00:54:36,010 --> 00:54:40,310
这里我会调用 buttonWithType

1304
00:54:40,310 --> 00:54:43,680
然后做一个直接的类型转换 就在调用这行

1305
00:54:43,680 --> 00:54:46,350
如果我调用上边那行绿色代码

1306
00:54:46,350 --> 00:54:49,280
在下边我就可以写

1307
00:54:49,290 --> 00:54:52,120
title = (button as UIButton).currentTitle

1308
00:54:52,120 --> 00:54:54,360
这样我就把上边那个按钮的 AnyObject

1309
00:54:54,360 --> 00:54:57,360
转换成一个 UIButton

1310
00:54:57,360 --> 00:54:58,860
并且发送一个消息

1311
00:54:58,860 --> 00:55:00,130
所以你是可以做这样一个直接的类型转换

1312
00:55:00,130 --> 00:55:03,100
再说一次 如果这个按钮不是 UIButton 程序就崩溃了

1313
00:55:03,100 --> 00:55:04,100
不过也可以

1314
00:55:04,100 --> 00:55:06,020
在这个例子里

1315
00:55:06,020 --> 00:55:07,930
buttonWithType 我觉得最好还是直接返回 UIButton 比较好

1316
00:55:10,870 --> 00:55:15,270
继续 类型转换并不仅仅针对 AnyObject

1317
00:55:15,280 --> 00:55:17,180
你可以对任意两种不同的对象进行类型转换

1318
00:55:17,180 --> 00:55:20,410
对于所有的非 AnyObject 对象 需要类型转换的两个对象

1319
00:55:20,410 --> 00:55:23,880
必须在一条继承链上

1320
00:55:23,880 --> 00:55:24,920
明白？

1321
00:55:24,920 --> 00:55:26,220
并且只能向下转换

1322
00:55:26,220 --> 00:55:29,290
沿着继承链向下转换

1323
00:55:29,290 --> 00:55:34,060
举个例子 如果我有一个 UIViewController

1324
00:55:34,060 --> 00:55:36,890
类型的局部变量 vc  但是我需要把它

1325
00:55:36,890 --> 00:55:40,600
设置成 CalculatorViewController

1326
00:55:40,600 --> 00:55:43,160
我不可以直接写 vc.enter()

1327
00:55:43,170 --> 00:55:45,330
因为 enter() 是 CalculatorViewController 类的方法

1328
00:55:45,340 --> 00:55:49,470
所以我不能写 vc.enter() 因为vc是一个 UIViewController

1329
00:55:49,470 --> 00:55:52,470
至少 Swift 是这么认为的 所以 vc 不会响应 enter 方法

1330
00:55:52,470 --> 00:55:55,070
尽管它事实上是一个 CalculatorViewController

1331
00:55:55,080 --> 00:55:57,710
但是从 Swift 的角度看 它明显不是

1332
00:55:57,710 --> 00:55:59,350
它是一个 UIViewController 对象

1333
00:55:59,350 --> 00:56:04,150
但是我可以做一个类型转换 新建一个常量 calcVC = vc

1334
00:56:04,150 --> 00:56:09,520
as CalculatorViewController 现在就可以写 calcVC.enter()

1335
00:56:09,520 --> 00:56:10,820
好的

1336
00:56:10,820 --> 00:56:15,220
所以说 向下转换是可以的

1337
00:56:17,330 --> 00:56:19,960
我们很少这么做 但是你也许以后偶尔会做

1338
00:56:19,960 --> 00:56:21,960
好的

1339
00:56:21,970 --> 00:56:23,970
你们需要深入的

1340
00:56:23,970 --> 00:56:26,130
研究一下 AnyObject 的所有细节

1341
00:56:26,140 --> 00:56:27,540
当你在实际的项目中见到的时候

1342
00:56:27,540 --> 00:56:29,470
你就会更加透彻的理解了

1343
00:56:31,210 --> 00:56:33,290
下面咱们看一些在

1344
00:56:33,290 --> 00:56:35,380
所有我们见过的类里很有趣的函数

1345
00:56:35,380 --> 00:56:36,680
从 Array 开始

1346
00:56:37,750 --> 00:56:41,380
你们应该知道 Array 可以用 += .

1347
00:56:41,380 --> 00:56:42,850
Array +=

1348
00:56:42,850 --> 00:56:45,480
但是 += 的另外一个参数是另一个 Array

1349
00:56:46,590 --> 00:56:49,550
所以 如果你想用 += 把一个东西加到 Array 里

1350
00:56:49,560 --> 00:56:51,620
你需要把它放到另一个 Array 里

1351
00:56:51,620 --> 00:56:54,320
就是把它放到方括号里

1352
00:56:54,330 --> 00:56:56,410
有一些人在这里犯错误

1353
00:56:56,410 --> 00:56:58,500
比如他们有一个 Int 的 Array  他们想用 +=

1354
00:56:58,500 --> 00:57:01,260
他们会写我的 Array  += 一个 Int

1355
00:57:01,270 --> 00:57:02,630
然后他们就会纳闷为什么不行

1356
00:57:02,630 --> 00:57:07,140
这是因为 += 只能是一个 Array 加上另外一个 Array

1357
00:57:07,140 --> 00:57:08,570
这是一个 Array 的连接器

1358
00:57:11,240 --> 00:57:15,380
Array 还有一些有趣的变量

1359
00:57:15,380 --> 00:57:18,280
first 和 last 会分别返回

1360
00:57:18,280 --> 00:57:20,710
Array 的第一个和最后一个元素

1361
00:57:20,720 --> 00:57:22,050
它们有趣的地方是

1362
00:57:22,050 --> 00:57:23,720
他们返回一个 Optional

1363
00:57:23,720 --> 00:57:25,990
所以他们不会访问到越界的 Array 下标

1364
00:57:25,990 --> 00:57:28,350
当然如果 Array 是空的 它们会返回nil

1365
00:57:29,420 --> 00:57:33,260
你们应该了解这些 这会让你们的代码

1366
00:57:33,260 --> 00:57:36,130
有些时候看起来非常好看

1367
00:57:37,330 --> 00:57:38,700
下边我还有一个关于

1368
00:57:38,700 --> 00:57:40,800
Array 的小例子

1369
00:57:40,800 --> 00:57:42,930
这是一个有3个元素的 Array

1370
00:57:42,930 --> 00:57:44,370
我们不需要知道它们的类型

1371
00:57:44,370 --> 00:57:46,870
任何类型都可以

1372
00:57:46,870 --> 00:57:48,100
因为 Array 是泛型的

1373
00:57:48,110 --> 00:57:49,740
Array<T>

1374
00:57:49,740 --> 00:57:50,740
你可以假设

1375
00:57:50,740 --> 00:57:52,870
它们都是 T 类型

1376
00:57:52,880 --> 00:57:56,240
无论 T 是什么类型 我创建了一个 T 类型的 Array

1377
00:57:56,250 --> 00:57:58,610
让我们继续 你应该知道 append（追加 即在 Array 的末尾增加元素）方法

1378
00:57:58,610 --> 00:57:59,980
这就是我们在计算器的 App 中

1379
00:57:59,980 --> 00:58:02,020
对 Array 操作一直在使用的方法

1380
00:58:02,020 --> 00:58:03,520
当然  Array 也有 insert（插入）操作

1381
00:58:03,520 --> 00:58:05,020
你可以在 Array 中间的某个位置插入元素

1382
00:58:05,020 --> 00:58:06,920
通过指定一个 index（位置）

1383
00:58:06,920 --> 00:58:09,150
同样也有 splice 操作

1384
00:58:09,160 --> 00:58:10,590
Splice 操作会

1385
00:58:10,590 --> 00:58:15,060
将另外的一个 Array 加入到你的 Array 的中间位置

1386
00:58:15,060 --> 00:58:15,960
明白了吗？有时候

1387
00:58:15,960 --> 00:58:17,690
这个操作是十分重要的

1388
00:58:17,700 --> 00:58:19,460
它不像 insert 操作插入一个元素 它是

1389
00:58:19,460 --> 00:58:22,270
在 Array 中插入 Array 而不是元素的一种方法

1390
00:58:22,270 --> 00:58:25,670
当然还有 removeAtIndex 这样一个方法

1391
00:58:25,670 --> 00:58:29,240
如果你确定 Array 是变量 你可以利用这个方法来

1392
00:58:29,240 --> 00:58:31,440
从一个 Array 中移除一个元素

1393
00:58:31,440 --> 00:58:33,910
有了这个方法 也有 removeRange 方法

1394
00:58:33,910 --> 00:58:36,680
removeRange 的方法接受一个范围 并移除这个范围内的所有元素

1395
00:58:36,680 --> 00:58:38,450
你可以通过 ... 或者 ..< 来创建一个范围

1396
00:58:38,450 --> 00:58:41,250
并在 removeRange 方法中使用这个范围

1397
00:58:41,250 --> 00:58:43,520
另外 还有 replaceRange 这样的方法

1398
00:58:43,520 --> 00:58:46,190
当你替换一个范围内的元素时 替换的元素个数

1399
00:58:46,190 --> 00:58:47,420
不需要等于被替换的元素个数

1400
00:58:48,420 --> 00:58:51,220
假如我有一个包含3个元素的 Array  我将这个 Array 的全范围

1401
00:58:51,230 --> 00:58:55,130
替换成包含6个元素的 Array

1402
00:58:55,130 --> 00:58:56,700
这样就可以使原 Array 变长了

1403
00:58:56,700 --> 00:58:59,100
这就是 replaceRange

1404
00:58:59,100 --> 00:59:01,370
同样 Array 范型提供排序方法

1405
00:59:02,300 --> 00:59:04,000
你可以对一个 Array 进行排序

1406
00:59:04,000 --> 00:59:08,670
排序方法接受一个函数作为参数

1407
00:59:08,670 --> 00:59:13,310
一个决定两个元素

1408
00:59:13,310 --> 00:59:16,510
谁放在前面的函数

1409
00:59:16,510 --> 00:59:17,860
明白了吗？这个函数

1410
00:59:17,860 --> 00:59:19,210
将遍历整个 Array 并排序整个 Array

1411
00:59:19,220 --> 00:59:20,980
排序方法需要知道元素谁放在前面 它接受一个 Array  并传出一个 Array

1412
00:59:20,980 --> 00:59:23,050
无论是怎么样的排序算法 例如快排

1413
00:59:23,050 --> 00:59:25,690
我不知道里面用的什么排序算法

1414
00:59:25,690 --> 00:59:27,090
它只需要能够比较两个元素即可

1415
00:59:27,090 --> 00:59:30,790
你只需要提供一个比较函数

1416
00:59:30,790 --> 00:59:32,990
通常一般会把比较函数写成一个闭包

1417
00:59:32,990 --> 00:59:36,130
这里你可以看到这样的排序函数默认

1418
00:59:36,130 --> 00:59:39,330
两者之间通过小于来比较

1419
00:59:39,330 --> 00:59:44,170
例如：a.sort

1420
00:59:44,170 --> 00:59:45,990
明白了吗

1421
00:59:45,990 --> 00:59:47,800
如果 $0 < $1 的话 这个函数会返回 yes

1422
00:59:47,810 --> 00:59:49,740
这个返回结果是我们想了解的

1423
00:59:49,740 --> 00:59:52,540
sort 方法会不断的调用这个闭包

1424
00:59:52,550 --> 00:59:55,680
当它采用的是快速排序或者其他任何的排序算法

1425
00:59:55,680 --> 00:59:58,280
这里还有另外一个方法叫 sorted

1426
00:59:58,280 --> 01:00:00,550
在适当的地方

1427
01:00:00,550 --> 01:00:01,880
将整个 Array 进行排序

1428
01:00:01,890 --> 01:00:05,950
如果一个 Array 是已排序 它将会返回一个已排序的新 Array

1429
01:00:05,960 --> 01:00:07,590
这个意思是 一个已排序的 Array 的拷贝

1430
01:00:10,290 --> 01:00:11,490
接下来让我们看看更多的 Array 方法

1431
01:00:11,490 --> 01:00:14,460
这里有3个非常酷的方法

1432
01:00:14,460 --> 01:00:16,030
这一个叫 filter

1433
01:00:16,030 --> 01:00:19,100
filter 方法将你所有不想要的元素

1434
01:00:19,100 --> 01:00:22,800
过滤掉然后返回给你那个过滤后的 Array

1435
01:00:22,800 --> 01:00:25,570
你指定元素是不是你想要的方式 就是提供一个

1436
01:00:25,570 --> 01:00:27,510
函数作为参数

1437
01:00:27,510 --> 01:00:28,810
函数返回一个 Bool 的结果

1438
01:00:28,810 --> 01:00:31,080
来表明这个元素是不是想要的

1439
01:00:32,280 --> 01:00:32,840
明白了吗？

1440
01:00:33,850 --> 01:00:36,350
另外一个很酷的方法就是 mapping（映射）

1441
01:00:36,350 --> 01:00:39,380
这将会将你原来的 Array 中每一个元素

1442
01:00:39,380 --> 01:00:43,020
映射到一个新的 Array

1443
01:00:43,020 --> 01:00:44,450
原来的元素通过映射后的类型甚至都

1444
01:00:44,460 --> 01:00:46,690
不需要与原来的一样 好比我有一个 Int 型的 Array

1445
01:00:46,690 --> 01:00:49,090
我可以将这些元素映射为 String 类型

1446
01:00:49,090 --> 01:00:50,760
这就是我在这里所做的

1447
01:00:50,760 --> 01:00:52,230
这里 我有一个包含1 2 3的 Int 型 Array

1448
01:00:52,230 --> 01:00:54,390
我利用一个闭包将它们映射

1449
01:00:54,400 --> 01:00:59,800
到它们的字符串形式

1450
01:00:59,800 --> 01:01:02,940
从这些方法中你可以看到 Swift 语言是多么简洁

1451
01:01:02,940 --> 01:01:05,970
我的意思是 拿来一个 Int 型的 Array  将

1452
01:01:05,970 --> 01:01:08,570
它转变成一个 String 型的 Array  不需要循环

1453
01:01:08,580 --> 01:01:11,140
你只需要知道的是 你可以充分享受

1454
01:01:11,140 --> 01:01:13,110
Swift 语言带给你的闭包特性

1455
01:01:13,110 --> 01:01:15,910
不需要撰写

1456
01:01:15,920 --> 01:01:16,480
一大堆的代码

1457
01:01:16,480 --> 01:01:20,850
还有 你可以将整个 Array  reduce（减少）为一个值

1458
01:01:20,850 --> 01:01:23,920
这个方法接受一个参数

1459
01:01:23,920 --> 01:01:25,050
这个参数是你自定的初始值

1460
01:01:25,060 --> 01:01:26,790
还有一个函数作为参数

1461
01:01:26,790 --> 01:01:30,360
这个函数传入当前的值和下一个 Array 中的元素

1462
01:01:30,360 --> 01:01:31,830
你只需要返回他们两者的组合是什么

1463
01:01:31,830 --> 01:01:33,530
就这样你一直组合、组合、组合 直到得到最终的结果

1464
01:01:33,530 --> 01:01:36,060
举例来说 你想要累加整个 Array 中的值

1465
01:01:36,070 --> 01:01:38,570
你只需要输入 [1, 2, 3].reduce

1466
01:01:38,570 --> 01:01:41,470
然后我们以0为初始值 即第一个参数 我的闭包作为第二个参数

1467
01:01:41,470 --> 01:01:48,110
将下一个元素（$1）累加起来

1468
01:01:48,110 --> 01:01:52,510
以上就是所有 Array 中的方法 String

1469
01:01:52,510 --> 01:01:54,610
String 有一点点复杂

1470
01:01:57,690 --> 01:01:59,050
今天的课程我无法将所有 String 的内容讲完

1471
01:01:59,050 --> 01:02:00,790
String 的内容可能一直要持续到

1472
01:02:00,790 --> 01:02:02,650
下周三的课程

1473
01:02:02,660 --> 01:02:05,320
这个 Slide 包在这里

1474
01:02:05,320 --> 01:02:06,940
String

1475
01:02:06,940 --> 01:02:08,560
字符串处理的一个难点是处理索引

1476
01:02:08,560 --> 01:02:10,760
和创建字符串等其他的问题

1477
01:02:10,760 --> 01:02:13,360
一堆人会说：“我根本弄不明白怎么

1478
01:02:13,370 --> 01:02:16,100
在 Swift 中创建一个字符串的子串

1479
01:02:16,100 --> 01:02:18,150
太复杂了”

1480
01:02:18,150 --> 01:02:20,200
但是一旦你了解到字符串只不过是由一堆 Unicode 字符组成

1481
01:02:20,200 --> 01:02:23,840
的时候 你就不会希望你处理的子串的是

1482
01:02:23,840 --> 01:02:26,170
一堆由 Unicode 字符组成的了

1483
01:02:26,180 --> 01:02:27,210
你想要处理的是

1484
01:02:27,210 --> 01:02:29,610
单个的 Unicode 字素

1485
01:02:29,610 --> 01:02:33,750
字素是显示为单字符的文本单元

1486
01:02:33,750 --> 01:02:34,980
在 Unicode 编码中

1487
01:02:34,980 --> 01:02:36,820
一个字素有可能由多个字符组成

1488
01:02:36,820 --> 01:02:38,520
举例说 一个重音符号

1489
01:02:38,520 --> 01:02:41,290
在一些欧洲语系中有重音符号

1490
01:02:41,290 --> 01:02:44,560
你们中有些人应该知道 在法语中有 ´ 重音符号

1491
01:02:44,560 --> 01:02:46,390
对 就是这个斜向上的横线

1492
01:02:46,390 --> 01:02:48,460
带有这个重音符号的 é 就是由两个 Unicode 字符组成 e 和

1493
01:02:48,460 --> 01:02:50,430
重音符号 ´

1494
01:02:50,430 --> 01:02:53,300
两个 Unicode 字符组成一个字素

1495
01:02:53,300 --> 01:02:57,170
所以你不能在一个字符串像数组一样

1496
01:02:57,170 --> 01:02:58,200
使用索引

1497
01:02:58,200 --> 01:02:59,670
字符串是

1498
01:02:59,670 --> 01:03:01,140
简单的说 内部是

1499
01:03:01,140 --> 01:03:03,010
由一系列 Unicode 字符

1500
01:03:03,010 --> 01:03:04,770
组成的一个集合

1501
01:03:04,780 --> 01:03:06,310
你不能用整数来索引

1502
01:03:06,310 --> 01:03:08,980
因为你有可能碰巧遇到类似的重音符号

1503
01:03:08,980 --> 01:03:12,280
像数组一样用整数索引做有可能会把重音符号和

1504
01:03:12,280 --> 01:03:14,310
e 分开 而无法取得整个字符 é

1505
01:03:14,320 --> 01:03:17,050
所以字符串是由另外的一个类型来索引的

1506
01:03:17,050 --> 01:03:18,890
这种类型叫 String.Index

1507
01:03:18,890 --> 01:03:20,020
接下来 你如何

1508
01:03:20,020 --> 01:03:22,190
获得一个 String.Index 呢？

1509
01:03:22,190 --> 01:03:22,820
好

1510
01:03:22,820 --> 01:03:23,660
用 Slide 上这里说的函数

1511
01:03:23,660 --> 01:03:25,860
明白了吗？

1512
01:03:25,860 --> 01:03:28,060
你可以通过 startIndex 来获取这个字符串的开始位置

1513
01:03:28,060 --> 01:03:29,290
来得到一个 String.Index 类型的变量

1514
01:03:29,300 --> 01:03:30,530
刚才的那个方法 它会返回给你一个指向字符串开头的

1515
01:03:30,530 --> 01:03:31,960
String.Index 的变量

1516
01:03:31,960 --> 01:03:34,900
然后你可以讲这个索引向后推进

1517
01:03:34,900 --> 01:03:36,500
随便你想推进多少次都行

1518
01:03:36,500 --> 01:03:38,300
换言之 你在遍历整个字符的过程中

1519
01:03:38,300 --> 01:03:40,140
这种方法它会跳过整个 é 而不是只跳过一个 e 而停在重音符号上

1520
01:03:40,140 --> 01:03:42,440
明白了吗？

1521
01:03:43,640 --> 01:03:45,270
而你可以你使用下面的这个函数来推进你的 String.Index

1522
01:03:45,280 --> 01:03:47,910
这不是 String 类中的一个方法 这只是一个函数

1523
01:03:47,910 --> 01:03:50,180
一个叫 advance 的全局函数

1524
01:03:50,180 --> 01:03:52,610
你传入索引

1525
01:03:52,620 --> 01:03:55,180
同时 你告诉这个函数你想向后推进多少次

1526
01:03:55,180 --> 01:03:58,120
然后它就会返回给你一个新的索引位置

1527
01:03:58,120 --> 01:03:59,490
这里举一个例子

1528
01:03:59,490 --> 01:04:01,850
我有一个内容为 hello 的字符串

1529
01:04:01,860 --> 01:04:05,460
我想要知道第一个 l 的位置

1530
01:04:05,460 --> 01:04:06,590
我只需要输入

1531
01:04:06,590 --> 01:04:08,760
let index = advance ...

1532
01:04:08,760 --> 01:04:11,760
advance(s.startIndex, 2)

1533
01:04:12,900 --> 01:04:13,760
明白了吗？

1534
01:04:13,770 --> 01:04:15,480
然后它就会指向第一个 l 了

1535
01:04:15,480 --> 01:04:17,200
向前1个会指向 e 向后一个会指向 l

1536
01:04:17,200 --> 01:04:18,800
这里我再重申 假如这里不是 e 而是一个 é

1537
01:04:18,800 --> 01:04:21,640
刚才的操作他会向前推进4个 Unicode 字符

1538
01:04:21,640 --> 01:04:25,440
但只有第3个字符是 e

1539
01:04:25,440 --> 01:04:28,710
接下来 既然我已经有一个指向 l 的指针

1540
01:04:28,710 --> 01:04:31,480
我就可以用一个 String 类中的方法 叫 splice

1541
01:04:31,480 --> 01:04:33,950
字符串中的 splice 和数组中的 splice 方法很像

1542
01:04:33,950 --> 01:04:38,150
它会将一个字符串拼合到另外的一个字符串之中

1543
01:04:38,150 --> 01:04:40,450
明白吗？如果我在这个位置使用了 splice 方法

1544
01:04:40,460 --> 01:04:44,220
（另外一个字符串是 abc 的话）那么原先的字符串就会变成 heabcllo

1545
01:04:44,230 --> 01:04:47,260
将 abc 加入到这个中间的位置

1546
01:04:47,260 --> 01:04:49,230
明白了吗？

1547
01:04:49,230 --> 01:04:53,300
所以 startIndex 是在幕后起关键作用的

1548
01:04:53,300 --> 01:04:56,840
另外假如我说 我有两个局部变量 startIndex

1549
01:04:56,840 --> 01:05:00,470
和 endIndex

1550
01:05:00,470 --> 01:05:02,470
startIndex 是由最初的 startIndex 向后推进1个字符得到的 endIndex 是向后推进6个得到的

1551
01:05:02,480 --> 01:05:05,440
这也就意味着 我想这两个变量一个指向索引1的位置

1552
01:05:05,450 --> 01:05:08,150
另一个指向索引6的位置 然后我可以在这两个范围内创建一个子串

1553
01:05:08,150 --> 01:05:11,250
就像数组创建子数组一样

1554
01:05:11,250 --> 01:05:13,220
使用方括号得到一个字符串的子串

1555
01:05:13,220 --> 01:05:14,680
也就是说 字符串也可以使用方括号来创建子串

1556
01:05:14,690 --> 01:05:17,790
方括号里面是一个范围

1557
01:05:17,790 --> 01:05:19,320
范围由两个 String.Index 类型的

1558
01:05:19,320 --> 01:05:22,520
变量组成 一个在左侧

1559
01:05:22,530 --> 01:05:26,260
一个在右侧 中间是 ..

1560
01:05:26,260 --> 01:05:27,630
String.Index 类型而不是 Int 型 明白了吗？

1561
01:05:27,630 --> 01:05:29,000
这里我

1562
01:05:29,000 --> 01:05:31,930
通过向前推进到左侧的位置和右侧的位置 得到

1563
01:05:31,930 --> 01:05:34,670
截断的子串为 eabcl 的两个 String.Index 类型的变量

1564
01:05:34,670 --> 01:05:36,570
因为我从索引1的位置

1565
01:05:36,570 --> 01:05:41,110
也就是是第二个字符 索引0是第一个字符 这跟数组索引情况相似

1566
01:05:41,110 --> 01:05:44,580
到索引6 但是不包括索引6

1567
01:05:44,580 --> 01:05:46,040
每个人都理解了 String.Index 了吗？

1568
01:05:46,050 --> 01:05:49,550
以上这些是关于 advance 函数的

1569
01:05:49,550 --> 01:05:54,950
advance 函数是理解如何创建子串的关键

1570
01:05:54,950 --> 01:05:57,120
还有其他的东西 一旦你弄懂了这个

1571
01:05:57,120 --> 01:05:58,520
类似 rangeOfString 这样的东西你也会明白了

1572
01:05:58,520 --> 01:06:01,620
还记得我们在我们的计算器应用中用到了 rangeOfString

1573
01:06:01,630 --> 01:06:04,360
我告诉过你们 如果 rangeOfString 不能找到的想要的范围的话 会返回 nil

1574
01:06:04,360 --> 01:06:06,830
那么如果 rangeOfString 能找到范围的话 它会返回什么？

1575
01:06:06,830 --> 01:06:09,530
它会返回 Range

1576
01:06:09,530 --> 01:06:11,380
实际上

1577
01:06:11,380 --> 01:06:13,230
它会返回一个 Optional 的 Range

1578
01:06:13,240 --> 01:06:14,600
明白了吗？这就是如何使用这个方法

1579
01:06:14,600 --> 01:06:15,900
你们的作业中可能会用到它

1580
01:06:15,910 --> 01:06:17,540
你可以用到它 Optional 的性质

1581
01:06:17,540 --> 01:06:20,210
你更可以用到它 Range 的性质

1582
01:06:20,210 --> 01:06:22,490
比如我们想要在一个含有数字的字符串中

1583
01:06:22,490 --> 01:06:24,780
获取其中的数字部分

1584
01:06:24,780 --> 01:06:27,250
这里我有一个“56.25”的字符串

1585
01:06:27,250 --> 01:06:29,020
我想要获取整个数字部分

1586
01:06:29,020 --> 01:06:33,450
我可以这么做——首先找到小数点

1587
01:06:33,450 --> 01:06:34,940
然后

1588
01:06:34,940 --> 01:06:36,420
它会返回一个范围 如果它能够找到小数点

1589
01:06:36,420 --> 01:06:37,840
如果在我刚才的字符串中有小数点的话

1590
01:06:37,840 --> 01:06:39,260
这个方法会返回那个范围

1591
01:06:39,260 --> 01:06:43,230
接着我就可以用 num.startIndex 来获取那部分了

1592
01:06:43,230 --> 01:06:46,100
这里你可以看到 num 是一个数字 他的 startIndex 是

1593
01:06:46,100 --> 01:06:49,800
小数点之后的那个位置 而不是小数点 明白了吗？

1594
01:06:49,800 --> 01:06:51,400
现在我已经从字符串中提取了我想要的那部分

1595
01:06:53,470 --> 01:06:54,100
理解了吗？

1596
01:06:55,540 --> 01:06:57,640
所以 字符串和子字符串

1597
01:06:57,640 --> 01:07:01,240
一旦你了解了这些方法

1598
01:07:01,240 --> 01:07:03,410
我们就可以利用它们在字符串中移除整个数字部分

1599
01:07:03,410 --> 01:07:06,180
只需要对相同的范围使用 removeRange

1600
01:07:06,180 --> 01:07:09,420
num.startIndex 小数的范围

1601
01:07:09,420 --> 01:07:12,350
或者我们可以将这个范围替换成其他的东西 等等

1602
01:07:12,350 --> 01:07:15,060
好的 对字符串进行修改的方法大多数

1603
01:07:15,060 --> 01:07:17,890
都基于字符串的索引

1604
01:07:17,890 --> 01:07:19,360
还有另外一些字符串的方法

1605
01:07:19,360 --> 01:07:21,260
我会快速讲解其中的一些

1606
01:07:21,260 --> 01:07:22,930
你可以在文档里找到所有的这些方法

1607
01:07:22,930 --> 01:07:24,560
其中一些实际上从 NSString 中来的

1608
01:07:24,560 --> 01:07:26,400
稍后我会讲一下 NSString

1609
01:07:26,400 --> 01:07:28,770
你看你从 Slide 上可以找到 endIndex

1610
01:07:28,770 --> 01:07:31,740
还有我们之前讨论过的 join 方法

1611
01:07:31,740 --> 01:07:36,540
注意 还有一个方法是 toInt 而不是 toDouble

1612
01:07:36,540 --> 01:07:38,880
为什么在字符串操作中只有 toInt 而没有 toDouble？

1613
01:07:38,880 --> 01:07:40,610
有人知道原因吗？

1614
01:07:43,110 --> 01:07:45,480
这是因为如果你转换到一个 Double 时

1615
01:07:45,480 --> 01:07:46,980
你需要指定一些东西

1616
01:07:46,980 --> 01:07:48,720
你需要多少的有效位数？

1617
01:07:48,720 --> 01:07:50,720
你需要小数点后几位？

1618
01:07:50,720 --> 01:07:52,250
如此之类的问题

1619
01:07:52,250 --> 01:07:53,790
事实上没有地方去指定这些东西

1620
01:07:53,790 --> 01:07:55,560
如果有一个 toDouble 方法 那么会有一大堆的

1621
01:07:55,560 --> 01:07:57,790
参数来指定转换中的一些细节

1622
01:07:57,790 --> 01:08:00,490
但当你将字符串转换为 Int 时 这些细节都不存在了

1623
01:08:00,500 --> 01:08:01,890
你仅仅需要将它转换为 Int 对吗？

1624
01:08:01,900 --> 01:08:05,600
注意 toInt 方法返回的是一个 Optional Int

1625
01:08:05,600 --> 01:08:08,670
那是因为 当你调用 toInt 方法时

1626
01:08:08,670 --> 01:08:13,500
但是你的字符串是“hello” 此时会返回 nil 明白了吗？

1627
01:08:13,510 --> 01:08:15,840
String 中的方法 没问题了吧？

1628
01:08:16,880 --> 01:08:20,240
好的 其实有一些隐藏的方法

1629
01:08:20,250 --> 01:08:24,010
这些方法你根本不知道 这就是使用初始化方法实现转换

1630
01:08:24,020 --> 01:08:26,220
比如 我有一个 Double 的值

1631
01:08:26,220 --> 01:08:31,220
浮点数 我可以利用 let x = Int(d)

1632
01:08:31,220 --> 01:08:35,460
我就可以对这个值取下整并将它转化为一个 Int

1633
01:08:35,460 --> 01:08:37,020
这就是我如何转换的

1634
01:08:37,030 --> 01:08:38,590
我知道你们把这个东西转换成那个东西

1635
01:08:38,590 --> 01:08:39,860
或者从那个东西转换成这个东西

1636
01:08:39,860 --> 01:08:42,830
像 Int 和 Float 或者类似的

1637
01:08:42,830 --> 01:08:44,150
都可以这么做来相互转换

1638
01:08:44,150 --> 01:08:45,460
下周你们会使用到 CGFloat

1639
01:08:45,470 --> 01:08:47,900
这是另外一种浮点数

1640
01:08:47,900 --> 01:08:49,340
同样你可以通过转换使用它

1641
01:08:49,340 --> 01:08:50,740
但是 CGFloat 没有 toInt 或者其他的方法

1642
01:08:50,740 --> 01:08:53,410
你只能通过初始化方法（initializer）创建一个 CGFloat 对象

1643
01:08:53,410 --> 01:08:54,410
接下来 Numbers

1644
01:08:54,410 --> 01:08:56,210
你会感到惊讶的是

1645
01:08:56,210 --> 01:08:57,740
如果你之前认真地读过了课后作业的要求

1646
01:08:57,740 --> 01:08:59,710
你会看到

1647
01:08:59,710 --> 01:09:02,210
你可以在 Array 和字符串之间

1648
01:09:02,210 --> 01:09:06,520
通过初始化方法完成相互转化

1649
01:09:06,520 --> 01:09:11,150
举例 你通过调用 Array("abc") 来

1650
01:09:11,160 --> 01:09:13,920
创建一个数组

1651
01:09:13,920 --> 01:09:15,090
这个方法会返回一个数组

1652
01:09:15,090 --> 01:09:18,230
而数组中的元素是字符串中的字符

1653
01:09:18,230 --> 01:09:20,800
Unicode 字符

1654
01:09:20,800 --> 01:09:23,360
相反的 你有一个包含一堆 Unicode 字符的数组

1655
01:09:23,370 --> 01:09:25,400
是吧？

1656
01:09:25,400 --> 01:09:27,430
你可以使用 String 的构建器（constructor）来创建一个字符串

1657
01:09:27,440 --> 01:09:29,970
字符串中字符由数组中元素拼接而成

1658
01:09:31,370 --> 01:09:32,660
明白了吗？

1659
01:09:32,660 --> 01:09:33,940
所以还有一些隐藏的方法

1660
01:09:35,640 --> 01:09:38,210
但是 注意你不能调用 let s = Stirng(52.5)

1661
01:09:38,210 --> 01:09:40,950
但是你可以通过 let s = "\(37.5)" 来实现

1662
01:09:40,950 --> 01:09:43,310
浮点数到字符串之间的

1663
01:09:43,320 --> 01:09:45,080
转换

1664
01:09:46,850 --> 01:09:47,720
明白了吗？你可以

1665
01:09:47,720 --> 01:09:49,190
let s = String(52) 这么做

1666
01:09:49,190 --> 01:09:51,350
因为 String 有 toInt 这个方法 它知道如何将 Int 转换成字符串

1667
01:09:52,720 --> 01:09:54,290
接下来 Assertions

1668
01:09:54,290 --> 01:09:57,360
Assertions 是一个很有用的 debug 方法

1669
01:09:57,360 --> 01:10:01,200
它们接受一个闭包作为其第一个参数

1670
01:10:01,200 --> 01:10:02,430
闭包是 autoclosure 的

1671
01:10:02,430 --> 01:10:03,630
这意味着你不需要花括号

1672
01:10:03,630 --> 01:10:05,930
这是一个很有意思的事情

1673
01:10:06,940 --> 01:10:10,040
总而言之 第一个参数应该是

1674
01:10:10,040 --> 01:10:11,270
在闭包括号内的那些东西

1675
01:10:11,270 --> 01:10:14,240
assert() 的第二个参数是一个字符串

1676
01:10:14,240 --> 01:10:18,180
假如 assert 方法的第一个参数返回的是 false

1677
01:10:18,180 --> 01:10:22,810
这个字符串将会在你的控制台中输出

1678
01:10:22,820 --> 01:10:24,720
这是因为你 assert 的条件应该是成立的

1679
01:10:24,720 --> 01:10:26,150
如果不成立 那么它会导致你的程序崩溃

1680
01:10:27,250 --> 01:10:28,350
这时在控制台中输出一个信息

1681
01:10:28,350 --> 01:10:30,240
对程序的 debug 是很有帮助的

1682
01:10:30,240 --> 01:10:32,120
因为你的程序因为某些条件的不满足而导致崩溃

1683
01:10:32,120 --> 01:10:35,790
assert 方法会在你生成程序的 Release 版本的时候

1684
01:10:35,790 --> 01:10:37,490
失效 也就是提交到 App Store 的版本

1685
01:10:37,490 --> 01:10:40,600
当你在把程序提交到 App Store 的时候 assert 不会工作

1686
01:10:40,600 --> 01:10:42,630
这时 它甚至不会对闭包求值

1687
01:10:42,630 --> 01:10:43,300
它们被忽略了

1688
01:10:44,400 --> 01:10:46,130
这个在 debug 中很有用

1689
01:10:46,140 --> 01:10:50,100
我可能会有一个叫 validation 的函数

1690
01:10:50,110 --> 01:10:52,940
当我在执行 assert 的时候

1691
01:10:52,940 --> 01:10:54,940
不应该返回 nil

1692
01:10:54,940 --> 01:10:59,240
而且 它如果返回 nil 了 这会把程序搞崩溃

1693
01:10:59,250 --> 01:11:04,080
这里我写 assert(validation() != nil, "the validation fucniton return nil")

1694
01:11:04,080 --> 01:11:04,650
ok？

1695
01:11:05,890 --> 01:11:10,290
assert 在很多语言中都有实现 Swift 也有一样

1696
01:11:10,290 --> 01:11:12,820
好的 还有一些其他的函数

1697
01:11:12,820 --> 01:11:15,830
这些函数并没有出现在文档中

1698
01:11:15,830 --> 01:11:18,330
所以我的 Slide 可能是唯一你们可以参考的文档

1699
01:11:18,330 --> 01:11:20,030
我相信你们在网上也可以找到这些

1700
01:11:20,030 --> 01:11:22,000
可能网上的资料还要更详细一点

1701
01:11:22,000 --> 01:11:24,300
这些是全局函数 并不是 String, Array 或者其他的 struct 的方法

1702
01:11:24,300 --> 01:11:26,870
它们接受一些参数 这些参数

1703
01:11:26,870 --> 01:11:28,900
目前我很难跟你们解释

1704
01:11:28,900 --> 01:11:32,040
但是你们只需要知道这些函数可以接受 Array, Dictionary, String 的参数

1705
01:11:32,040 --> 01:11:34,240
因为它们还接受 Array, Dictionary, String 的参数

1706
01:11:34,240 --> 01:11:37,440
和其他的一些东西

1707
01:11:37,450 --> 01:11:40,980
你可以看一遍这个列表

1708
01:11:40,980 --> 01:11:42,850
我会将它和 String 中的方法

1709
01:11:42,850 --> 01:11:45,950
混合在一起

1710
01:11:45,950 --> 01:11:47,620
传入一个由字符组成的数组

1711
01:11:47,620 --> 01:11:51,690
我可以拿一个字符串 在它之上调用 reverse 方法

1712
01:11:51,690 --> 01:11:55,730
返回这些字符的反转 然后再调用

1713
01:11:55,730 --> 01:11:59,200
String 的方法创建一个新的字符串

1714
01:11:59,200 --> 01:12:00,500
明白了吗？

1715
01:12:00,500 --> 01:12:02,070
Objective-C 兼容性

1716
01:12:02,070 --> 01:12:04,320
这个话题

1717
01:12:04,320 --> 01:12:06,570
我们下一次再讲

1718
01:12:06,570 --> 01:12:08,000
这是一个很重要的话题

1719
01:12:08,010 --> 01:12:09,440
我想好好探讨一下

1720
01:12:09,440 --> 01:12:11,170
这就是今天课程的所有内容

1721
01:12:11,180 --> 01:12:15,880
最后让我快速给你们看一下这页 Slide

1722
01:12:17,710 --> 01:12:20,050
周五没有课程

1723
01:12:20,050 --> 01:12:21,820
下周一是节假日 也没有课程

1724
01:12:21,820 --> 01:12:23,130
下周三

1725
01:12:23,130 --> 01:12:24,450
我可能会讲一些 Auto Layout 的话题

1726
01:12:24,450 --> 01:12:26,420
但不一定

1727
01:12:26,420 --> 01:12:28,390
课后作业一今天截止 课后作业二

1728
01:12:28,390 --> 01:12:31,520
我也贴出来了 你们的阅读作业二会在

1729
01:12:31,530 --> 01:12:35,160
（下）周一贴上来 然后所有的东西下周三截止

1730
01:12:35,160 --> 01:12:36,930
如果你们有其他的疑问 欢迎来询问

1731
01:12:36,930 --> 01:12:42,400
更多课程 请访问 stanford.edu

