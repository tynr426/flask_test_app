1
00:00:05,600 --> 00:00:07,400
斯坦福大学

2
00:00:08,400 --> 00:00:17,600
CS193P iOS开发应用系统

3
00:00:08,850 --> 00:00:11,550
好的 欢迎来到2011年秋季

4
00:00:11,550 --> 00:00:14,910
CS193P第二课程

5
00:00:14,910 --> 00:00:16,620
这实际上不是一堂正规的课堂讲课

6
00:00:16,620 --> 00:00:18,130
全都是做些演示而已

7
00:00:18,130 --> 00:00:19,960
好了 言归正传 我们直接进入演示

8
00:00:19,960 --> 00:00:23,030
这个演示要花掉全部时间

9
00:00:23,030 --> 00:00:29,640
演示中我们讨论的是模型视图控制器

10
00:00:29,650 --> 00:00:31,750
好 我们要做一个简单的模型视图控制器

11
00:00:31,760 --> 00:00:33,450
但是 今天的主要内容

12
00:00:33,460 --> 00:00:35,690
是让你们知道Xcode 4是什么东西

13
00:00:35,690 --> 00:00:38,840
了解编写Objective-C程序是怎么回事

14
00:00:38,850 --> 00:00:41,250
包括创建我们的模型视图和控制器

15
00:00:41,250 --> 00:00:45,730
好的 我现在打开了Xcode

16
00:00:45,730 --> 00:00:48,340
运行Xcode时 你会看到这种闪屏

17
00:00:48,340 --> 00:00:51,340
你可以在屏幕的右边

18
00:00:51,340 --> 00:00:54,610
看到你最近打开的所有项目列表

19
00:00:54,620 --> 00:00:55,980
如果运行Xcode时

20
00:00:55,980 --> 00:00:58,040
这里是空白一片 就像这右边的空白一样

21
00:00:58,040 --> 00:01:00,950
是因为我们还没有编写我们的第一个程序

22
00:01:00,950 --> 00:01:03,070
现在我们将编写我们的第一个程序

23
00:01:03,070 --> 00:01:04,620
这儿还提供了一些其他选项

24
00:01:04,620 --> 00:01:06,100
我们今天有时间来操作这些选项

25
00:01:06,100 --> 00:01:09,350
现在我要从这个非常重要的选项开始了

26
00:01:09,350 --> 00:01:11,320
那就是创建一个新项目

27
00:01:11,330 --> 00:01:14,850
点击这个选项

28
00:01:14,850 --> 00:01:18,780
我们就立即进入到Xcode 4的项目创建界面

29
00:01:18,780 --> 00:01:21,600
这里Xcode 4要求我们

30
00:01:21,600 --> 00:01:24,770
为应用程序选择一个模板

31
00:01:24,770 --> 00:01:27,150
这些模板里面没有很多代码

32
00:01:27,150 --> 00:01:28,920
只有一点代码

33
00:01:28,930 --> 00:01:30,460
你可以看到这儿的一个模板

34
00:01:30,470 --> 00:01:32,700
它是用于创建基于文档的应用程序模板

35
00:01:32,700 --> 00:01:34,970
还有开放性图形库Open GL游戏模板

36
00:01:34,980 --> 00:01:37,250
创建基于页面的应用程序

37
00:01:37,250 --> 00:01:40,280
如iBook以及一些应用程序的模板

38
00:01:40,280 --> 00:01:43,440
今天我们选择这个最基本的模板

39
00:01:43,440 --> 00:01:45,690
这个或许就是你们这学期最经常用到的

40
00:01:45,690 --> 00:01:47,510
这就是单一视图应用程序

41
00:01:47,510 --> 00:01:50,730
单一视图应用程序模板的作用是

42
00:01:50,730 --> 00:01:56,320
创建控制器和空白视图

43
00:01:56,320 --> 00:02:00,350
所以它基本上就是创建单一MVC应用程序

44
00:02:00,350 --> 00:02:03,450
它可用来创建模板控制器和空白视图

45
00:02:03,460 --> 00:02:04,990
并且你必须创建自定义模型......

46
00:02:04,990 --> 00:02:07,260
下面我们将创建自定义模型

47
00:02:07,260 --> 00:02:09,130
好的 我们点击下一步按键

48
00:02:09,130 --> 00:02:12,700
现在我们需要填写项目的一些详细信息

49
00:02:12,700 --> 00:02:13,870
比如它的名称

50
00:02:13,870 --> 00:02:17,230
今天 我们要创建一个RPN计算器

51
00:02:17,230 --> 00:02:20,460
就是我上次说的逆波兰式算法计算器

52
00:02:20,460 --> 00:02:22,230
它是这样的一种计算器

53
00:02:22,230 --> 00:02:25,160
如果你使用回车键输入所有的数字

54
00:02:25,170 --> 00:02:27,040
然后运算就会把数字

55
00:02:27,040 --> 00:02:29,190
从运算堆栈中取出

56
00:02:29,190 --> 00:02:31,620
比如 你想进行3+5的计算

57
00:02:31,620 --> 00:02:34,470
你输入3回车 5 回车 加号

58
00:02:34,470 --> 00:02:36,300
那么就会把3和5取出来

59
00:02:36,300 --> 00:02:37,680
它们加起来等于8

60
00:02:37,680 --> 00:02:39,200
然后将8放回到堆栈

61
00:02:39,200 --> 00:02:42,040
然后输入6 加号 就会得到14

62
00:02:42,040 --> 00:02:44,040
所以这仅仅只是数字堆栈

63
00:02:44,040 --> 00:02:45,990
这就是我们要创建的

64
00:02:45,990 --> 00:02:49,130
产品名称为计算器

65
00:02:49,130 --> 00:02:52,110
下一个字段是公司标识符

66
00:02:52,110 --> 00:02:55,750
它会将你的应用程序单独标识出来

67
00:02:55,750 --> 00:03:00,470
你可以使用这种反向域名解析的结构

68
00:03:00,470 --> 00:03:05,050
我们将其命名为edu.stanford.cs193p.你的名字

69
00:03:05,050 --> 00:03:06,180
好了 这个标识符非常独特

70
00:03:06,180 --> 00:03:08,930
它不会与别人的标识符冲突

71
00:03:08,930 --> 00:03:11,080
比如 你想使用Stanford ID

72
00:03:11,080 --> 00:03:12,810
或者其他的 还可以加上导师名字

73
00:03:12,810 --> 00:03:14,820
这可以说是非常独特的了

74
00:03:14,820 --> 00:03:18,440
还有类前缀

75
00:03:18,450 --> 00:03:19,690
要记得这个模板

76
00:03:19,700 --> 00:03:22,930
会为你生成控制类

77
00:03:22,930 --> 00:03:25,600
类名就叫做view controller

78
00:03:25,600 --> 00:03:27,910
这是一个非常常见的类名称

79
00:03:27,910 --> 00:03:30,880
你可以在它前面加上一个单词

80
00:03:30,880 --> 00:03:32,830
使类名称不那么普通

81
00:03:32,840 --> 00:03:34,260
我们使用calculator

82
00:03:34,260 --> 00:03:36,000
以前Xcode总是默认使用

83
00:03:36,010 --> 00:03:37,420
应用程序名称作为类前缀

84
00:03:37,420 --> 00:03:38,410
但是现在你可以自己设置它的名称

85
00:03:38,420 --> 00:03:41,860
现在我们的控制器会命名为calculator view controller

86
00:03:41,860 --> 00:03:44,460
而不是简单的view controller

87
00:03:44,470 --> 00:03:48,260
此处我们可以选择为iPhone或iPad构建应用程序

88
00:03:48,260 --> 00:03:51,700
或者是适用于二者运行的通用应用程序

89
00:03:51,700 --> 00:03:55,290
在iOS和 Xcode里

90
00:03:55,290 --> 00:03:58,980
可以构建有两个不同用户界面的应用程序

91
00:03:58,980 --> 00:04:00,870
一个界面适用于iPad 另一个界面适用于iPhone

92
00:04:00,870 --> 00:04:02,230
这真是挺棒的

93
00:04:02,240 --> 00:04:04,160
因为你想共享很多控制器

94
00:04:04,160 --> 00:04:06,100
模型之类的东西

95
00:04:06,100 --> 00:04:09,180
但是你的视图

96
00:04:09,180 --> 00:04:10,640
控制器与某些视图之间

97
00:04:10,640 --> 00:04:11,700
交互的方式可能是不一样的

98
00:04:11,700 --> 00:04:12,950
如果你有很多屏幕实时状态

99
00:04:12,950 --> 00:04:14,800
你可以将许多东西同时放在

100
00:04:14,800 --> 00:04:17,720
一个小手机界面上

101
00:04:17,720 --> 00:04:19,440
我们会在本学期后期学习这些

102
00:04:19,440 --> 00:04:20,420
但是为简单起见

103
00:04:20,420 --> 00:04:23,200
我们这个程序只适用于iPhone

104
00:04:23,200 --> 00:04:24,960
这个使用Storyboard

105
00:04:24,960 --> 00:04:27,270
Storyboard是iOS5新增功能

106
00:04:27,270 --> 00:04:29,710
它的基本功能允许你同时在屏幕上显示

107
00:04:29,710 --> 00:04:32,730
所有的MVC视图

108
00:04:32,730 --> 00:04:34,550
因此 你可以看到它们之间是如何交互的

109
00:04:34,560 --> 00:04:38,740
你们还记得我在上次课中演示的内容吧

110
00:04:38,740 --> 00:04:40,130
在很多的MVC之间

111
00:04:40,130 --> 00:04:41,370
进行了很好的交互

112
00:04:41,370 --> 00:04:42,950
Storyboard让你能够

113
00:04:42,950 --> 00:04:45,820
在屏幕上同时看到那些交互

114
00:04:45,820 --> 00:04:48,140
所以 你能够看到MVC之间是如何交互的

115
00:04:48,140 --> 00:04:49,660
这真的棒极了

116
00:04:49,660 --> 00:04:52,720
自动引用计数系统更棒

117
00:04:52,720 --> 00:04:55,580
因为在iOS4中你必须手动

118
00:04:55,580 --> 00:04:58,700
使用引用计数来管理所有对象的内存

119
00:04:58,700 --> 00:04:59,990
那真是一项乏味烦琐的工作

120
00:04:59,990 --> 00:05:02,990
而自动引用计数可以在编译时帮助你完成

121
00:05:02,990 --> 00:05:05,810
它能够管理所有内存

122
00:05:05,820 --> 00:05:08,550
当内存丢失或者在存取的时候

123
00:05:08,550 --> 00:05:11,050
利用这项看似小实则很强大的程序

124
00:05:11,050 --> 00:05:14,150
它真的很不错 记得勾选上它

125
00:05:14,150 --> 00:05:17,300
单元测试我们可能放到学期末讲

126
00:05:17,300 --> 00:05:20,580
这里我们不选

127
00:05:20,580 --> 00:05:21,610
我们点击下一步

128
00:05:21,610 --> 00:05:24,900
现在 它想要知道你要把你的项目储存在哪儿

129
00:05:24,900 --> 00:05:27,110
我强烈建议你们把它

130
00:05:27,110 --> 00:05:28,920
储存在根目录下的

131
00:05:28,920 --> 00:05:32,530
developer的文件夹里

132
00:05:32,530 --> 00:05:34,430
这是我的根目录 CS193P

133
00:05:34,430 --> 00:05:38,090
这个是developer文件夹

134
00:05:38,090 --> 00:05:41,060
如果你没有这个目录

135
00:05:41,060 --> 00:05:43,860
你可以使用新建文件夹来创建这个目录

136
00:05:43,860 --> 00:05:45,790
当我在这儿点击"创建"时

137
00:05:45,790 --> 00:05:48,980
它就会创建文件夹来保存我的计算器程序

138
00:05:48,980 --> 00:05:50,480
这个文件夹可以命名为calculator

139
00:05:50,480 --> 00:05:53,400
保存在我的根目录\developer路径下

140
00:05:53,400 --> 00:05:54,500
这个位置很不错

141
00:05:54,500 --> 00:05:56,730
我强烈推荐你们将程序存在这

142
00:05:56,730 --> 00:05:59,560
在这儿下面你可以看到源代码控制

143
00:05:59,560 --> 00:06:01,960
我们当然要来讨论一下源代码控制

144
00:06:01,960 --> 00:06:04,230
它已经很好地移植到了Xcode 4上

145
00:06:04,230 --> 00:06:07,060
但是在第一个项目里  我们不准备做这个

146
00:06:07,060 --> 00:06:09,140
所以不要勾选这项

147
00:06:09,140 --> 00:06:12,160
我点击了这儿的"创建"按键

148
00:06:12,160 --> 00:06:13,270
创建了我们的项目

149
00:06:13,270 --> 00:06:16,170
现在 看这个初始界面

150
00:06:16,180 --> 00:06:18,280
我将它放大到全屏 用快捷键Y

151
00:06:18,280 --> 00:06:19,810
放大到全屏

152
00:06:19,810 --> 00:06:23,320
屏幕上有很多东西 所有的图标等等

153
00:06:23,320 --> 00:06:24,670
但是这些只是其中的一半

154
00:06:24,670 --> 00:06:27,600
这里还有各种设置 如创建规则 创建阶段等等

155
00:06:27,600 --> 00:06:28,870
我们不能......

156
00:06:28,870 --> 00:06:30,670
我们在这学期会学习所有这些设置

157
00:06:30,670 --> 00:06:34,010
但是今天我们不讲这些

158
00:06:34,010 --> 00:06:36,930
我们今天的重点是左边这些

159
00:06:36,930 --> 00:06:40,240
左侧这个区域叫导航器

160
00:06:40,240 --> 00:06:42,810
它显示了项目中的所有文件

161
00:06:42,810 --> 00:06:45,050
你们可以按文件夹和其他东西将它们分组

162
00:06:45,050 --> 00:06:46,630
跟随课程的进行我们将会学习这些

163
00:06:46,630 --> 00:06:49,710
现在我们只看其中的三个文件

164
00:06:49,710 --> 00:06:51,250
其余的都不看

165
00:06:51,250 --> 00:06:52,950
MainsStoryboard.storyboard

166
00:06:52,950 --> 00:06:53,590
看到了吗？

167
00:06:53,590 --> 00:06:55,570
还有Calculator.ViewController.m

168
00:06:55,570 --> 00:06:56,790
和Calculator.ViewController.h

169
00:06:56,790 --> 00:06:59,140
好了 所以我想从MainsStoryboard.storyboard开始

170
00:06:59,140 --> 00:07:02,490
它是MVC视图

171
00:07:02,490 --> 00:07:04,890
实际上是我们全部的MVC视图

172
00:07:04,890 --> 00:07:07,110
都属于这个类中的主面板

173
00:07:07,110 --> 00:07:08,810
在MVC里面

174
00:07:08,810 --> 00:07:11,760
可以有多个Storyboard等等 但是

175
00:07:11,760 --> 00:07:13,610
那样的话应用程序会很复杂

176
00:07:13,610 --> 00:07:16,320
所以在这个例子里 我们的Storyboard

177
00:07:16,320 --> 00:07:19,450
包含控制器的所有视图

178
00:07:19,450 --> 00:07:21,540
接下来看calculatorviewcontroller.m

179
00:07:21,540 --> 00:07:22,100
和Calculator.ViewController.h

180
00:07:22,100 --> 00:07:25,380
你们记得上次课中提到的类吗

181
00:07:25,380 --> 00:07:27,940
有一个头文件.h和一个实现文件.m

182
00:07:27,940 --> 00:07:30,160
就是这两个文件

183
00:07:30,160 --> 00:07:32,450
这是控制器 这是视图

184
00:07:32,450 --> 00:07:34,960
等一下我们要创建模型

185
00:07:34,960 --> 00:07:37,740
它不能为你创建模型 你知道

186
00:07:37,740 --> 00:07:39,150
在哪里创建模型

187
00:07:39,150 --> 00:07:41,120
我们要从Storyboard开始

188
00:07:41,120 --> 00:07:47,760
点击一下Storyboard 这个视图就弹出来了

189
00:07:47,760 --> 00:07:50,240
你看到的是一片空白

190
00:07:50,240 --> 00:07:52,520
这就是控制器的视图

191
00:07:52,520 --> 00:07:54,930
它是空白的 你看到它类似于iPhone的大小

192
00:07:54,940 --> 00:07:56,250
以后的课程中我们会讨论

193
00:07:56,250 --> 00:07:57,670
如何改变尺寸等

194
00:07:57,670 --> 00:08:00,230
相关的内容

195
00:08:00,230 --> 00:08:02,810
目前它的尺寸差不多刚刚好

196
00:08:02,810 --> 00:08:04,370
和一台iPhone的大小差不多

197
00:08:04,370 --> 00:08:08,440
这块小区域是用来浏览视图中所有对象的

198
00:08:08,440 --> 00:08:10,060
按对象名查看

199
00:08:10,060 --> 00:08:12,270
现在这里只有顶层视图

200
00:08:12,280 --> 00:08:14,580
今天我们不看这一部分

201
00:08:14,580 --> 00:08:15,770
但是 当你做的时候

202
00:08:15,770 --> 00:08:19,120
你应该可以注意到这部分

203
00:08:19,120 --> 00:08:21,350
点击关闭按钮隐藏这一部分

204
00:08:21,350 --> 00:08:25,040
我也不需要这个导航器一直显示在这里

205
00:08:25,040 --> 00:08:27,850
会浪费非常宝贵的屏幕空间

206
00:08:27,850 --> 00:08:29,960
我要使用右上部的这些按钮

207
00:08:29,960 --> 00:08:31,810
你看到这儿有一个编辑器和视图工具

208
00:08:31,820 --> 00:08:34,750
这些是用来管理屏幕上的东西的

209
00:08:34,750 --> 00:08:37,930
好了点击这个按键

210
00:08:37,930 --> 00:08:39,650
它是用来隐藏和显示导航器的

211
00:08:39,650 --> 00:08:42,750
屏幕显示空间更大了

212
00:08:42,750 --> 00:08:44,820
现在 我真正想要的是

213
00:08:44,820 --> 00:08:47,920
除了有这边屏幕上的这个视图

214
00:08:47,920 --> 00:08:51,330
我还想在屏幕上同时显示控制器代码

215
00:08:51,330 --> 00:08:53,540
让其并排显示 这样我可以对它们同时进行操作

216
00:08:53,540 --> 00:08:54,740
因为它们需要一起运行

217
00:08:54,740 --> 00:08:56,560
视图是控制器的随从

218
00:08:56,560 --> 00:08:59,140
我可以点击这个图标来实现

219
00:08:59,140 --> 00:09:01,640
这个图标有点儿像男士礼服

220
00:09:01,640 --> 00:09:02,910
它看起像是管家之类的什么东西

221
00:09:02,910 --> 00:09:06,170
这是辅助编辑器 如果你点击它

222
00:09:06,170 --> 00:09:09,090
屏幕会分成两个部分

223
00:09:09,090 --> 00:09:11,120
为了查看两个相关的东西

224
00:09:11,130 --> 00:09:12,790
有一点是很重要

225
00:09:12,790 --> 00:09:15,160
就是要知道在你移动鼠标时 它会使用Xcode

226
00:09:15,160 --> 00:09:17,190
将这两个东西关联在一起

227
00:09:17,190 --> 00:09:20,680
我们接下来会讲到

228
00:09:20,680 --> 00:09:22,970
中间这栏可以移动

229
00:09:22,970 --> 00:09:25,110
就是这样 你可以调整空间大小

230
00:09:25,110 --> 00:09:26,720
将视图移动到边上

231
00:09:26,720 --> 00:09:28,360
为代码腾出更多空间

232
00:09:28,360 --> 00:09:29,800
我将这边的字号调得很大

233
00:09:29,800 --> 00:09:31,290
这样你们才能看清

234
00:09:31,290 --> 00:09:35,230
所以我给代码部分分出尽可能多的空间

235
00:09:35,230 --> 00:09:38,640
现在 你应该认出来了

236
00:09:38,640 --> 00:09:41,640
这是我们上次课中的controller.h

237
00:09:41,640 --> 00:09:43,260
这是它的界面

238
00:09:43,260 --> 00:09:45,680
这是超类 超类是从

239
00:09:45,680 --> 00:09:48,110
这个UIkit框架文件导入的

240
00:09:48,110 --> 00:09:49,400
我们讨论过了

241
00:09:49,400 --> 00:09:53,200
我们目前没有公共接口 对吧

242
00:09:53,200 --> 00:09:55,600
我们马上来看一下执行文件

243
00:09:55,600 --> 00:09:58,490
所以我们要直接为我们的计算器

244
00:09:58,490 --> 00:09:59,580
创建用户界面

245
00:09:59,580 --> 00:10:00,690
为了创建界面

246
00:10:00,690 --> 00:10:04,380
显然我们需要按钮 标记 标签区域

247
00:10:04,380 --> 00:10:06,380
这样它们就可以显示在计数器上

248
00:10:06,380 --> 00:10:11,240
所有这些东西都是通过右边的这个小按钮生成的

249
00:10:11,240 --> 00:10:12,720
右上角这里

250
00:10:12,720 --> 00:10:14,090
点击它以后

251
00:10:14,090 --> 00:10:16,540
会展开一个小工作区

252
00:10:16,540 --> 00:10:19,910
分为上下两部分

253
00:10:19,920 --> 00:10:23,340
上面的部分称作检查器

254
00:10:23,340 --> 00:10:27,270
用来显示选定对象的所有信息

255
00:10:27,270 --> 00:10:28,980
所以如果我选择了这个视图

256
00:10:28,980 --> 00:10:30,670
就会得到关于这个视图的信息

257
00:10:30,670 --> 00:10:32,240
这些是视图属性

258
00:10:32,240 --> 00:10:35,280
今天我们没有时间来讲这些

259
00:10:35,280 --> 00:10:36,400
但是随着课程的进行

260
00:10:36,400 --> 00:10:37,420
我们会逐渐学到
we‘ll see these more and more

261
00:10:37,420 --> 00:10:38,910
下面的部分是

262
00:10:38,910 --> 00:10:40,800
你可以将其想象为一个调色板

263
00:10:40,810 --> 00:10:44,900
你可以使用调色板上的东西给视图上色

264
00:10:44,900 --> 00:10:46,390
这个调色板还包括代码

265
00:10:46,390 --> 00:10:48,570
代码片段等等

266
00:10:48,570 --> 00:10:50,740
再往下我们就需要使用这个了

267
00:10:50,740 --> 00:10:53,820
你可看到调色板里的这些东西

268
00:10:53,820 --> 00:10:56,100
我们选择这个 它看起来像一个对象

269
00:10:56,100 --> 00:10:59,440
我们需要从对象库中选择对象

270
00:10:59,440 --> 00:11:01,090
因为我们想获取按钮之类的东西

271
00:11:01,090 --> 00:11:02,970
所以 你看这个对象库

272
00:11:02,980 --> 00:11:04,460
里面的对象实在太多了

273
00:11:04,460 --> 00:11:07,840
滑动条 开关 网页视图和表视图等

274
00:11:07,840 --> 00:11:10,880
在这个学期结束前 我们全部都会学到

275
00:11:10,880 --> 00:11:14,320
但是 我们现在只需要一个标签 是吗

276
00:11:14,320 --> 00:11:17,110
标签是静态的 只读的文本字段

277
00:11:17,110 --> 00:11:19,440
如果你想要放一个标签到视图里面

278
00:11:19,440 --> 00:11:20,640
控制器视图里面

279
00:11:20,650 --> 00:11:24,340
你只要用鼠标选中拖拽就行了

280
00:11:24,340 --> 00:11:27,560
在拖曳的时候 它的颜色会变浅

281
00:11:27,560 --> 00:11:30,200
将它一直拖拽到我的视图里

282
00:11:30,200 --> 00:11:34,510
你可以看到这边蓝色的线

283
00:11:34,510 --> 00:11:36,370
可以帮助你对齐

284
00:11:36,370 --> 00:11:38,330
不要太靠近边缘

285
00:11:38,330 --> 00:11:40,920
或者 如果你想要将它放在中间之类的

286
00:11:40,920 --> 00:11:44,410
我们就利用蓝线将它放在这儿

287
00:11:44,410 --> 00:11:46,800
添加这个标签是个很好的开端

288
00:11:46,810 --> 00:11:49,590
但是对我来说它不太像是计算器

289
00:11:49,590 --> 00:11:52,190
所以我们还需要对它加工一下

290
00:11:52,190 --> 00:11:53,680
首先 标签太小了

291
00:11:53,680 --> 00:11:56,760
我们不想让它在左上角像这个样子

292
00:11:56,770 --> 00:11:59,170
你看到四周的控点了吗？

293
00:11:59,170 --> 00:12:03,200
我可以选中并移动它 调整标签大小

294
00:12:03,200 --> 00:12:05,010
我可以使用这些蓝线

295
00:12:05,010 --> 00:12:08,200
来把它调整到我要的大小

296
00:12:08,210 --> 00:12:11,060
差不多40像素高吧

297
00:12:11,060 --> 00:12:13,560
我们也不要它左对齐

298
00:12:13,560 --> 00:12:15,470
在你见过的任何计算器里

299
00:12:15,470 --> 00:12:16,860
数字都是右对齐的

300
00:12:16,860 --> 00:12:19,200
它们在屏幕的右边显示

301
00:12:19,200 --> 00:12:20,050
那么我们要怎么操作呢

302
00:12:20,050 --> 00:12:23,150
好的 现在我们看看右侧的检查器

303
00:12:23,150 --> 00:12:24,390
这个属性检查器

304
00:12:24,390 --> 00:12:26,550
可以看到我们可以设置的东西

305
00:12:26,550 --> 00:12:28,850
包括文本对齐方式

306
00:12:28,860 --> 00:12:31,080
点击右对齐

307
00:12:31,080 --> 00:12:33,010
这里还有字体设置

308
00:12:33,020 --> 00:12:34,550
我通过这个把字号放大一点

309
00:12:34,550 --> 00:12:37,590
大概24号 这样看得更清晰

310
00:12:37,600 --> 00:12:38,680
我当然不想

311
00:12:38,680 --> 00:12:40,680
在计算器里显示label这个词

312
00:12:40,680 --> 00:12:42,830
所以我可以直接双击它

313
00:12:42,830 --> 00:12:45,100
将其变为0这样就行了

314
00:12:45,100 --> 00:12:47,230
这可能是一个不错的初始值

315
00:12:47,230 --> 00:12:48,920
就像这样

316
00:12:48,920 --> 00:12:53,060
我有了一个文本标签 用于显示数字

317
00:12:53,060 --> 00:12:56,810
现在 我要使它能够起作用

318
00:12:56,810 --> 00:13:01,700
实际上 如果你们记得刚才的MVC图片

319
00:13:01,700 --> 00:13:04,090
这个绿色的输出是一个箭头

320
00:13:04,090 --> 00:13:07,170
表示控制器在向视图里的对象发送命令

321
00:13:07,170 --> 00:13:10,120
控制器定会向这个显示屏发送消息

322
00:13:10,120 --> 00:13:12,770
它需要告诉显示屏显示什么

323
00:13:12,770 --> 00:13:14,330
告知计算的结果

324
00:13:14,330 --> 00:13:15,750
你输入数字之后

325
00:13:15,750 --> 00:13:17,730
显示屏也要实时更新

326
00:13:17,730 --> 00:13:22,840
所以我们要创建一个从控制器到视图的输出

327
00:13:22,840 --> 00:13:24,710
现在我们开始操作

328
00:13:24,710 --> 00:13:29,330
实现这个不需要输入代码之类的东西

329
00:13:29,330 --> 00:13:31,030
用鼠标操作就可以

330
00:13:31,030 --> 00:13:33,250
这个用手指操作的技巧是

331
00:13:33,250 --> 00:13:35,520
按住键盘上的Control键

332
00:13:35,520 --> 00:13:37,030
不要忘记这样做噢

333
00:13:37,030 --> 00:13:38,230
按住Control键

334
00:13:38,240 --> 00:13:40,250
然后从显示屏

335
00:13:40,250 --> 00:13:46,020
拖拽一条线到你的代码区

336
00:13:46,020 --> 00:13:47,180
这看起来或许有点奇怪

337
00:13:47,180 --> 00:13:49,780
我将图形和代码混在一起用了

338
00:13:49,780 --> 00:13:52,000
但是如果你适应了的话 这真的很棒

339
00:13:52,000 --> 00:13:54,430
所以我们将它拖到这里 然后放开

340
00:13:54,430 --> 00:13:57,590
系统会提示你创建一个输出

341
00:13:57,600 --> 00:13:59,310
你看 这里的连接类型就是输出

342
00:13:59,310 --> 00:14:02,640
系统明白你要创建的是控制器的输出

343
00:14:02,640 --> 00:14:05,860
这里的类型是UILabel

344
00:14:05,860 --> 00:14:08,560
是指这是UILabel和控制器之间的连接

345
00:14:08,560 --> 00:14:11,020
这里的存储设置默认为强类型

346
00:14:11,020 --> 00:14:13,460
但实际上 我将要这个存储设置

347
00:14:13,460 --> 00:14:16,080
这就是我们说的属性

348
00:14:16,080 --> 00:14:17,770
我要将此存储 这个指针

349
00:14:17,770 --> 00:14:19,490
因为它是一个指向对象的指针

350
00:14:19,490 --> 00:14:21,370
指向UIlabel的指针 我将其设置成弱类型

351
00:14:21,370 --> 00:14:23,930
为什么我要在这里把它设置成弱类型呢

352
00:14:23,930 --> 00:14:27,390
因为这个标签已经有强指针指向它了

353
00:14:27,390 --> 00:14:29,450
因为它是在那个窗口里的

354
00:14:29,450 --> 00:14:35,590
那个窗口是该标签的父视图

355
00:14:35,590 --> 00:14:37,020
已经有一个指向标签的强指针了

356
00:14:37,020 --> 00:14:38,890
如果没有指向它的强指针

357
00:14:38,890 --> 00:14:41,130
我就不需要对显示屏进行修改了

358
00:14:41,130 --> 00:14:44,680
因为如果它在这个窗口内运行

359
00:14:44,680 --> 00:14:47,080
我就只需要弱指针指向它

360
00:14:47,080 --> 00:14:50,620
除非标签是在视图里面 否则我不需要它

361
00:14:50,620 --> 00:14:52,010
所以我将其设置成了弱类型

362
00:14:52,010 --> 00:14:53,850
通常我们将输出设置成弱类型

363
00:14:53,850 --> 00:14:55,510
几乎都是弱类型

364
00:14:55,520 --> 00:14:58,530
系统也想知道这个输出的名称

365
00:14:58,530 --> 00:15:00,230
由于它是计算器的显示屏

366
00:15:00,230 --> 00:15:02,270
我要将其称为display

367
00:15:02,270 --> 00:15:03,730
好的 点击连接

368
00:15:03,730 --> 00:15:06,520
你可以看到生成了属性

369
00:15:06,520 --> 00:15:11,610
希望 你们能认出上次讲的语法

370
00:15:11,610 --> 00:15:13,010
这就是属性

371
00:15:13,010 --> 00:15:15,380
它是弱类型 不是强类型

372
00:15:15,380 --> 00:15:16,490
非原子操作

373
00:15:16,490 --> 00:15:19,180
不是线程安全的 这里我们不管

374
00:15:19,180 --> 00:15:22,130
这边有个单词IBOutlet

375
00:15:22,130 --> 00:15:26,980
这个没什么用 只是在此处显示

376
00:15:26,980 --> 00:15:29,440
所以它能够跟踪哪些属性是输出

377
00:15:29,440 --> 00:15:32,410
这一部分我们不需要看它

378
00:15:32,410 --> 00:15:35,530
这只是输入没有什么用 不必要担心

379
00:15:35,530 --> 00:15:39,950
接下来是这个属性的类型 UILabel *对吧？

380
00:15:39,950 --> 00:15:41,430
指向UIlabel的指针

381
00:15:41,430 --> 00:15:43,070
这个名词说明了它是干什么的

382
00:15:43,070 --> 00:15:46,110
这是属性的名称display

383
00:15:46,120 --> 00:15:48,090
现在这儿很酷的东西是

384
00:15:48,090 --> 00:15:51,120
你注意到左边的圆圈了

385
00:15:51,120 --> 00:15:53,040
如果你把鼠标移到上面

386
00:15:53,040 --> 00:15:55,540
你不需要点击它 只要移到上面

387
00:15:55,540 --> 00:15:56,450
它就会显示

388
00:15:56,450 --> 00:16:01,250
这个display属性和什么连接在一起

389
00:16:01,250 --> 00:16:04,180
这真的很棒 如果你有很多属性

390
00:16:04,180 --> 00:16:07,410
能够清楚地看到什么和什么连接在一起

391
00:16:07,410 --> 00:16:10,880
好的 这是属性的声明

392
00:16:10,880 --> 00:16:13,830
我们来看看属性的实现文件

393
00:16:13,840 --> 00:16:16,160
为了实现这个目的 我们需要

394
00:16:16,160 --> 00:16:18,590
从CalculatorViewerControler.H

395
00:16:18,590 --> 00:16:20,240
切换到CalculatorViewerControler.M

396
00:16:20,240 --> 00:16:22,670
只需要转到顶部的查看器

397
00:16:22,670 --> 00:16:25,970
点击名称并切换到 .M

398
00:16:25,970 --> 00:16:29,780
我把这拉大一点

399
00:16:29,780 --> 00:16:32,080
你可以看到

400
00:16:32,080 --> 00:16:35,290
视图控制器的模板上有很多东西

401
00:16:35,290 --> 00:16:38,500
我们不需要这些东西 我们会删掉它们

402
00:16:38,510 --> 00:16:40,100
我们需要这个

403
00:16:40,100 --> 00:16:41,280
系统自动添加了

404
00:16:41,280 --> 00:16:45,570
属性的实现为合成display

405
00:16:45,570 --> 00:16:48,860
和我们要的不太一样 但是个不错的开始

406
00:16:48,860 --> 00:16:51,940
我要删掉文件里的其他东西

407
00:16:51,940 --> 00:16:54,340
因为第一个应用程序中

408
00:16:54,340 --> 00:16:58,210
我们不会用到这些东西 删除这些

409
00:16:58,210 --> 00:17:00,420
这个空间变大了

410
00:17:00,420 --> 00:17:04,450
现在很清晰了 Xcode还有什么没做呢

411
00:17:04,450 --> 00:17:07,670
它还没做我告诉你们要做的事情

412
00:17:07,670 --> 00:17:09,730
使用 = 符号

413
00:17:09,730 --> 00:17:12,930
为存储指针的实例变量

414
00:17:12,930 --> 00:17:14,820
指定一个名称

415
00:17:14,820 --> 00:17:18,230
这个名称不同于实例变量名称

416
00:17:18,230 --> 00:17:21,330
学生:(听不清)

417
00:17:21,330 --> 00:17:22,360
问题是

418
00:17:22,360 --> 00:17:24,890
我总是需要删掉模板上的东西吗

419
00:17:24,890 --> 00:17:25,780
这得看情况

420
00:17:25,780 --> 00:17:27,120
本季度课程的后期 你会找到答案

421
00:17:27,130 --> 00:17:28,890
你可能会用到其中的一些

422
00:17:28,890 --> 00:17:31,000
它并没有真正起到作用

423
00:17:31,000 --> 00:17:33,120
就像那些需要你填入内容的方法一样

424
00:17:33,120 --> 00:17:34,960
所以 这由你来决定了

425
00:17:34,960 --> 00:17:36,110
如果你想把它们留在那儿

426
00:17:36,110 --> 00:17:37,250
它也不会破坏什么

427
00:17:37,260 --> 00:17:39,590
它不会损害到什么 但是我只是想要清晰的代码

428
00:17:39,590 --> 00:17:42,300
让你们可以看清楚

429
00:17:42,300 --> 00:17:46,140
显示部分到目前进展得还不错

430
00:17:46,140 --> 00:17:48,740
现在我们的控制器

431
00:17:48,740 --> 00:17:51,910
已可随时与标签进行对话了

432
00:17:51,910 --> 00:17:55,670
要记得synthesize创建了setter和getter

433
00:17:55,670 --> 00:17:58,330
什么时候setter用于此属性

434
00:17:58,340 --> 00:18:00,740
什么时候getter用于此属性

435
00:18:00,740 --> 00:18:04,590
iOS会使用setter来设置指针

436
00:18:04,590 --> 00:18:06,630
当加载Storyboard时

437
00:18:06,630 --> 00:18:08,160
屏幕上会出现这个东西

438
00:18:08,160 --> 00:18:12,430
它会调用setter来创建与标签的连接

439
00:18:12,430 --> 00:18:15,090
我们将在代码中调用getter

440
00:18:15,100 --> 00:18:16,850
在我们要对标签对话时

441
00:18:16,850 --> 00:18:20,080
调用getter 会使指针指向它 并发送消息

442
00:18:20,090 --> 00:18:22,260
你们就可以看到了

443
00:18:22,260 --> 00:18:25,390
除了标签 用户界面里我们还需要什么呢

444
00:18:25,390 --> 00:18:28,780
我们还需要使用一些按钮

445
00:18:28,780 --> 00:18:29,900
比如 我们需要为计算器键盘

446
00:18:29,900 --> 00:18:31,320
设置一些按钮

447
00:18:31,320 --> 00:18:33,370
从0到9

448
00:18:33,370 --> 00:18:35,320
我们再回到刚才那儿

449
00:18:35,320 --> 00:18:40,000
回到对象面板 拖拽另一个标签

450
00:18:40,000 --> 00:18:43,840
这次我要拖拽这个圆角按钮

451
00:18:43,840 --> 00:18:46,020
我把它拖到这儿

452
00:18:46,020 --> 00:18:48,160
你们看到蓝色的线又出现了

453
00:18:48,160 --> 00:18:50,620
我们要对着蓝线放置

454
00:18:50,620 --> 00:18:53,760
把大小调到64像素宽

455
00:18:53,760 --> 00:18:56,690
这个尺寸挺不错的

456
00:18:56,690 --> 00:18:58,640
好了

457
00:18:58,640 --> 00:19:00,130
这就是数字键了

458
00:19:00,140 --> 00:19:02,440
这个大概是数字7按键

459
00:19:02,440 --> 00:19:05,800
在键盘的左上方 这儿

460
00:19:05,800 --> 00:19:09,590
现在我们要来讨论一下

461
00:19:09,590 --> 00:19:11,500
控制器和视图之间的另外一种连接

462
00:19:11,500 --> 00:19:13,120
那就是目标和动作连接

463
00:19:13,120 --> 00:19:15,920
我们需要在控制器上设置目标

464
00:19:15,920 --> 00:19:19,930
这样这些按钮才能向它发送动作

465
00:19:19,930 --> 00:19:24,110
完成某些操作 当用户

466
00:19:24,110 --> 00:19:28,870
抱歉 当用户触摸了这些按钮

467
00:19:28,870 --> 00:19:31,150
这个要怎么操作呢？与输出的操作一样

468
00:19:31,150 --> 00:19:33,310
按住control键

469
00:19:33,310 --> 00:19:36,270
拖拽 这次

470
00:19:36,270 --> 00:19:38,050
系统显示了实现文件中

471
00:19:38,050 --> 00:19:40,370
所有我们可能插入动作的地方

472
00:19:40,370 --> 00:19:41,730
我们放到这里

473
00:19:41,730 --> 00:19:44,830
注意到了吧 连接类型现在是动作

474
00:19:44,830 --> 00:19:47,360
我们现在不讲这里的这些选项

475
00:19:47,360 --> 00:19:49,290
但是我们需要给这个动作命名

476
00:19:49,290 --> 00:19:52,290
我要将其叫做digitPressed

477
00:19:52,290 --> 00:19:53,780
因为它就是这个作用

478
00:19:53,780 --> 00:19:57,850
就是触摸这个按钮和数字 数字按键

479
00:19:57,860 --> 00:20:01,490
点击连接 出现了这段代码

480
00:20:01,490 --> 00:20:05,220
我们来看看这个代码到底是什么

481
00:20:05,220 --> 00:20:08,720
这和周二课堂上

482
00:20:08,720 --> 00:20:10,870
讲过的信息声明相似

483
00:20:10,870 --> 00:20:14,200
此种返回类型 有点儿令人费解

484
00:20:14,200 --> 00:20:16,720
你或许会问 什么是IBAction

485
00:20:16,720 --> 00:20:20,710
实际上这是我们要void类型

486
00:20:20,710 --> 00:20:23,240
目标和动作不会返回任何值

487
00:20:23,240 --> 00:20:27,730
这是IBaction而不是void类型的原因

488
00:20:27,730 --> 00:20:30,250
和IBOutlet一样 只是放在那告诉Xcode

489
00:20:30,250 --> 00:20:33,900
噢 好的 这是一个动作或只是随机消息

490
00:20:33,900 --> 00:20:37,020
还带一些参数

491
00:20:37,020 --> 00:20:39,880
这是动作digitPressed的名称加冒号

492
00:20:39,880 --> 00:20:44,860
这是它的参数类型

493
00:20:44,860 --> 00:20:46,500
这个地方很重要

494
00:20:46,500 --> 00:20:49,700
当按下按钮时 目标动作消息

495
00:20:49,700 --> 00:20:54,250
会发送带参数的消息给控制器

496
00:20:54,250 --> 00:20:57,650
参数是给我们发送的消息的对象

497
00:20:57,650 --> 00:21:00,440
是发信方 在我们的例子中 就是按钮

498
00:21:00,440 --> 00:21:04,590
你可能会说 那里的id是什么啊

499
00:21:04,590 --> 00:21:10,010
在Objective C里 id是很重要的类型

500
00:21:10,010 --> 00:21:11,860
好的 类型

501
00:21:11,860 --> 00:21:16,560
本来是原始类型 但内置在了objective C里

502
00:21:16,560 --> 00:21:21,110
Id是指向对象的指针

503
00:21:21,110 --> 00:21:25,940
或者你可以让它指向未知类别的对象

504
00:21:25,940 --> 00:21:29,060
所以 任何对象都可以被传递

505
00:21:29,060 --> 00:21:32,170
这可能是一件好事

506
00:21:32,170 --> 00:21:34,260
这在你们下周的作业中将得到求证

507
00:21:34,270 --> 00:21:37,210
或者它也可能不是一件好事

508
00:21:37,210 --> 00:21:39,640
今天 我要把id放在这儿

509
00:21:39,640 --> 00:21:41,580
但是 我会改变它 你会看到

510
00:21:41,580 --> 00:21:44,900
它为什么可好可坏

511
00:21:44,900 --> 00:21:46,890
我需要更多这种键盘按钮

512
00:21:46,890 --> 00:21:48,790
实际上 我可以直接复制和粘贴

513
00:21:48,790 --> 00:21:53,170
复制和粘贴 复制和粘贴

514
00:21:53,170 --> 00:21:56,720
用蓝线对齐 我们可以一次复制三个

515
00:21:56,720 --> 00:22:01,200
粘贴三个 粘贴另外三个

516
00:22:01,210 --> 00:22:08,100
很快建好我的键盘 好的

517
00:22:08,100 --> 00:22:11,360
直接双击标题 就可以修改它们

518
00:22:11,360 --> 00:22:29,790
8 这是9 4 5 6 1 2 3和0 好了

519
00:22:29,790 --> 00:22:33,940
现在要注意的是

520
00:22:34,360 --> 00:22:35,920
值得注意的一件有趣的事是

521
00:22:35,920 --> 00:22:39,080
这里现在这些按键都发送

522
00:22:39,080 --> 00:22:41,680
相同的目标动作消息

523
00:22:41,680 --> 00:22:44,930
当你复制粘贴这些按钮的时候

524
00:22:44,930 --> 00:22:50,500
同样复制粘贴了它们的目标动作

525
00:22:50,500 --> 00:22:53,510
如果我将鼠标放在@property上

526
00:22:53,510 --> 00:22:57,790
记住我们看到的标签 我进入到实现文件

527
00:22:57,790 --> 00:23:03,270
把鼠标放在这儿 所有的按钮都发送同一条消息

528
00:23:03,270 --> 00:23:04,170
看明白了吗

529
00:23:04,170 --> 00:23:06,630
因为它们都是我复制和粘贴的

530
00:23:06,630 --> 00:23:09,230
当我们添加运算按钮和回车按钮时

531
00:23:09,230 --> 00:23:11,600
我们就不会去复制数字按钮

532
00:23:11,600 --> 00:23:12,500
否则我们就会发送数字消息

533
00:23:12,500 --> 00:23:15,150
一个按钮可以发送多种消息

534
00:23:15,150 --> 00:23:16,890
所以你当然不想让运算按钮同时

535
00:23:16,890 --> 00:23:20,120
发送digitPressed和operationPress

536
00:23:20,120 --> 00:23:21,810
好的 我们要小心

537
00:23:21,810 --> 00:23:23,330
不要通过复制粘贴数字按钮来

538
00:23:23,340 --> 00:23:25,660
制作运算按钮

539
00:23:25,660 --> 00:23:28,580
我们现在来编写digitPressed的实现部分

540
00:23:28,580 --> 00:23:31,580
我们要在这边创建一些objective C类型

541
00:23:31,580 --> 00:23:33,610
我要创建一个局部变量

542
00:23:33,610 --> 00:23:38,780
它是指向字符串对象的指针

543
00:23:38,780 --> 00:23:43,570
NSString*意思是指向NSString的指针

544
00:23:43,570 --> 00:23:46,420
digit是局部变量的名称

545
00:23:46,420 --> 00:23:49,520
很明显的参数有点儿像

546
00:23:49,520 --> 00:23:51,310
实现文件里的局部变量

547
00:23:51,310 --> 00:23:52,720
和其它语言一样

548
00:23:52,720 --> 00:23:54,110
所以 我们有名为sender的局部变量

549
00:23:54,110 --> 00:23:57,800
它是发送消息的对象

550
00:23:57,810 --> 00:24:00,240
现在 我要做的是获取数字

551
00:24:00,240 --> 00:24:02,260
我知道按了什么数字按键

552
00:24:02,260 --> 00:24:04,040
那样我就可以将消息发送回sender

553
00:24:04,040 --> 00:24:07,110
我要问当前按键的标题是什么

554
00:24:07,110 --> 00:24:09,320
这样我就知道按了什么按钮

555
00:24:09,320 --> 00:24:12,560
objective-C里 [ 表示发送消息

556
00:24:12,560 --> 00:24:14,960
sender是指向

557
00:24:14,960 --> 00:24:16,360
我要发送消息的对象的指针

558
00:24:16,360 --> 00:24:18,260
它是将这个消息发送给我的对象

559
00:24:18,260 --> 00:24:21,920
现在 我开始键入内容 看看会发生什么

560
00:24:21,920 --> 00:24:24,770
好的 我键入C U

561
00:24:24,770 --> 00:24:28,180
启动objective C和Xcode

562
00:24:28,180 --> 00:24:30,280
它向我显示了全部

563
00:24:30,290 --> 00:24:33,660
我知道的以CU开头的消息 相当多的

564
00:24:33,660 --> 00:24:36,810
但是大多数都不是按钮的消息

565
00:24:36,810 --> 00:24:39,700
我不会发送这样的消息 如currencySymbol

566
00:24:39,700 --> 00:24:42,010
那不是一个按钮消息

567
00:24:42,010 --> 00:24:47,400
或者currentRequest currentMinimumTrackImage

568
00:24:47,400 --> 00:24:49,730
这些不是用户界面的按钮消息

569
00:24:49,730 --> 00:24:52,220
所以 这里有很多没用的东西

570
00:24:52,220 --> 00:24:53,640
如果我键入其中的一个

571
00:24:53,640 --> 00:24:55,800
我不会得到一个错误结果 但做法有问题

572
00:24:55,800 --> 00:25:01,220
这就是id作为类型的一个问题

573
00:25:01,220 --> 00:25:03,490
我们知道

574
00:25:03,490 --> 00:25:06,380
只有按钮发送消息的时候 代码才起作用

575
00:25:06,380 --> 00:25:08,680
如果滑动条发送消息给我们 但是它不会起作用

576
00:25:08,680 --> 00:25:10,070
因为我们需要请求获取对象的标题

577
00:25:10,080 --> 00:25:11,670
而滑动条上面是没有标题的

578
00:25:11,670 --> 00:25:14,320
所以那样代码会崩溃 甚至使应用程序崩溃

579
00:25:14,320 --> 00:25:17,420
我可以将这儿的id变成

580
00:25:17,420 --> 00:25:20,420
UIButton* 指向按钮的指针

581
00:25:20,420 --> 00:25:23,870
这样操作后回到这儿 键入CU

582
00:25:23,870 --> 00:25:28,670
现在我只看到按钮响应的消息

583
00:25:28,670 --> 00:25:32,190
这5个 currentTitle currentImage等

584
00:25:32,190 --> 00:25:33,680
实际上 我可以选择其中一个

585
00:25:33,680 --> 00:25:35,300
比如我选择currentTitle

586
00:25:35,300 --> 00:25:36,450
然后使用Tab键

587
00:25:36,450 --> 00:25:37,550
使用Tab键

588
00:25:37,550 --> 00:25:41,800
补全输入

589
00:25:41,800 --> 00:25:43,760
然后以 ] 来结束这个部分

590
00:25:43,770 --> 00:25:47,120
所以 现在我获得了按钮的标题

591
00:25:47,120 --> 00:25:52,350
我将其复制到这个局部变量digit中

592
00:25:52,360 --> 00:25:55,140
我现在要做的是

593
00:25:55,140 --> 00:25:58,120
向你们迅速展示一个调试技巧

594
00:25:58,120 --> 00:26:02,190
我将输出 将这个digit发送到控制台

595
00:26:02,200 --> 00:26:05,450
因为这是一种很容易的调试方法

596
00:26:05,450 --> 00:26:09,820
大多数语言可以这样来调试

597
00:26:09,820 --> 00:26:11,920
这比设置布尔 断点

598
00:26:11,920 --> 00:26:13,640
设置和查看变量更容易一点儿

599
00:26:13,640 --> 00:26:15,090
使用此种方法你只需要打印

600
00:26:15,090 --> 00:26:16,400
我要来进行这样的操作了

601
00:26:16,400 --> 00:26:18,790
我们要用函数来实现

602
00:26:18,790 --> 00:26:19,590
它是函数 不是消息

603
00:26:19,600 --> 00:26:21,290
这个函数叫作NSLog

604
00:26:21,290 --> 00:26:23,660
这个NSLog就像是printf

605
00:26:23,660 --> 00:26:25,600
你们应该知道printf吧

606
00:26:25,600 --> 00:26:26,860
除此之外

607
00:26:26,860 --> 00:26:27,820
这里不用

608
00:26:27,820 --> 00:26:30,710
格式化的字符串const char * string

609
00:26:30,710 --> 00:26:32,570
我们用NSString

610
00:26:32,570 --> 00:26:38,600
指定常量NSString的方法是使用@"

611
00:26:38,600 --> 00:26:42,620
@"是一个常量NSString

612
00:26:42,630 --> 00:26:46,760
我们可以向其中添加内容 比如digitPressed =

613
00:26:46,760 --> 00:26:49,350
然后输入一个百分比格式

614
00:26:49,350 --> 00:26:52,890
如整数用%d 浮点数值用%g

615
00:26:52,890 --> 00:26:55,170
我们不用%s

616
00:26:55,180 --> 00:26:58,040
因为它是const char * 或 char

617
00:26:58,040 --> 00:27:02,550
但是我们使用一个非常特别的符号%@

618
00:27:02,550 --> 00:27:04,840
%@符号意思是

619
00:27:04,840 --> 00:27:08,660
显示输出的内容的类型是一个对象

620
00:27:08,660 --> 00:27:11,520
NSLog会用来做什么呢

621
00:27:11,520 --> 00:27:14,640
它将用于发送消息描述 非常特殊的消息

622
00:27:14,640 --> 00:27:16,650
它发送消息描述给那个对象

623
00:27:16,650 --> 00:27:19,650
该描述消息会返回一个NSString

624
00:27:19,650 --> 00:27:21,190
并使用该NSString

625
00:27:21,190 --> 00:27:25,950
来显示这个特定的%@符号

626
00:27:25,950 --> 00:27:30,930
现在NSString自身从描述消息中返回了

627
00:27:30,930 --> 00:27:33,360
大家都看懂了吗 为什么这么做呢

628
00:27:33,360 --> 00:27:35,630
因为它本身就要返回一个字符串来描述自己

629
00:27:35,630 --> 00:27:37,590
它就是字符串 所以它自己返回了

630
00:27:37,590 --> 00:27:40,270
所以在这里我们可以输入digit

631
00:27:40,270 --> 00:27:43,430
我们可获得digit中的字符串

632
00:27:43,430 --> 00:27:44,470
也就是该按钮的currentTitle

633
00:27:44,470 --> 00:27:46,990
所以 我们第一次运行这个程序

634
00:27:46,990 --> 00:27:50,710
看看它是否可以运行 想要运行程序

635
00:27:50,710 --> 00:27:53,680
将鼠标移到左上角的运行按钮

636
00:27:53,690 --> 00:27:56,460
它看起来像播放按钮 我们点击运行

637
00:27:56,460 --> 00:27:58,420
这是我们第一次运行该程序

638
00:27:58,420 --> 00:28:02,240
所以它需要预编译一些头文件

639
00:28:02,240 --> 00:28:04,800
并载入框架等内容

640
00:28:04,800 --> 00:28:07,640
你可以在上面看到 它会显示什么正在运行

641
00:28:07,640 --> 00:28:11,780
现在正在编译其中一个前缀头文件

642
00:28:11,780 --> 00:28:16,830
Xcode非常擅长预编译和缓存信息

643
00:28:16,830 --> 00:28:18,640
你第二次这样操作的时候

644
00:28:18,640 --> 00:28:20,910
它会变得快多了

645
00:28:20,910 --> 00:28:25,330
现在是链接 现在正在复制storyboard

646
00:28:25,330 --> 00:28:27,290
和其他图像等资源

647
00:28:27,290 --> 00:28:30,940
编译成功 我们现在来运行这个

648
00:28:30,940 --> 00:28:32,470
你可以在设备上运行这个

649
00:28:32,470 --> 00:28:33,400
如果你看看这个

650
00:28:33,400 --> 00:28:36,600
你看看上面的计算器iPhone模拟器5.0

651
00:28:36,600 --> 00:28:40,390
前四五个作业

652
00:28:40,390 --> 00:28:43,190
你们可以在模拟器上运行

653
00:28:43,190 --> 00:28:44,430
没问题

654
00:28:44,430 --> 00:28:47,730
你也可以从顶部选择在设备上运行

655
00:28:47,730 --> 00:28:49,110
但是如果你要在设备上运行

656
00:28:49,120 --> 00:28:52,960
你需要加入开发者计划

657
00:28:52,960 --> 00:28:56,560
如苹果开发者计划或大学开发者计划

658
00:28:56,560 --> 00:29:02,130
所以 我要返回到非全屏模式

659
00:29:02,130 --> 00:29:04,920
因此我们可以在屏幕上

660
00:29:04,920 --> 00:29:11,070
同时看到代码和模拟器

661
00:29:13,260 --> 00:29:22,080
对啦 这就是我们的模拟器

662
00:29:22,080 --> 00:29:25,300
这个模拟器 你知道的

663
00:29:25,300 --> 00:29:27,920
在模拟器里运行程序

664
00:29:27,930 --> 00:29:29,400
与在实际设备上运行并不完全一样

665
00:29:29,410 --> 00:29:32,970
但是非常接近 这就是那个模拟器

666
00:29:32,970 --> 00:29:36,720
它将载入storyboard

667
00:29:36,720 --> 00:29:40,110
并运行应用程序

668
00:29:40,110 --> 00:29:42,400
现在 在我们按模拟器中的

669
00:29:42,400 --> 00:29:44,500
任何按键之前

670
00:29:44,500 --> 00:29:46,470
我要给你看控制台

671
00:29:46,470 --> 00:29:47,610
因为我们要做的

672
00:29:47,610 --> 00:29:48,960
就是在这儿获得NSLog

673
00:29:48,960 --> 00:29:50,290
输出到控制台上

674
00:29:50,290 --> 00:29:51,180
控制台在哪

675
00:29:51,180 --> 00:29:54,790
你看看屏幕最底下

676
00:29:54,790 --> 00:29:58,160
下面这一栏

677
00:29:58,160 --> 00:29:59,990
是调试器和控制台的组合体

678
00:29:59,990 --> 00:30:02,430
当你运行程序时 它就出现

679
00:30:02,430 --> 00:30:04,390
停止运行时 它也就消失了

680
00:30:04,390 --> 00:30:06,180
如果你想要看到更多信息

681
00:30:06,180 --> 00:30:08,890
可以使用这边的这个小按钮

682
00:30:08,890 --> 00:30:11,640
好了 你也可以用左下角的小按钮

683
00:30:11,640 --> 00:30:13,030
我们用上面的这个按钮

684
00:30:13,030 --> 00:30:16,330
我们点击这个按键的时候 它就出现了

685
00:30:16,330 --> 00:30:19,670
这里显示调试器的所有变量

686
00:30:19,670 --> 00:30:22,050
我们程序中指局部变量 没有

687
00:30:22,060 --> 00:30:23,580
你可以用这边的这个小按钮

688
00:30:23,580 --> 00:30:26,020
来显示变量和控制台

689
00:30:26,020 --> 00:30:27,640
就是这样 你可以移动这个

690
00:30:27,650 --> 00:30:29,280
或者你可只显示控制台

691
00:30:29,280 --> 00:30:31,050
就像这样 这就是控制台

692
00:30:31,050 --> 00:30:32,750
控制台上什么都没有

693
00:30:32,750 --> 00:30:35,450
你生成的编程会在控制台里用粗体显示

694
00:30:35,450 --> 00:30:37,520
我们继续 看这个模拟程序

695
00:30:37,520 --> 00:30:38,700
在这儿点击一些按钮

696
00:30:38,700 --> 00:30:40,340
看看控制台里会有什么变化

697
00:30:40,340 --> 00:30:41,310
我们试一下按5

698
00:30:41,310 --> 00:30:43,720
可以看到digit pressed等于5

699
00:30:43,720 --> 00:30:44,880
每次输出

700
00:30:44,880 --> 00:30:46,020
每个日志时间都会出现在此处

701
00:30:46,020 --> 00:30:48,860
这里以毫秒为单位的时间

702
00:30:48,860 --> 00:30:51,570
因此你可以在这里看到发生了什么

703
00:30:51,570 --> 00:30:52,290
我们目前进展顺利

704
00:30:52,300 --> 00:30:56,290
我们运行了第一个应用程序 非常简单 非常直观

705
00:30:56,290 --> 00:30:57,760
好了 我们停下来

706
00:30:57,760 --> 00:31:00,750
回到全屏模式

707
00:31:00,750 --> 00:31:03,420
现在 我们要将这个NSLog去掉

708
00:31:03,420 --> 00:31:06,620
输入数字按键的实际实现代码

709
00:31:06,620 --> 00:31:09,390
现在 我要...... 我们的时间有点不够了

710
00:31:09,390 --> 00:31:10,860
所以我要讲得非常快了

711
00:31:10,860 --> 00:31:12,910
我们的数字按键所需要的

712
00:31:12,910 --> 00:31:14,640
只是一行代码

713
00:31:14,640 --> 00:31:16,810
但是我要把它分成两行或三行

714
00:31:16,820 --> 00:31:19,130
然后合并起来 看看会发生什么

715
00:31:19,130 --> 00:31:24,250
首先 我要创建一个局部变量UILabel

716
00:31:24,260 --> 00:31:25,810
命名为myLabel

717
00:31:25,810 --> 00:31:29,840
或者叫做myDisplay可能会更好一点

718
00:31:29,840 --> 00:31:33,680
得到值并赋给指针的方法是

719
00:31:33,680 --> 00:31:41,220
我要把getter发送到输出

720
00:31:41,220 --> 00:31:42,860
好了 我们有label对应的输出

721
00:31:42,860 --> 00:31:44,740
我把这个getter消息发送给self

722
00:31:44,740 --> 00:31:46,770
这就是我们得到label的方法

723
00:31:46,770 --> 00:31:48,550
并能够发送消息给它

724
00:31:48,560 --> 00:31:51,990
我不需要在这儿创建一个局部变量

725
00:31:51,990 --> 00:31:53,330
再把它放进去 但是我想给你们看看

726
00:31:53,340 --> 00:31:54,790
调用getter会出现什么样的情况

727
00:31:54,790 --> 00:31:58,170
实际上 我告诉过你们有一种特别的语法

728
00:31:58,170 --> 00:32:00,280
是用来调用getter的 那个点标记法

729
00:32:00,280 --> 00:32:01,960
记得吗 在上次课的结尾时说的

730
00:32:01,960 --> 00:32:04,570
好了 使用点标记法 就像这样

731
00:32:04,570 --> 00:32:07,910
好 所以self.display 实际上是一样的

732
00:32:07,910 --> 00:32:10,980
它与[self display]一样 调用getter

733
00:32:10,980 --> 00:32:13,490
获得指向UILabel的指针

734
00:32:13,490 --> 00:32:16,210
现在我们有指向UILabel的指针

735
00:32:16,210 --> 00:32:17,990
我要把其中的文本读出来

736
00:32:18,000 --> 00:32:21,710
因为当我们按数字按钮如5 6 8 9时

737
00:32:21,710 --> 00:32:24,570
我们真正要的是把这些数字附在

738
00:32:24,570 --> 00:32:25,960
已在显示器里显示的数的后面

739
00:32:25,960 --> 00:32:29,410
如我当前已在显示器里输入56了 然后输入2

740
00:32:29,410 --> 00:32:31,280
我想让它变成562

741
00:32:31,280 --> 00:32:32,830
所以 我要把文本读出来

742
00:32:32,840 --> 00:32:36,110
附上这些刚输入的数字 然后返回去

743
00:32:36,110 --> 00:32:38,690
就是这样了 这就是这个消息要做的

744
00:32:38,690 --> 00:32:42,560
好了 我们再添加一个局部变量NSString

745
00:32:42,560 --> 00:32:46,520
就把它叫做currentText

746
00:32:46,520 --> 00:32:48,290
好了 为了获取当前文本

747
00:32:48,290 --> 00:32:51,070
我要发送消息到myDisplay

748
00:32:51,070 --> 00:32:52,650
获取文本

749
00:32:52,650 --> 00:32:57,390
文本是能够被UILabel理解的消息

750
00:32:57,390 --> 00:33:00,120
它说把你带的文本传给我

751
00:33:00,130 --> 00:33:02,140
我们现在可以

752
00:33:02,140 --> 00:33:04,160
说点题外话

753
00:33:04,160 --> 00:33:05,560
来说说文档资料

754
00:33:05,570 --> 00:33:09,480
文档资料很容易使用

755
00:33:09,480 --> 00:33:12,210
起作用的就是这个option键

756
00:33:12,210 --> 00:33:14,250
我按住option键

757
00:33:14,250 --> 00:33:16,160
我这样做的时候 你如果注意到了

758
00:33:16,160 --> 00:33:17,750
我把鼠标移过这个信息

759
00:33:17,750 --> 00:33:19,120
看看发生了什么

760
00:33:19,120 --> 00:33:20,180
它们变成了链接

761
00:33:20,180 --> 00:33:22,480
看看这些链接 我不知道你们

762
00:33:22,480 --> 00:33:23,210
能不能看清那些链接

763
00:33:23,210 --> 00:33:25,190
它们变成蓝色的有下划线

764
00:33:25,190 --> 00:33:27,930
如果我点击 比如说text

765
00:33:27,930 --> 00:33:30,010
就会有个小窗口弹出来

766
00:33:30,010 --> 00:33:34,710
窗口里有相关内容的快速帮助

767
00:33:34,710 --> 00:33:35,960
这就是text

768
00:33:35,960 --> 00:33:38,120
注意这个属性

769
00:33:38,120 --> 00:33:40,640
这实际就是属性的getter

770
00:33:40,640 --> 00:33:42,780
我们可能在这儿使用点标记法

771
00:33:42,780 --> 00:33:43,800
一会儿就用得到

772
00:33:43,800 --> 00:33:46,320
但是 同时要注意在快速帮助里面的一切

773
00:33:46,320 --> 00:33:49,350
它的描述 也是链接

774
00:33:49,360 --> 00:33:52,770
所以 如果我想找到更多的NSString类信息

775
00:33:52,770 --> 00:33:54,320
我只要在这儿点击一下

776
00:33:54,320 --> 00:33:56,810
现在 你可以看到完整的文档资料

777
00:33:56,810 --> 00:33:58,350
好了 现在正在加载

778
00:33:58,350 --> 00:34:00,770
所有关于NSString的文档资料

779
00:34:00,770 --> 00:34:05,460
全部的类参考说明 真是棒极了

780
00:34:05,460 --> 00:34:08,470
这真的需要你花时间好好研究一下这个向导

781
00:34:08,480 --> 00:34:11,500
这就是NSString

782
00:34:11,500 --> 00:34:13,860
它告诉你NSString的超类是什么

783
00:34:13,860 --> 00:34:16,000
展示了很多样本代码

784
00:34:16,000 --> 00:34:19,280
这些都是非常棒的 并且提供了多种相关指南

785
00:34:19,280 --> 00:34:22,190
如字符串编程指南 如何编写字符串

786
00:34:22,190 --> 00:34:24,250
这里是对类的概述

787
00:34:24,250 --> 00:34:28,480
这是所以NSString执行的方法 有很多

788
00:34:28,480 --> 00:34:31,570
好的 NSString的很多很棒的方法

789
00:34:31,570 --> 00:34:34,500
如果你对这些研究熟悉了的话

790
00:34:34,500 --> 00:34:36,800
你可以少写很多行代码

791
00:34:36,800 --> 00:34:38,790
因为NSString会为你做这些事情

792
00:34:38,790 --> 00:34:42,400
而且还是挺多的 每个方法都有

793
00:34:42,400 --> 00:34:46,600
非常详细的说明 比如返回值

794
00:34:46,600 --> 00:34:48,630
路径等之类的东西

795
00:34:48,630 --> 00:34:52,520
很显然 你可以搜索这些文档资料

796
00:34:52,520 --> 00:34:54,150
利用这些文档资料

797
00:34:54,150 --> 00:34:55,510
它们绝对是很有用的

798
00:34:55,510 --> 00:34:57,540
你们学习iOS5的时候

799
00:34:57,540 --> 00:35:00,050
很应该在这上面多花些时间

800
00:35:00,060 --> 00:35:03,210
我们再次注意到这是属性

801
00:35:03,220 --> 00:35:05,990
我也要把这变成点标记法

802
00:35:05,990 --> 00:35:10,370
myDisplay.text 好了

803
00:35:10,370 --> 00:35:12,350
现在我

804
00:35:12,350 --> 00:35:13,510
注意到我并不需要

805
00:35:13,510 --> 00:35:16,600
这儿的局部变量

806
00:35:16,610 --> 00:35:20,020
好的 我们再写一行 然后去掉那个

807
00:35:20,020 --> 00:35:21,390
现在我们有了这个文本

808
00:35:21,390 --> 00:35:23,160
我现在需要一个新的字符串

809
00:35:23,160 --> 00:35:26,780
这个字符串是当前显示屏里面的数字

810
00:35:26,780 --> 00:35:27,670
末尾加上新输入的数字

811
00:35:27,670 --> 00:35:32,940
所以我输入NSString *newText 使它简短一些

812
00:35:32,940 --> 00:35:36,040
我要用一个方法来做这个

813
00:35:36,040 --> 00:35:39,090
用字符串对象的append string方法

814
00:35:39,090 --> 00:35:39,820
所以 看一下这里

815
00:35:39,820 --> 00:35:46,000
currentText stringByAppendingString: digit

816
00:35:46,000 --> 00:35:49,170
好的 这个stringByAppendingString

817
00:35:49,170 --> 00:35:50,810
是字符串的一个方法

818
00:35:50,810 --> 00:35:52,160
你用另一个字符串作为参数

819
00:35:52,160 --> 00:35:53,650
将其发送到这个字符串

820
00:35:53,650 --> 00:35:57,770
会自动将字符串附加到末尾再返回给你

821
00:35:57,780 --> 00:35:59,660
好的 这就是我们需要的

822
00:35:59,660 --> 00:36:01,210
现在我们知道了newText的值

823
00:36:01,210 --> 00:36:09,610
我们可以用setText将mydisplay赋值为newText

824
00:36:09,610 --> 00:36:12,370
这个setText方法是什么呢

825
00:36:12,370 --> 00:36:17,570
这是setter 这是getter

826
00:36:17,570 --> 00:36:19,940
你看到我这里用了myDisplay.text

827
00:36:19,950 --> 00:36:21,770
这里用的是myDisplay setText

828
00:36:21,770 --> 00:36:23,800
我在这儿使用的是点标记法

829
00:36:23,800 --> 00:36:26,730
同样在这儿也用点标记法

830
00:36:26,730 --> 00:36:29,370
这就是setter的点标记法

831
00:36:29,370 --> 00:36:35,920
所以这里可以写成myDisplay.text=newText

832
00:36:35,920 --> 00:36:38,980
你可以看到在setter和getter中

833
00:36:38,990 --> 00:36:41,510
点标记法的用法是完全一样的

834
00:36:41,510 --> 00:36:43,950
区别只在于调用出现在等号的哪一边

835
00:36:43,950 --> 00:36:45,520
这就是唯一的不同点

836
00:36:45,520 --> 00:36:48,610
好了 现在 我们不要这一大堆的代码

837
00:36:48,610 --> 00:36:52,360
比如 myDisplay 我们不需要这个局部变量

838
00:36:52,360 --> 00:36:55,430
我们只需要复制这一小部分 就是myDisplay的值

839
00:36:55,440 --> 00:36:56,730
替换原来的myDisplay

840
00:36:56,730 --> 00:36:58,280
这儿和这儿

841
00:36:58,280 --> 00:36:59,620
现在 你或许有点慌了

842
00:36:59,620 --> 00:37:01,680
你说 哇哦 两个点啊

843
00:37:01,680 --> 00:37:03,800
但这是非常正确 而且常见的

844
00:37:03,800 --> 00:37:07,310
一排里面有两个 三个或四个点

845
00:37:07,310 --> 00:37:08,810
访问一个属性

846
00:37:08,810 --> 00:37:10,060
然后访问属性的属性

847
00:37:10,060 --> 00:37:10,800
然后是那个属性的属性

848
00:37:10,800 --> 00:37:13,980
完全没问题 所以我们不需要这个了

849
00:37:13,980 --> 00:37:17,110
还有 我们也不需要newText这个局部变量

850
00:37:17,110 --> 00:37:21,630
我们只要将它的内容拿来放在这里

851
00:37:22,020 --> 00:37:27,220
删掉这行 我们也不需要这个currentText

852
00:37:27,220 --> 00:37:32,920
我们只要将这个粘贴到这 然后删除这个

853
00:37:32,920 --> 00:37:35,720
我说了只需要一行代码  现在就是了

854
00:37:35,720 --> 00:37:37,240
你看到这个点标记法如何与

855
00:37:37,240 --> 00:37:40,680
Objective-C中带关键词的参数

856
00:37:40,680 --> 00:37:43,410
一起使用的

857
00:37:43,420 --> 00:37:46,570
这看起来有点像伪英语

858
00:37:46,570 --> 00:37:53,110
就像是说我的显示屏上的文字等于

859
00:37:53,110 --> 00:37:56,260
我显示屏上的文字末尾加上这个数字

860
00:37:56,260 --> 00:37:58,840
有点像可以直接读出来

861
00:37:58,840 --> 00:38:03,750
你知道Objective-C努力让自己的语法可读

862
00:38:03,750 --> 00:38:06,700
对于任何好的代码 可读性都是很重要的

863
00:38:06,700 --> 00:38:09,850
可读性高的自文档化代码非常重要

864
00:38:09,850 --> 00:38:11,270
这就是按下数字键

865
00:38:11,270 --> 00:38:12,250
需要进行的操作

866
00:38:12,250 --> 00:38:17,300
所以 我们再来运行一下 看看效果如何

867
00:38:21,860 --> 00:38:24,860
我们试试按5 8

868
00:38:24,860 --> 00:38:26,790
噢 看起来运行没问题

869
00:38:26,790 --> 00:38:28,760
但是我不喜欢开头的这个0

870
00:38:28,760 --> 00:38:29,860
看到开头的0了吗

871
00:38:29,860 --> 00:38:31,600
看起来有点儿不舒服

872
00:38:31,600 --> 00:38:32,640
为什么会这样呢

873
00:38:32,640 --> 00:38:35,220
这是因为我们真正想要执行

874
00:38:35,220 --> 00:38:36,700
末尾添加数字这个操作

875
00:38:36,710 --> 00:38:39,250
是在我们输入数字的时候

876
00:38:39,250 --> 00:38:40,590
如果我们正在输入数字

877
00:38:40,590 --> 00:38:41,450
输入的数字应该添加在原有数字末尾

878
00:38:41,450 --> 00:38:42,720
但是如果我们不在输入数字的过程中

879
00:38:42,730 --> 00:38:44,050
我们就要以一个新的数字开始

880
00:38:44,050 --> 00:38:48,550
所以 我们来进行这个操作 停止

881
00:38:48,550 --> 00:38:51,260
现在我们需要一些专用数据

882
00:38:51,260 --> 00:38:53,790
用来跟踪

883
00:38:53,790 --> 00:38:55,460
我们是否正在输入数字

884
00:38:55,460 --> 00:38:57,640
记不记得我跟你们说过

885
00:38:57,640 --> 00:39:02,150
可以用@interface来添加专有属性

886
00:39:02,150 --> 00:39:05,210
类名

887
00:39:05,210 --> 00:39:06,960
calculatorViewController

888
00:39:06,960 --> 00:39:09,880
然后加两个圆括号 对吧

889
00:39:09,880 --> 00:39:13,480
所以 这里用来创建专有接口

890
00:39:13,480 --> 00:39:16,550
接下来我要创建一个属性 非原子操作

891
00:39:16,560 --> 00:39:18,580
类型是BOOL

892
00:39:18,580 --> 00:39:20,870
这是Objective-C里面的布尔类型

893
00:39:20,870 --> 00:39:23,370
它的值为yes或者no

894
00:39:23,370 --> 00:39:25,500
no的话就是0 yes的话除了0什么都可以

895
00:39:25,500 --> 00:39:29,680
大写字母Y E S 或者N O 都可以

896
00:39:29,680 --> 00:39:31,360
这个变量的名为

897
00:39:31,360 --> 00:39:37,190
userIsInTheMiddleOfEnteringANumber

898
00:39:37,190 --> 00:39:39,920
你们都笑了 可以理解

899
00:39:39,920 --> 00:39:43,960
但是有这样长的变量名称真的很不错

900
00:39:43,960 --> 00:39:44,490
你会明白为什么要这么说

901
00:39:44,490 --> 00:39:46,380
因为只要我输入过一次

902
00:39:46,380 --> 00:39:48,260
现在我们来写synthesize

903
00:39:48,260 --> 00:39:50,790
synthesize user我只需要

904
00:39:50,790 --> 00:39:52,710
输入前三个符号 点击Tab

905
00:39:52,710 --> 00:39:55,640
等于号 下划线 user 按下Tab

906
00:39:55,640 --> 00:40:00,140
好了 我很快地输入了这个名称

907
00:40:00,140 --> 00:40:02,450
不需要打很多字

908
00:40:02,450 --> 00:40:03,790
现在 我们如何使用它呢？

909
00:40:03,790 --> 00:40:06,430
这个userIsInTheMiddleOfEnteringANumber

910
00:40:06,430 --> 00:40:09,290
好的 我们只要在这行

911
00:40:09,300 --> 00:40:11,160
Self.display.text这里

912
00:40:11,160 --> 00:40:15,240
if self. userIsInTheMiddleOfEnteringANumber

913
00:40:15,240 --> 00:40:18,530
好的 它为yes这里才会继续

914
00:40:18,530 --> 00:40:21,500
抱歉 字大了显示得不全

915
00:40:21,500 --> 00:40:25,500
否则的话 我们只要

916
00:40:25,500 --> 00:40:28,540
将display的text值设置为digits数值

917
00:40:28,540 --> 00:40:29,900
重新开始一个新的数字

918
00:40:29,900 --> 00:40:31,620
当然 如果我们开始新的数字

919
00:40:31,620 --> 00:40:32,570
那么我们就一定是在

920
00:40:32,570 --> 00:40:34,090
输入数字了

921
00:40:34,100 --> 00:40:38,330
好 我们设置userIsInTheMiddleOfEnteringANumber=YES

922
00:40:38,330 --> 00:40:43,540
我们还需要一些用户界面元素

923
00:40:43,540 --> 00:40:45,550
我们需要运算符按钮

924
00:40:45,550 --> 00:40:49,260
所以 我们快速设置一下

925
00:40:49,260 --> 00:40:52,210
这上面 这儿

926
00:40:52,210 --> 00:40:53,220
直接拖出新的一个

927
00:40:53,220 --> 00:40:56,650
因为我不想复制粘贴同样的目标动作

928
00:40:56,650 --> 00:40:58,550
我再次按住control键

929
00:40:58,550 --> 00:41:01,720
拖出来 就是这样 插入一个新的动作

930
00:41:01,720 --> 00:41:04,300
我将它称之为operationPressed

931
00:41:04,300 --> 00:41:06,300
这个按键也需要一个发送器

932
00:41:06,300 --> 00:41:10,190
因为我们需要知道要执行哪种运算

933
00:41:10,190 --> 00:41:16,070
我复制粘贴这个 做四个这样的按钮

934
00:41:16,070 --> 00:41:17,820
我们还需要一个Enter键

935
00:41:17,820 --> 00:41:19,100
我要重新拖出一个按钮

936
00:41:19,100 --> 00:41:22,050
因为我不想让它发送数字或是运算按钮的消息

937
00:41:22,050 --> 00:41:26,010
好的 Enter按钮放在这里

938
00:41:26,010 --> 00:41:34,800
/ + - 好了

939
00:41:34,800 --> 00:41:37,660
这样我们就能够知道我们在进行什么运算

940
00:41:37,660 --> 00:41:40,670
所以 我要把Enter拖出来 放在这儿

941
00:41:40,670 --> 00:41:43,350
我跟你们说过要讲讲下面的这些东西

942
00:41:43,350 --> 00:41:45,440
实际上 我只讲一个 就是这个参数arguments

943
00:41:45,440 --> 00:41:48,170
你注意到 我们的目标动作的arguments

944
00:41:48,170 --> 00:41:49,220
总是发送方sender

945
00:41:49,220 --> 00:41:52,070
但实际上有可能是发送和触控事件

946
00:41:52,080 --> 00:41:55,070
动作可能被发送 或者什么也不发送

947
00:41:55,070 --> 00:41:56,470
这就是我希望Enter做的

948
00:41:56,470 --> 00:41:58,570
因为只有一个Enter键

949
00:41:58,570 --> 00:42:00,640
我不需要发送器来告诉我们发生了什么

950
00:42:00,640 --> 00:42:02,810
然后 我们将它命名为EnterPressed

951
00:42:02,810 --> 00:42:05,770
你可以看到没有任何发送参数

952
00:42:05,770 --> 00:42:08,600
你看 就像那样 好的

953
00:42:08,600 --> 00:42:13,320
所以 我们要实现enterPressed和operationPressed

954
00:42:13,320 --> 00:42:15,670
但是 实际上 我们现在还不能那样做

955
00:42:15,670 --> 00:42:16,960
在继续后面操作之前

956
00:42:16,960 --> 00:42:17,900
我们来暂停一下

957
00:42:17,910 --> 00:42:19,160
确保我们的判断用户是否正在输入数字

958
00:42:19,160 --> 00:42:21,040
能够正常运行

959
00:42:21,040 --> 00:42:23,280
所以 这是0 我们按5

960
00:42:23,280 --> 00:42:25,470
重新开始了一个新的数字

961
00:42:25,470 --> 00:42:26,690
真是太好了 它起作用了

962
00:42:26,690 --> 00:42:31,150
如果连续按下两个0会怎样

963
00:42:31,150 --> 00:42:34,480
就像按其他数字一样

964
00:42:34,480 --> 00:42:35,940
但是 你以0开始的话

965
00:42:35,940 --> 00:42:37,700
它们会开始 按0

966
00:42:37,700 --> 00:42:39,700
你开始按0 再按0

967
00:42:39,700 --> 00:42:40,840
会在末尾再加一个0

968
00:42:40,840 --> 00:42:42,290
0和其他数字没有什么不同

969
00:42:42,290 --> 00:42:45,280
如果你认为应该处理一下

970
00:42:45,280 --> 00:42:47,470
防止数字以0开头

971
00:42:47,470 --> 00:42:48,660
这还是取决于你

972
00:42:48,670 --> 00:42:50,200
这是一个非常简单的计算器

973
00:42:50,200 --> 00:42:52,110
我们不可能去做很多极端情况的运算

974
00:42:52,110 --> 00:42:56,070
好的 我们只要做一般运算  后面同学

975
00:42:56,070 --> 00:43:00,290
学生:(听不清)

976
00:43:00,290 --> 00:43:01,120
这个问题很好

977
00:43:01,120 --> 00:43:02,560
他问这个地方

978
00:43:02,560 --> 00:43:05,350
我写了digit=sender currentTitle

979
00:43:05,350 --> 00:43:08,200
那是在复制NSString吗

980
00:43:08,200 --> 00:43:11,460
还是指向NSString的一个指针呢

981
00:43:11,460 --> 00:43:14,160
好的 这就取决于属性是如何声明的了

982
00:43:14,170 --> 00:43:18,200
其实复制也有强弱类型之分

983
00:43:18,200 --> 00:43:19,950
基本上来说 复制是强类型的

984
00:43:19,950 --> 00:43:23,180
除非你使用了一个强类型的指针来复制它

985
00:43:23,180 --> 00:43:25,070
你们查查文档

986
00:43:25,070 --> 00:43:26,530
我认为currentTitle可能用了复制

987
00:43:26,530 --> 00:43:29,110
但是这取决于它的属性

988
00:43:29,110 --> 00:43:31,900
其他问题 这边后面的同学

989
00:43:31,910 --> 00:43:34,450
学生:(这些地方都可以用点标记法吗)

990
00:43:34,450 --> 00:43:35,650
是的 当然 很好的问题

991
00:43:35,650 --> 00:43:38,900
就像currentTitle也是按钮的一个属性

992
00:43:38,910 --> 00:43:42,240
所以我们在这儿可以用sender.currentTitle

993
00:43:42,240 --> 00:43:44,310
是的 我们可以这样做 我们也应该这样

994
00:43:44,310 --> 00:43:45,430
不仅仅是可以 应该说是我们应该

995
00:43:45,430 --> 00:43:47,360
还有其他问题吗

996
00:43:47,360 --> 00:43:52,210
所以 现在我们需要建模型了 请说

997
00:43:52,210 --> 00:43:54,270
学生:这些按钮都是拖进来的

998
00:43:54,280 --> 00:43:56,270
学生:有其它方法实现吗

999
00:43:57,990 --> 00:43:59,030
你是说用代码吗

1000
00:43:59,030 --> 00:44:00,180
所以 你的问题是

1001
00:44:00,180 --> 00:44:01,970
除了图形化方法

1002
00:44:01,970 --> 00:44:03,300
有没有其他方法添加按钮这些东西

1003
00:44:03,310 --> 00:44:04,850
当然 那就是用代码了

1004
00:44:04,850 --> 00:44:05,950
你创建一个UI按钮

1005
00:44:05,950 --> 00:44:06,620
就已经有了

1006
00:44:06,620 --> 00:44:09,040
它的配置和初始化方法等等

1007
00:44:09,040 --> 00:44:10,590
但是你基本不会这么做的

1008
00:44:10,590 --> 00:44:12,890
我们总是用图形化方法来实现

1009
00:44:12,890 --> 00:44:15,910
因为这能够帮助你看清楚UI的样子

1010
00:44:15,910 --> 00:44:19,360
学生:(我们可以看到系统生成了什么吗)

1011
00:44:19,360 --> 00:44:19,930
很好的问题

1012
00:44:19,930 --> 00:44:21,970
可以看到这些生成了什么吗

1013
00:44:21,970 --> 00:44:23,320
答案是 并不是真的能看到

1014
00:44:23,320 --> 00:44:25,180
因为这不是一个代码生成器

1015
00:44:25,180 --> 00:44:27,740
这些对象实际上存档在磁盘上

1016
00:44:27,740 --> 00:44:29,790
它在运行的时候它们还没存档

1017
00:44:29,790 --> 00:44:30,530
它们是被引入到这儿的

1018
00:44:30,530 --> 00:44:32,620
这儿没有代码生成

1019
00:44:32,620 --> 00:44:34,960
好的 按钮只能够 你知道

1020
00:44:34,960 --> 00:44:37,390
将它们的属性保存在磁盘上

1021
00:44:37,400 --> 00:44:39,330
然后 当你加载storyboard的时候

1022
00:44:39,330 --> 00:44:41,040
按钮将会把属性读出来

1023
00:44:41,040 --> 00:44:42,320
我们稍后会讨论到这个问题

1024
00:44:42,320 --> 00:44:44,540
所以 我们来讨论一下怎么 好的 快点

1025
00:44:44,550 --> 00:44:45,020
好的

1026
00:44:45,020 --> 00:44:52,680
学生:(听不清)

1027
00:44:52,680 --> 00:44:55,670
啊 我们稍后再来讨论那个问题

1028
00:44:55,670 --> 00:44:58,250
现在时间所剩不多了

1029
00:44:58,250 --> 00:44:59,580
我不想拖堂太久

1030
00:44:59,580 --> 00:45:01,040
但是 我会课下跟你讨论

1031
00:45:01,040 --> 00:45:06,910
很抱歉 我们快点来创建模型

1032
00:45:06,910 --> 00:45:07,940
好的 所以 这是我们的控制器

1033
00:45:07,940 --> 00:45:09,860
这是视图 太棒了

1034
00:45:09,860 --> 00:45:11,240
快点儿来创建模型

1035
00:45:11,240 --> 00:45:13,620
我们创建模型的方法是

1036
00:45:13,620 --> 00:45:14,770
我先停止模拟器

1037
00:45:14,770 --> 00:45:17,360
我们创建模型的方法非常直接

1038
00:45:17,360 --> 00:45:20,720
进入到文件菜单 选择新文件New File

1039
00:45:20,720 --> 00:45:22,410
在X-Code里 用新文件

1040
00:45:22,410 --> 00:45:25,080
可以创建很多东西

1041
00:45:25,090 --> 00:45:26,870
不仅仅是新的类如objective-C类

1042
00:45:26,880 --> 00:45:29,050
或者是像这样的新控制器

1043
00:45:29,050 --> 00:45:29,930
除此之外

1044
00:45:29,930 --> 00:45:32,030
你还可以创建一个新的数据库图像描述

1045
00:45:32,030 --> 00:45:33,550
是的 用这个数据模型就可以

1046
00:45:33,550 --> 00:45:34,860
所以 这儿有很多可以做的

1047
00:45:34,860 --> 00:45:37,450
但是 今天我们只要创建新的类

1048
00:45:37,460 --> 00:45:39,930
我们点击 点击创建新类

1049
00:45:39,930 --> 00:45:43,320
我们将模型命名为CalculatorBrain

1050
00:45:43,320 --> 00:45:46,200
我们也可以把它叫做CalculatorModel

1051
00:45:46,200 --> 00:45:49,800
但是我喜欢CalculatorBrain这个名字 更形象

1052
00:45:49,800 --> 00:45:51,990
我们要确保

1053
00:45:51,990 --> 00:45:55,640
所有文件都保存在相同的路径下

1054
00:45:55,640 --> 00:45:59,080
好了 创建完成

1055
00:45:59,080 --> 00:46:01,600
现在 可以看到在控制器里面

1056
00:46:01,600 --> 00:46:03,690
有我们的CalculatorBrain.m和CalculatorBrain.h

1057
00:46:03,690 --> 00:46:05,390
我要收起这部分 还有这边

1058
00:46:05,390 --> 00:46:09,530
左边是实现文件

1059
00:46:09,540 --> 00:46:12,480
右边是头文件

1060
00:46:12,480 --> 00:46:15,540
我要添加一个公共方法

1061
00:46:15,540 --> 00:46:17,680
现在 这是我们的RPN calculatorbrain

1062
00:46:17,680 --> 00:46:18,720
它现在是空白

1063
00:46:18,720 --> 00:46:20,150
它只知道两项操作

1064
00:46:20,150 --> 00:46:22,480
一项是将操作数送入其堆栈

1065
00:46:22,490 --> 00:46:23,800
另一项是对堆栈上的内容

1066
00:46:23,800 --> 00:46:25,920
进行运算操作

1067
00:46:25,920 --> 00:46:30,290
所以 这两个公共方法是pushOperand

1068
00:46:30,290 --> 00:46:37,250
用double类型值作为参数  还有一个performOperation

1069
00:46:37,250 --> 00:46:42,580
用NSString类型值来指定运算

1070
00:46:42,580 --> 00:46:45,490
我把这里拉大一点让你们看清楚

1071
00:46:45,490 --> 00:46:47,970
这些字符串与按钮上的字符串是一样的

1072
00:46:47,970 --> 00:46:50,030
很可能是非常糟糕的设计

1073
00:46:50,030 --> 00:46:52,580
但是我们的例子做了简化

1074
00:46:52,590 --> 00:46:55,120
将运算符作为字符串来处理还不是太糟糕

1075
00:46:55,120 --> 00:46:57,370
但是直接使用UI中的字符串作为运算符

1076
00:46:57,370 --> 00:46:58,570
出于本地化或者其他原因

1077
00:46:58,570 --> 00:47:00,650
你或许不想要那么做

1078
00:47:00,650 --> 00:47:01,810
但是我们这里需要那样做

1079
00:47:01,810 --> 00:47:04,270
接下来 这就是我们整个公共API

1080
00:47:04,270 --> 00:47:05,990
只有这两个方法

1081
00:47:05,990 --> 00:47:09,060
注意我将公共API添加到头文件时

1082
00:47:09,060 --> 00:47:10,640
在这得到了一个警告

1083
00:47:10,640 --> 00:47:12,210
看看这些黄色的小三角形

1084
00:47:12,210 --> 00:47:14,490
我们不想花时间讨论这个

1085
00:47:14,490 --> 00:47:17,510
当我们 如果你点击这些警告

1086
00:47:17,510 --> 00:47:19,140
它会告诉你问题出在哪里

1087
00:47:19,140 --> 00:47:20,570
当你打字的时候 它会随时显示

1088
00:47:20,570 --> 00:47:23,450
所以 基本上 X-Code在不断地编译

1089
00:47:23,450 --> 00:47:25,190
解析你的代码

1090
00:47:25,200 --> 00:47:28,970
这是正常的 我们的实现文件还没有完成

1091
00:47:28,970 --> 00:47:30,250
因为我们有这两条公共方法

1092
00:47:30,250 --> 00:47:31,480
却还没有实现它们

1093
00:47:31,480 --> 00:47:32,740
是的 我们来解决它

1094
00:47:32,740 --> 00:47:36,980
我要把它们全部复制粘贴在这儿

1095
00:47:36,980 --> 00:47:40,410
然后添加一些存根实现

1096
00:47:40,410 --> 00:47:42,070
这里空着

1097
00:47:42,070 --> 00:47:45,930
我要在这儿创建一个小局部变量

1098
00:47:45,930 --> 00:47:51,290
然后返回它 在它们之间 我们将

1099
00:47:51,290 --> 00:47:55,000
糟糕 糟糕 抱歉 好了

1100
00:47:55,000 --> 00:48:01,010
计算结果

1101
00:48:01,010 --> 00:48:04,750
好的 这就是我们的两个公共方法

1102
00:48:04,750 --> 00:48:05,690
这真是太棒了

1103
00:48:05,690 --> 00:48:07,250
现在来实现我们的模型brain

1104
00:48:07,250 --> 00:48:09,560
我们需要那个堆栈

1105
00:48:09,560 --> 00:48:11,750
记得我们有一个存储操作的堆栈

1106
00:48:11,750 --> 00:48:13,260
每次我们按一个操作时

1107
00:48:13,260 --> 00:48:14,900
我们把所有需要的操作都取出来

1108
00:48:14,910 --> 00:48:16,850
那我们如何实现这个堆栈呢

1109
00:48:16,850 --> 00:48:21,150
一个很简单的办法是使用数组

1110
00:48:21,150 --> 00:48:24,540
因为在大多数语言里都有包含对象的数组

1111
00:48:24,540 --> 00:48:25,970
当然objective-C也有

1112
00:48:25,970 --> 00:48:28,110
当你在末尾添加一个对象时

1113
00:48:28,110 --> 00:48:29,280
数组就变得更大一点儿

1114
00:48:29,280 --> 00:48:31,160
如果你去掉最后的一个对象

1115
00:48:31,160 --> 00:48:32,290
它就变得小一点儿

1116
00:48:32,290 --> 00:48:33,730
这就是堆栈的工作方式

1117
00:48:33,730 --> 00:48:37,060
所以入栈我们要给数组添加一个对象

1118
00:48:37,060 --> 00:48:37,640
而出栈

1119
00:48:37,640 --> 00:48:39,600
我们将删除数组中最后一个对象

1120
00:48:39,610 --> 00:48:43,510
好的 使用数组来实现堆栈很简单

1121
00:48:43,510 --> 00:48:44,950
所以 想要实现这部分

1122
00:48:44,950 --> 00:48:47,390
我们需要一个专有接口

1123
00:48:47,390 --> 00:48:48,810
因为它是专有属性

1124
00:48:48,810 --> 00:48:50,400
这个堆栈不是公共的

1125
00:48:50,400 --> 00:48:52,970
当取出一项操作并执行其实现部分

1126
00:48:52,970 --> 00:48:55,920
是在我们的模型中的

1127
00:48:55,920 --> 00:48:56,810
它不是公共的

1128
00:48:56,810 --> 00:48:58,830
所以 这应该是nonatomic

1129
00:48:58,830 --> 00:49:04,760
糟糕 抱歉 这是Calculatorbrain()方法

1130
00:49:04,760 --> 00:49:08,030
好的 这里是我们的专有接口

1131
00:49:08,030 --> 00:49:10,310
然后设置属性 nonatomic

1132
00:49:10,310 --> 00:49:12,060
当然是强类型

1133
00:49:12,060 --> 00:49:14,680
因为我们是唯一对此指针感兴趣的人

1134
00:49:14,680 --> 00:49:16,880
所以我们要使用强指针

1135
00:49:16,880 --> 00:49:21,140
它是NSMutableArray类型

1136
00:49:21,140 --> 00:49:23,330
我将它命名为operandStack

1137
00:49:23,330 --> 00:49:28,740
我往这边拉一点

1138
00:49:28,740 --> 00:49:30,660
好的 这就是我们的属性

1139
00:49:30,660 --> 00:49:33,570
现在 Mutablearray 还有一个NSArray

1140
00:49:33,580 --> 00:49:35,910
在objective-C里 那是不可变数组

1141
00:49:35,910 --> 00:49:38,170
如果你在数组里包括了确定数目的对象

1142
00:49:38,170 --> 00:49:40,530
你不能对数目进行修改 不能添加或删除

1143
00:49:40,530 --> 00:49:43,170
NSArray有一个子类MutableArray

1144
00:49:43,170 --> 00:49:44,680
它允许你添加和删除

1145
00:49:44,680 --> 00:49:46,130
添加很多添加和删除的方法

1146
00:49:46,140 --> 00:49:48,330
这是我们想要的

1147
00:49:48,330 --> 00:49:50,230
你们认为这个黄色警告为什么会出现在这

1148
00:49:50,230 --> 00:49:52,810
有人知道吗

1149
00:49:53,820 --> 00:49:54,930
因为我们没有使用它

1150
00:49:54,930 --> 00:49:57,250
并不是这样 是的

1151
00:49:57,250 --> 00:49:58,330
因为我们没有使用synthesize

1152
00:49:58,330 --> 00:50:01,130
对啦 它告诉你没有getter 这有两个错

1153
00:50:01,130 --> 00:50:02,750
点击它就都能看到了

1154
00:50:02,750 --> 00:50:05,030
意思是这里还没有setter和getter

1155
00:50:05,030 --> 00:50:07,140
所以让他们在那吧 我们继续

1156
00:50:07,140 --> 00:50:12,210
@ synthesize operandStack = _operandStack

1157
00:50:12,210 --> 00:50:15,200
现在 我要给你们演示一下 synthesize会创建什么

1158
00:50:15,200 --> 00:50:17,730
这就是synthesize将为我们创建的东西

1159
00:50:17,730 --> 00:50:20,680
(NSMutableArray * ) operand stack

1160
00:50:20,680 --> 00:50:23,090
return _ operandStack

1161
00:50:23,090 --> 00:50:27,570
(void)setOperandStack

1162
00:50:27,570 --> 00:50:30,230
_operandStack =

1163
00:50:30,230 --> 00:50:33,130
这边的这个参数是 operandStack

1164
00:50:33,130 --> 00:50:36,750
好的 所以对nonatomic的属性来说

1165
00:50:36,750 --> 00:50:38,350
这就是是synthesize生成的东西

1166
00:50:38,350 --> 00:50:40,920
synthesize会生成这两样东西

1167
00:50:40,920 --> 00:50:43,040
现在 我们不需要这段代码

1168
00:50:43,040 --> 00:50:44,640
因为我们用了synthesize

1169
00:50:44,640 --> 00:50:46,090
但是 我要把它们留在这儿

1170
00:50:46,090 --> 00:50:46,910
你等会就会知道为什么要这么做

1171
00:50:46,910 --> 00:50:51,250
学生:(听不清)

1172
00:50:51,250 --> 00:50:54,230
是的 这里需要是强类型

1173
00:50:54,230 --> 00:50:55,760
无论你是否实现

1174
00:50:55,760 --> 00:50:58,750
strong告诉了编译器要如何使用内存

1175
00:50:58,750 --> 00:51:01,640
这儿的这个指针的指向

1176
00:51:01,640 --> 00:51:04,200
学生:(听不清)

1177
00:51:04,200 --> 00:51:06,600
不 是的 Strong不仅仅生成代码

1178
00:51:06,600 --> 00:51:08,680
它是编译器帮助你管理内存的方法

1179
00:51:08,680 --> 00:51:12,070
不是帮你管理内存 是直接管理内存

1180
00:51:12,080 --> 00:51:14,730
好的 我们来写pushOperand

1181
00:51:14,730 --> 00:51:16,460
这项操作很简单

1182
00:51:16,460 --> 00:51:19,070
我们只要获取operandStack

1183
00:51:19,070 --> 00:51:21,300
噢 有件事周二我忘了说 很重要的

1184
00:51:21,300 --> 00:51:24,200
访问实例变量 _operandStack

1185
00:51:24,200 --> 00:51:27,240
你只能在setter和getter里面这样做

1186
00:51:27,240 --> 00:51:29,300
不要在其他代码中这样做

1187
00:51:29,300 --> 00:51:31,340
如果你需要在其他地方访问实例变量

1188
00:51:31,340 --> 00:51:32,980
要用setter 和 getter

1189
00:51:32,980 --> 00:51:33,790
那是setter和getter的作用

1190
00:51:33,800 --> 00:51:36,100
所以 在这儿我要获取operandStack

1191
00:51:36,100 --> 00:51:40,120
调用NSMutableArray的一个方法addObject

1192
00:51:40,120 --> 00:51:43,030
因为我想要在数组后面添加对象

1193
00:51:43,030 --> 00:51:43,890
这是我要做的事情

1194
00:51:43,890 --> 00:51:46,660
我试着直接添加这个操作数

1195
00:51:46,660 --> 00:51:48,060
但是 当然 这行不通

1196
00:51:48,060 --> 00:51:48,770
你能看到吗 这儿

1197
00:51:48,770 --> 00:51:51,430
这里出现了红色的东西 红色的错误提示

1198
00:51:51,430 --> 00:51:53,360
它说

1199
00:51:53,360 --> 00:51:54,130
将double发送至

1200
00:51:54,140 --> 00:51:56,480
不兼容的id类型的参数 这样不对

1201
00:51:56,480 --> 00:51:57,780
这不是一个对象

1202
00:51:57,780 --> 00:52:01,420
MutableArray只允许你添加对象

1203
00:52:01,420 --> 00:52:03,390
而不是像操作数那样的原始类型

1204
00:52:03,400 --> 00:52:06,270
这里不能用double

1205
00:52:06,270 --> 00:52:10,670
所以 我们需要把double封装在对象里面

1206
00:52:10,670 --> 00:52:12,440
我们将要来那样操作

1207
00:52:12,440 --> 00:52:14,160
通过使用类NSnumber

1208
00:52:14,160 --> 00:52:16,370
来创建一个operandObject

1209
00:52:16,380 --> 00:52:18,020
NSnumber所做的是

1210
00:52:18,020 --> 00:52:20,900
把原始数字包括在对象里

1211
00:52:20,910 --> 00:52:24,590
所以 我们这里写[numberWithDouble : operand]

1212
00:52:24,590 --> 00:52:27,350
好的 现在我们有了一个operandObject

1213
00:52:27,360 --> 00:52:30,440
我们可以将它添加进去 错误就消失了

1214
00:52:30,440 --> 00:52:32,760
实际上 我们并不需要这个局部变量

1215
00:52:32,760 --> 00:52:36,470
我们可以将它放在这儿

1216
00:52:36,470 --> 00:52:37,840
好的 一行代码就可以

1217
00:52:37,840 --> 00:52:39,790
我们在operandStack上输入一些东西

1218
00:52:39,790 --> 00:52:43,430
现在 这行代码有个小问题

1219
00:52:43,430 --> 00:52:45,290
问题在这儿

1220
00:52:45,290 --> 00:52:48,590
我告诉过你们 属性是以什么开始的

1221
00:52:48,590 --> 00:52:50,530
当对象在指针中创建

1222
00:52:50,530 --> 00:52:54,100
0 或 Nil时

1223
00:52:54,100 --> 00:52:57,930
如果你发送消息至Nil时会发生什么事情呢

1224
00:52:57,930 --> 00:52:59,960
什么都没有 是吗 什么都不发生

1225
00:52:59,960 --> 00:53:03,020
所以 这行代码 以Nil开始

1226
00:53:03,020 --> 00:53:04,690
这个空白的代码什么都没做

1227
00:53:04,690 --> 00:53:07,490
把addObject发送给Nil 结果什么也没做

1228
00:53:07,490 --> 00:53:09,730
这是徒劳无用的 很不好

1229
00:53:09,730 --> 00:53:11,270
我们不想让它做无用功

1230
00:53:11,270 --> 00:53:12,710
所以 现在你或许会想

1231
00:53:12,710 --> 00:53:14,100
噢 我需要一个构造函数

1232
00:53:14,100 --> 00:53:16,660
那样我才能对属性进行设置

1233
00:53:16,660 --> 00:53:19,970
对啦 在objective C里确实有构造函数

1234
00:53:19,970 --> 00:53:21,670
我们称之为初始化程序

1235
00:53:21,670 --> 00:53:26,170
但那并不是进行构建的最佳选择

1236
00:53:26,170 --> 00:53:29,960
确保operandStack不是Nil的最佳位置

1237
00:53:29,960 --> 00:53:33,400
是在它的getter中

1238
00:53:33,400 --> 00:53:35,040
我们往上去找它的getter

1239
00:53:35,040 --> 00:53:36,830
就在这儿

1240
00:53:36,840 --> 00:53:38,490
现在我马上把它展示给你们看

1241
00:53:38,490 --> 00:53:40,120
我们要实现getter了

1242
00:53:40,120 --> 00:53:40,580
所以我们直接这样写

1243
00:53:40,580 --> 00:53:46,030
if (_operandStack = nil) then operandStack =...

1244
00:53:46,030 --> 00:53:47,300
我要进行分配

1245
00:53:47,300 --> 00:53:51,550
我们来谈谈怎么在数组里面做分配

1246
00:53:51,550 --> 00:53:55,610
这里不会获取一个值为Nil的operandStack

1247
00:53:55,610 --> 00:53:58,970
因为如果它是Nil 我就会对它进行分配

1248
00:53:58,970 --> 00:54:01,240
我只要对它进行一次分配就行了

1249
00:54:01,250 --> 00:54:03,880
因为一旦分配 就不可能再成为Nil了

1250
00:54:03,880 --> 00:54:07,240
大家都懂了吗 这叫延迟实例化

1251
00:54:07,240 --> 00:54:10,670
它不到最后一秒 不会实例化你需要的东西

1252
00:54:10,670 --> 00:54:12,350
这在iOS里非常常见

1253
00:54:12,350 --> 00:54:14,120
所以 这儿我不需要setter

1254
00:54:14,120 --> 00:54:15,690
因为我们不在setter里面做任何特殊操作

1255
00:54:15,690 --> 00:54:16,760
但是我们把getter留下

1256
00:54:16,760 --> 00:54:19,530
synthesize不会生成getter

1257
00:54:19,530 --> 00:54:22,170
因为我们做过了

1258
00:54:22,170 --> 00:54:23,820
很好 所以 现在运行operandStack

1259
00:54:23,820 --> 00:54:24,910
这个不会为Nil

1260
00:54:24,910 --> 00:54:27,400
这个getter不会返回Nil 明白吗

1261
00:54:27,400 --> 00:54:27,930
好的 问题

1262
00:54:27,930 --> 00:54:30,720
学生:(听不清)

1263
00:54:30,720 --> 00:54:33,580
不 synthesize不会分配东西 这是个好问题

1264
00:54:33,580 --> 00:54:35,340
synthesize会分配吗 不会

1265
00:54:35,340 --> 00:54:39,580
synthesize所做的只是为指针创建实例变量

1266
00:54:39,580 --> 00:54:42,120
但是指针指向的东西 你得进行分配

1267
00:54:42,120 --> 00:54:42,950
好的 问题

1268
00:54:42,950 --> 00:54:49,750
学生:(听不清)

1269
00:54:49,750 --> 00:54:51,730
正确 问题是如果我不使用nonatomic

1270
00:54:51,730 --> 00:54:52,970
会发生什么事情呢

1271
00:54:52,970 --> 00:54:55,680
答案是 这儿会产生一个警告

1272
00:54:55,680 --> 00:54:58,320
它会说 噢 你重写了getter

1273
00:54:58,320 --> 00:55:00,160
但是没有重写setter

1274
00:55:00,160 --> 00:55:02,510
而你会说你正在把多线程都屏蔽了

1275
00:55:02,510 --> 00:55:04,640
呃...... 所以系统会给你个警告

1276
00:55:04,640 --> 00:55:05,920
它让你这么做 但是系统会提醒你

1277
00:55:05,920 --> 00:55:08,270
系统会给你一个警告

1278
00:55:08,270 --> 00:55:10,280
好的 我们顺便来快速查看一下这里

1279
00:55:10,280 --> 00:55:14,270
如果你需要先离开 请悄悄出去

1280
00:55:14,270 --> 00:55:18,840
我在网上上传了我们现在要来做的这个

1281
00:55:18,840 --> 00:55:20,250
所以 你需要自己来完成

1282
00:55:20,250 --> 00:55:22,140
如果你想待在这儿看我操作

1283
00:55:22,140 --> 00:55:23,920
也可以 没问题

1284
00:55:23,920 --> 00:55:25,320
但是请你们离开的时候轻声点儿

1285
00:55:25,320 --> 00:55:27,150
因为还有人想留在这儿观看

1286
00:55:27,160 --> 00:55:28,890
好的 现在 我们来写执行结果部分

1287
00:55:28,890 --> 00:55:32,630
这里的performOperation 非常好懂

1288
00:55:32,630 --> 00:55:36,060
我把它放到屏幕上方一点儿 方便你们看到

1289
00:55:36,060 --> 00:55:38,560
要执行运算

1290
00:55:38,560 --> 00:55:40,580
取决于那是什么运算

1291
00:55:40,580 --> 00:55:43,550
我们把堆栈的运算调出来进行运算

1292
00:55:43,550 --> 00:55:46,950
如果操作是EqualToString

1293
00:55:46,950 --> 00:55:49,750
这是一个string的方法 这儿我使用一个常数字符串

1294
00:55:49,750 --> 00:55:53,280
正如我在NSLog那边设置的一样 然后

1295
00:55:53,280 --> 00:56:00,720
the result =[ self popOperand] + [self popOperand]

1296
00:56:00,720 --> 00:56:03,240
当然 这边就出现错误了

1297
00:56:03,250 --> 00:56:05,630
因为我们还没有实现popOperand

1298
00:56:05,630 --> 00:56:08,200
但是这个错误很容易修正 我们来实现就是了

1299
00:56:08,210 --> 00:56:12,090
(double)popOperand 我们这里这样写

1300
00:56:12,090 --> 00:56:16,450
把数从堆栈中取出NSnumber *operandObject

1301
00:56:16,460 --> 00:56:21,450
=[ self.operandStack lastObject ]

1302
00:56:21,450 --> 00:56:23,600
lastObject是NSArray的一个方法

1303
00:56:23,600 --> 00:56:25,670
它能把指针指向最后一个对象

1304
00:56:25,670 --> 00:56:27,850
而不是复制它 就是一个指针

1305
00:56:27,850 --> 00:56:29,870
但是 现在我们得到了最后一个对象 真是太棒了

1306
00:56:29,880 --> 00:56:33,240
现在我们可以返回它的double值

1307
00:56:33,240 --> 00:56:38,080
通过发送operandObject 这是个NSnumber 然后doubleValue

1308
00:56:38,090 --> 00:56:40,530
这个就是用doubleValue方法返回的数字

1309
00:56:40,530 --> 00:56:41,030
不是吗

1310
00:56:41,030 --> 00:56:42,960
现在 这儿看起来好像不太对

1311
00:56:42,960 --> 00:56:45,660
因为这本应该是popOperand

1312
00:56:45,660 --> 00:56:48,310
这似乎更像是peekOperand

1313
00:56:48,310 --> 00:56:50,330
因为它只查看了数组的结尾

1314
00:56:50,330 --> 00:56:54,650
我们需要删除操作的最后一个对象

1315
00:56:54,650 --> 00:56:59,760
用这个NSMutableArray的方法叫作removeLastObject

1316
00:56:59,760 --> 00:57:02,430
但是要更小心一点

1317
00:57:02,430 --> 00:57:06,110
因为如果我们删除空数组中的对象

1318
00:57:06,110 --> 00:57:08,330
不是Nil 而是空数组 是吧

1319
00:57:08,330 --> 00:57:09,470
我们还没放入任何东西呢

1320
00:57:09,470 --> 00:57:12,750
数组索引超出界限会使程序崩溃

1321
00:57:12,750 --> 00:57:14,960
lastObject没有那样的问题

1322
00:57:14,960 --> 00:57:16,170
因为它只是在那里查看了一下

1323
00:57:16,170 --> 00:57:19,000
但是removeLastObject会使程序崩溃

1324
00:57:19,000 --> 00:57:25,740
所以 我们需要这样写if (operandObject )

1325
00:57:25,740 --> 00:57:28,490
if (operandObject != Nil)

1326
00:57:28,500 --> 00:57:32,190
或者直接写if (operandObject ) 好了

1327
00:57:32,190 --> 00:57:34,620
通常 我们只写operandObject就行了

1328
00:57:34,620 --> 00:57:37,470
好的 看看为什么我们要为预防崩溃

1329
00:57:37,470 --> 00:57:38,830
而做一点儿自我保护

1330
00:57:38,830 --> 00:57:40,180
这儿我们取出了操作数

1331
00:57:40,180 --> 00:57:43,420
所以 既然现在我们时间有限

1332
00:57:43,420 --> 00:57:46,080
我不准备将剩下的运算加进来

1333
00:57:46,080 --> 00:57:47,440
我们要怎么编造它们呢

1334
00:57:47,440 --> 00:57:48,290
实际上 我们要再做一个运算

1335
00:57:48,290 --> 00:57:50,770
因为我想给你们演示另一个有趣的事件

1336
00:57:50,770 --> 00:57:53,940
这个如何

1337
00:58:02,520 --> 00:58:07,760
好的 注意到我正在向常量字符串发送消息

1338
00:58:07,760 --> 00:58:10,290
那样可以吗 绝对没问题

1339
00:58:10,290 --> 00:58:13,560
常量字符串和其他字符串并没有很大的区别

1340
00:58:13,560 --> 00:58:15,600
这是字符串 因为这儿有个参数

1341
00:58:15,610 --> 00:58:17,010
这是一个字符串

1342
00:58:17,010 --> 00:58:19,510
常量字符串是由编译器产生的

1343
00:58:19,520 --> 00:58:23,770
所以不用担心 完全没问题

1344
00:58:23,770 --> 00:58:25,220
接下来最后要做的一件事是

1345
00:58:25,220 --> 00:58:27,320
我们要进行另外一个运算

1346
00:58:27,320 --> 00:58:29,360
你们的作业是在这儿添加一些运算

1347
00:58:29,360 --> 00:58:32,210
希望你们知道怎么做

1348
00:58:32,210 --> 00:58:34,820
但是我们要明确一点

1349
00:58:34,820 --> 00:58:39,250
我们要把这些结果推回到堆栈

1350
00:58:39,250 --> 00:58:41,330
因为我们要能够继续进行运算

1351
00:58:41,330 --> 00:58:43,360
下一个输入的运算

1352
00:58:43,360 --> 00:58:44,740
好的 明白了吗

1353
00:58:44,740 --> 00:58:46,350
大家懂得这个模型吗

1354
00:58:46,350 --> 00:58:48,260
这就是我们的模型 它就是这样子的

1355
00:58:48,260 --> 00:58:51,660
你输入操作数 然后执行运算

1356
00:58:51,660 --> 00:58:52,940
它会弹出你需要的操作数

1357
00:58:52,940 --> 00:58:54,770
有些运算可能只需要一个操作数

1358
00:58:54,770 --> 00:58:57,440
比如计算平方根 你们要在作业里完成

1359
00:58:57,440 --> 00:58:58,740
它只需要一个操作数

1360
00:58:58,740 --> 00:59:01,140
所以它只从堆栈中提取了一个操作数

1361
00:59:01,140 --> 00:59:03,790
我要你们做的有个运算就是π

1362
00:59:03,790 --> 00:59:06,270
π运算不需要操作数

1363
00:59:06,270 --> 00:59:10,140
π运算不需要操作数来做什么事情

1364
00:59:10,140 --> 00:59:13,330
所以执行运算可以从堆栈中取出任意多个运算对象

1365
00:59:13,330 --> 00:59:14,440
只要它需要

1366
00:59:14,440 --> 00:59:15,900
取决于你要它做什么

1367
00:59:15,900 --> 00:59:18,380
这两个需要两个操作数

1368
00:59:18,380 --> 00:59:19,670
所以它取出两个

1369
00:59:19,670 --> 00:59:22,760
那就是它的功能

1370
00:59:22,760 --> 00:59:26,390
现在我们回到控制器完成全部操作

1371
00:59:26,390 --> 00:59:28,350
由于我们有模型

1372
00:59:28,350 --> 00:59:29,480
这个操作将是很直接的

1373
00:59:29,480 --> 00:59:32,490
所以 我要回控制器 只要在上面这里

1374
00:59:32,490 --> 00:59:34,040
顶部的这栏

1375
00:59:34,040 --> 00:59:36,980
从CalculatorBrain切换到ViewController

1376
00:59:36,980 --> 00:59:39,520
嗯 我需要做的第一件事

1377
00:59:39,520 --> 00:59:42,040
将brain导入到控制器controller

1378
00:59:42,040 --> 00:59:45,230
这是我的CalculatorViewController的实现文件

1379
00:59:45,230 --> 00:59:48,540
我在导入我的模型 现在我可以使用了

1380
00:59:48,540 --> 00:59:51,530
在右手边这儿 它是自动的

1381
00:59:51,530 --> 00:59:54,210
系统辅助工具自动提示了

1382
00:59:54,210 --> 00:59:56,580
将控制器头文件放在这里

1383
00:59:56,580 --> 00:59:58,000
但是实际上我不想要那个

1384
00:59:58,000 --> 01:00:01,080
我想要的是我的CalculatorBrain

1385
01:00:01,080 --> 01:00:02,640
我的模型的头文件

1386
01:00:02,650 --> 01:00:04,280
因为我想用它的公共API

1387
01:00:04,280 --> 01:00:06,110
所以如果你那样操作了 你可以看看这儿

1388
01:00:06,110 --> 01:00:07,680
你可以用到的

1389
01:00:07,680 --> 01:00:08,570
各种各样的辅助工具

1390
01:00:08,570 --> 01:00:12,210
其中的一种辅助工具显示出我引用的一些东西

1391
01:00:12,210 --> 01:00:14,850
因为我在左边添加了CalculatorBrain

1392
01:00:14,850 --> 01:00:16,130
我可以展开这项

1393
01:00:16,130 --> 01:00:19,000
然后选择在右边显示我的CalculatorBrain

1394
01:00:19,000 --> 01:00:21,210
现在当我使用控制器的时候

1395
01:00:21,210 --> 01:00:22,780
我可以看到我的模型的公共API

1396
01:00:22,780 --> 01:00:25,670
这就很方便了 好的

1397
01:00:25,670 --> 01:00:29,770
所以 我们在控制器上还要做的是两个事情

1398
01:00:29,770 --> 01:00:31,350
enterPressed和 operationPressed

1399
01:00:31,350 --> 01:00:34,150
现在我们有功能强大的模型

1400
01:00:34,150 --> 01:00:36,820
它实际上很容易实现这两个

1401
01:00:36,820 --> 01:00:39,980
enterPressed仅输入数字

1402
01:00:39,980 --> 01:00:41,420
是吧 只要输入......

1403
01:00:41,420 --> 01:00:44,270
无论显示屏上有什么数字

1404
01:00:44,270 --> 01:00:46,020
只要输入模型就可以了

1405
01:00:46,020 --> 01:00:49,170
我们需要做的是

1406
01:00:49,170 --> 01:00:51,350
我们需要一个指向模型的指针

1407
01:00:51,350 --> 01:00:53,950
好的 几乎所有的控制器

1408
01:00:53,950 --> 01:00:56,770
都将有一个专有属性

1409
01:00:56,770 --> 01:01:00,290
不是所有都有 但是几乎都有

1410
01:01:00,290 --> 01:01:04,810
这个属性是strong的 属于CalculatorBrain

1411
01:01:04,810 --> 01:01:07,760
叫它brain'好了

1412
01:01:07,760 --> 01:01:13,060
当然 我需要synthesize它 等于_brain

1413
01:01:13,060 --> 01:01:17,350
我们现在要做延迟实例化 就在这下面

1414
01:01:17,360 --> 01:01:20,040
(CaclulatorBrain * ) barin

1415
01:01:20,040 --> 01:01:23,290
if(!brain) 如果还没有brain的话

1416
01:01:23,290 --> 01:01:28,690
brain = [[CaclulatorBrain alloc] init]

1417
01:01:28,690 --> 01:01:32,040
好的 下周我们要讨论一下分配初始化的情况

1418
01:01:32,040 --> 01:01:36,080
接下来我要返回brain

1419
01:01:36,080 --> 01:01:42,390
现在不论何时我调用getter

1420
01:01:42,780 --> 01:01:44,050
不论何时我呼叫我的getter

1421
01:01:44,050 --> 01:01:46,110
brain都会实例化

1422
01:01:46,120 --> 01:01:47,560
因为我将其延迟实例化了

1423
01:01:47,560 --> 01:01:48,900
在任何人需要它的任何时候

1424
01:01:48,900 --> 01:01:53,240
这是让代码强壮的好办法

1425
01:01:53,240 --> 01:01:55,610
因为你可以保护你的getter

1426
01:01:55,610 --> 01:01:59,230
以防你不想要任何的属性

1427
01:01:59,230 --> 01:02:01,250
我们非常容易理解

1428
01:02:01,250 --> 01:02:03,090
通常人们会看你的getter

1429
01:02:03,090 --> 01:02:06,370
查明大多数属性中哪些内容进行了实例化

1430
01:02:06,370 --> 01:02:08,480
要是没有getter 他们会四处寻找

1431
01:02:08,480 --> 01:02:10,760
它在哪里啊 初始化程序......等等

1432
01:02:10,760 --> 01:02:12,940
所以最好把它放在getter里面

1433
01:02:12,940 --> 01:02:14,730
好的 在entrePressed中

1434
01:02:14,730 --> 01:02:18,040
我们直接写self.brain pushOperand

1435
01:02:18,040 --> 01:02:19,230
我们需要输入操作数

1436
01:02:19,230 --> 01:02:21,170
这个操作很简单

1437
01:02:21,170 --> 01:02:23,280
我们要获取我们的display.text

1438
01:02:23,280 --> 01:02:25,200
大家明白为什么我刚才要这么做吗

1439
01:02:25,200 --> 01:02:26,550
self. display.text

1440
01:02:26,550 --> 01:02:29,620
和我们刚才做的一样 对吧

1441
01:02:29,620 --> 01:02:33,130
我要发送那个字符串 到方法doubleValue

1442
01:02:33,130 --> 01:02:34,380
就像我发送NSnumber一样

1443
01:02:34,380 --> 01:02:37,770
所以不仅NSnumber实现了doubleValue

1444
01:02:37,770 --> 01:02:38,540
还有NSString

1445
01:02:38,540 --> 01:02:40,910
NSString查看自己的内容

1446
01:02:40,910 --> 01:02:42,810
如果里面有个hello

1447
01:02:42,810 --> 01:02:43,670
它会变成0

1448
01:02:43,670 --> 01:02:45,360
但是如果是个数字

1449
01:02:45,360 --> 01:02:46,840
系统会将它变成double类型

1450
01:02:46,840 --> 01:02:48,470
很方便

1451
01:02:48,470 --> 01:02:50,230
这边我还要做的一件事是

1452
01:02:50,230 --> 01:02:51,230
如果我按下Enter

1453
01:02:51,230 --> 01:02:53,690
我就不再处于输入数字的过程中了

1454
01:02:53,690 --> 01:02:55,440
当然地 我就这样把它输入了

1455
01:02:55,440 --> 01:02:59,530
所以这里要写self.userIsInTheMiddleOfEnteringNumber=NO

1456
01:02:59,530 --> 01:03:02,290
好的 这就是是Enter的操作 Enter很简单

1457
01:03:02,290 --> 01:03:04,910
OperationPressed也很简单 好的

1458
01:03:04,910 --> 01:03:07,030
对于operationPressed我要做的是

1459
01:03:07,030 --> 01:03:10,260
我们要执行运算 因此这里写

1460
01:03:10,260 --> 01:03:15,770
double result = [self.brain performOperation:

1461
01:03:15,770 --> 01:03:19,130
我需要将它发送到运算 好的

1462
01:03:19,130 --> 01:03:21,930
现在 我要在这儿做同样的事

1463
01:03:21,930 --> 01:03:24,090
我知道这个按键会给我发送这个

1464
01:03:24,090 --> 01:03:25,950
所以我要改变这个(UIButton

1465
01:03:25,950 --> 01:03:27,470
大家明白为什么我要这样做吗

1466
01:03:27,470 --> 01:03:29,440
和我刚才在上面做的其实是一样的

1467
01:03:29,440 --> 01:03:32,220
好的 我要利用这个编译器来向我提供更多的帮助

1468
01:03:32,220 --> 01:03:33,660
是编译器的工作了

1469
01:03:33,660 --> 01:03:36,010
现在我需要运算符的字符串

1470
01:03:36,010 --> 01:03:37,500
运算符的字符串

1471
01:03:37,500 --> 01:03:41,800
是我们的操作按钮的标题 我知道这个设计不好

1472
01:03:41,800 --> 01:03:47,490
好的 这里写sender.currentTitle

1473
01:03:47,670 --> 01:03:48,270
大家明白这是为什么吗

1474
01:03:48,270 --> 01:03:51,680
好的 现在我获得了结果 但是它是double类型的

1475
01:03:51,680 --> 01:03:54,000
我需要把double转成字符串string类型

1476
01:03:54,000 --> 01:03:55,410
然后放入display

1477
01:03:55,410 --> 01:03:57,950
因为当我进行运算时 我需要显示出来

1478
01:03:57,950 --> 01:04:04,160
所以我要创建这个字符串 叫做resultString

1479
01:04:04,160 --> 01:04:07,130
我要使用一个NSString的一个类方法

1480
01:04:07,130 --> 01:04:10,370
下周我们来讨论一下这个类方法

1481
01:04:10,370 --> 01:04:13,730
叫做Called stringWithFormat

1482
01:04:13,730 --> 01:04:17,190
它的格式类似printf

1483
01:04:17,200 --> 01:04:18,330
我现在使用% g

1484
01:04:18,330 --> 01:04:20,750
这是一个浮点数 好的

1485
01:04:20,750 --> 01:04:24,010
把结果放在这边

1486
01:04:24,020 --> 01:04:25,860
现在我有了resultString字符串

1487
01:04:25,860 --> 01:04:27,680
把结果作为字符串

1488
01:04:27,680 --> 01:04:32,330
我使用string的这个方法实现

1489
01:04:32,330 --> 01:04:33,800
不要太担心这一点

1490
01:04:33,810 --> 01:04:35,770
这个接收器有点奇怪

1491
01:04:35,770 --> 01:04:37,440
因为这不是一个实例化 对吧

1492
01:04:37,440 --> 01:04:40,300
这是类本身 接下来我将它转成

1493
01:04:40,300 --> 01:04:46,140
但是现在我只要这样self.display.text = resultString

1494
01:04:46,140 --> 01:04:48,020
好的 这是我在operationPressed中

1495
01:04:48,020 --> 01:04:49,650
要做的唯一一件事

1496
01:04:49,650 --> 01:04:51,460
我要使终端更友好一些

1497
01:04:51,460 --> 01:04:54,240
如果他们输入6乘以3

1498
01:04:54,240 --> 01:04:55,930
我要替他们按回车键

1499
01:04:55,930 --> 01:04:59,190
所以他们不需要输入6 回车 3 回车 乘号

1500
01:04:59,190 --> 01:05:00,940
好的 我保存并自动输入Enter

1501
01:05:00,940 --> 01:05:03,640
他们正输入数字

1502
01:05:03,640 --> 01:05:08,190
If (self.userIsInTheMiddleofTypingANumber)

1503
01:05:08,190 --> 01:05:11,800
接下来我要输入Enter

1504
01:05:11,800 --> 01:05:13,800
大家都明白我在讲什么了吗

1505
01:05:13,800 --> 01:05:17,630
6 回车3回车+ 而不是 6 回车3 +

1506
01:05:17,630 --> 01:05:19,090
当我那样按+的时候

1507
01:05:19,090 --> 01:05:21,640
它会自动添加回车结束数字输入

1508
01:05:21,640 --> 01:05:24,650
很方便 就是为了用户方便

1509
01:05:24,650 --> 01:05:26,140
好了 就这样

1510
01:05:26,140 --> 01:05:27,290
我们来运行一下

1511
01:05:27,290 --> 01:05:31,430
希望我没有在某些地方犯错误

1512
01:05:31,430 --> 01:05:32,580
这是我们的计算器

1513
01:05:32,580 --> 01:05:37,270
现在我们来试试56 乘以3

1514
01:05:37,270 --> 01:05:41,130
我希望那是56乘以3的结果 7 除以

1515
01:05:41,130 --> 01:05:43,510
糟糕 我没有实现除以 所以结果是0

1516
01:05:43,510 --> 01:05:44,900
好的 这就对了

1517
01:05:44,900 --> 01:05:49,600
所以 36+2 + 3

1518
01:05:49,600 --> 01:05:52,090
当我计算加法的时候运行正常

1519
01:05:52,100 --> 01:05:57,450
6+ 这也行 好的 好的 就这样了

1520
01:05:57,460 --> 01:05:58,330
每个人都明白了吗

1521
01:05:58,340 --> 01:05:59,790
还有问题吗

1522
01:05:59,790 --> 01:06:01,330
好的 我很抱歉拖延了10分钟

1523
01:06:01,340 --> 01:06:04,140
我也不希望拖课 但是我希望大家都明白了

1524
01:06:04,140 --> 01:06:05,240
非常感谢

1525
01:06:06,500 --> 01:06:09,690
斯坦福大学

1526
01:06:07,190 --> 01:06:09,690
有关详细信息 请访问我们的网站Stanford.edu

